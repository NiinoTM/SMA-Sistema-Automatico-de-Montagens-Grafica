<!DOCTYPE html>
<html lang="pt-BR">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <!-- MUDANÇA: Título mais específico -->
    <title>Sistema de Montagem de Planos v0.5.1 (Método Selecionável)</title>
    <link rel="stylesheet" href="base-styles.css">             <!-- Base styles for all media -->
    <link rel="stylesheet" href="responsive-styles.css" media="screen"> <!-- Styles for screen adaptations -->
    <link rel="stylesheet" href="print-styles.css" media="print">    <!-- Styles specifically for printing -->

</head>
<body>

    <!-- Navegação Lateral -->
    <div id="sidebar">
        <h3>Navegação</h3>
        <ul>
            <li><a href="#inputSection">Entradas</a></li>
            <li><a href="#strategyComparison">Comparação de Estratégias</a></li>
            <li><a href="#lpdBreakdown">Montagem dos Planos</a></li>
            <li><a href="#finalSummaryTableDiv">Comparativo <br> Original x Modificado</a></li>
        </ul>
   </div>

    <!-- Área de Conteúdo Principal -->
    <h1 id="inputSection">Sistema de Montagem de Planos (Método Selecionável)</h1>
    <p>Insira os dados de Especificações e Quantidades para processamento. Escolha entre: 1) Otimização por Frequência de Maiores Divisores, que analisa os maiores divisores possíveis de cada produto e seleciona Planos baseados em sua recorrência; ou 2) Cálculo de Combinação Proporcional Direta para distribuição equilibrada. O sistema alocará automaticamente as Especificações conforme o método escolhido, apresentando resultados otimizados.</p>    <!-- Campos de Entrada -->
    <div class="input-group">
        <label for="tableData">Dados da Tabela (Especificação + Quantidade, um por linha):</label>
        <textarea id="tableData" placeholder="Exemplo:
Especificação A	10000
Especificação B	7500
Especificação C	20000
..."></textarea>
    </div>
    <div class="input-group">
        <label for="maxSlots">Imagens no Plano :</label>
        <input type="number" id="maxSlots" min="1" placeholder="ex: 8" required>
    </div>
    <div class="input-group">
        <label for="combinationSize">Quantidade de Planos :</label>
        <input type="number" id="combinationSize" value="1" min="1">
    </div>

    <!-- Botões de Ação -->
    <button onclick="initiateProcess('findBest')" class="primary-action">Otimizar por Frequência de Divisores</button>
    <button onclick="initiateProcess('forceProportional')" class="secondary">Aplicar Distribuição Proporcional</button>

    <!-- Áreas de Saída -->

    <!-- Seção para Resultados da Combinação -->
    <hr>
    <h2 id="finderTitle" class="output-section">Resultados da Combinação</h2>
    <div id="finderResultsLog" class="output-section">O registro da geração da combinação aparecerá aqui...</div>
    <div id="foundCombinationDisplay" class="output-section">A Combinação de Planos gerada aparecerá aqui...</div>

    <!-- Seção para Resultados do Alocador -->
    <hr>
    <h2 id="allocatorTitle" class="output-section">Resultados do Alocador de Especificações</h2>
    <div id="statusArea" class="output-section">Mensagens de status do alocador aparecerão aqui...</div>
    <div id="strategyComparison" class="output-section">Resultados da Comparação de Estratégias aparecerão aqui...</div>
    <hr style="margin-top: 1.5rem; border-top: 1px solid var(--border); margin-bottom: 0.5rem;">
    <h2 id="detailsTitle" class="output-section" style="margin-top: 0.5rem; font-size: 1.1em;">Resultados Detalhados da Alocação</h2>
    <div id="allocationResults" class="output-section">Resultados detalhados da Alocação por Especificação aparecerão aqui...</div>
    <div id="adjustmentLog" class="output-section">Registro de Ajuste de Preenchimento de Imagens aparecerá aqui...</div>
    <div id="variationLog" class="output-section">Registro de Ajuste de Variação aparecerá aqui...</div>
    <div id="cumulativeUsage" class="output-section">Uso acumulado de Planos aparecerá aqui...</div>
    <div id="refinementLog" class="output-section">Registro de Refinamento Iterativo aparecerá aqui...</div>
    <div id="lpdBreakdown" class="output-section">Montagem dos Planos por Instância de Especificação aparecerá aqui...</div>
    <div id="finalSummaryTableDiv" class="output-section">Tabela Comparativa Final da Alocação aparecerá aqui...</div>

    <script>
        // --- ARMAZENAMENTO GLOBAL ---
        let globalStrategyResults = [];
        let globalOriginalItems = []; // Especificações Originais
        let globalUniqueLpdValues = []; // Valores Únicos de Plano
        let globalUserLpdCombinationWithDuplicates = []; // Combinação de Planos do Usuário com Duplicatas
        let globalLpdInstanceCounts = {}; // Contagem de Instâncias de Plano
        let globalInitialTotalSlotsPerValue = {}; // Total Inicial de Imagens por Valor
        let globalMaxSlotsPerInstance = Infinity; // Máximo de Imagens por Instância
        let globalMaxSlotsDisplay = "Ilimitado"; // Exibição Máx Imagens
        let globalCurrentlyDisplayedStrategyName = null; // Track displayed strategy

        // --- REGRAS DE CONFIGURAÇÃO ---
        const MIN_LPD_VALUE = 2000; // Valor Mínimo do Plano
        const OBLIGATORY_RANGE = 500; // Intervalo Obrigatório
        const TARGET_RANGE_BELOW = 500; // Intervalo Alvo Abaixo
        const TARGET_RANGE_ABOVE = 1000; // Intervalo Alvo Acima
        const TARGET_STEP = 500; // Passo do Alvo
        const PROPORTIONAL_ROUNDING_STEP = 50; // Passo de Arredondamento Proporcional
        const MIN_LPD_VALUE_ALLOC = 0; // Valor Mínimo do Plano na Alocação
        const VARIATION_LIMIT_PASS_3 = 0.25; // Limite de Variação Passo 3
        const REPROCESS_VARIATION_LIMIT = 0.30; // Limite de Variação para Reprocessamento

        // --- FUNÇÕES AUXILIARES ---
        function gcd(a, b) { a = Math.abs(a); b = Math.abs(b); if (b === 0) return a; return gcd(b, a % b); } // mdc
        function arrayGcd(numbers) { if (!numbers || numbers.length === 0) return 0; if (numbers.length === 1) return Math.abs(numbers[0]); let result = Math.abs(numbers[0]); for (let i = 1; i < numbers.length; i++) { result = gcd(result, numbers[i]); if (result === 1) return 1; } return result; } // mdcArray
        function findSumCombinationRecursive(lpdValueObjectsToSearch, target, k, startIndex, currentCombinationValues) {
            if (currentCombinationValues.length === k) {
                const currentSum = currentCombinationValues.reduce((sum, item) => sum + item, 0);
                if (Math.abs(currentSum - target) < 0.01) { return [...currentCombinationValues]; }
                return null;
            }
             if (startIndex >= lpdValueObjectsToSearch.length ||
                currentCombinationValues.length > k ||
                (k > 0 && lpdValueObjectsToSearch.length - startIndex < k - currentCombinationValues.length)) { return null; }
            if (k === 0) return null;
            for (let i = startIndex; i < lpdValueObjectsToSearch.length; i++) {
                const currentLpdValue = lpdValueObjectsToSearch[i].value;
                    currentCombinationValues.push(currentLpdValue);
                    const result = findSumCombinationRecursive(lpdValueObjectsToSearch, target, k, i + 1, currentCombinationValues);
                    if (result) { return result; }
                    currentCombinationValues.pop();
            }
            return null;
         }
        function getFrequencyScore(combination, lpdFrequencies) { // obterPontuacaoFrequencia
             let score = 0; for (const lpdValue of combination) { score += (lpdFrequencies[lpdValue] || 0); } return score;
        }
        function roundToNearest(value, multiple) { // arredondarParaMultiploMaisProximo
             if (multiple <= 0) return Math.round(value); return Math.round(value / multiple) * multiple;
        }
        function findClosestSumWithRepetitionAndSlots(uniqueLpdValuesAvailable, target, remainingSlotsMap) { // encontrarSomaMaisProximaComRepeticaoEImagens
            if (!uniqueLpdValuesAvailable || uniqueLpdValuesAvailable.length === 0) { return { sum: 0, difference: 0 - target, combination: [], error: "Nenhum Plano fornecido para alocação" }; }
            if (target < 0) { return { sum: 0, difference: 0 - target, combination: [], error: "Quantidade alvo não pode ser negativa" }; }
            const validLpdsWithSlots = uniqueLpdValuesAvailable.filter(lpd => lpd > 0 && remainingSlotsMap.hasOwnProperty(lpd) && remainingSlotsMap[lpd] > 0).sort((a, b) => a - b);
            if (validLpdsWithSlots.length === 0) { return { sum: 0, difference: 0 - target, combination: [], error: "Lista de Planos vazia ou nenhum Plano tem imagens restantes" }; }
            const smallestLpd = validLpdsWithSlots[0];
            const maxSum = Math.max(target, 0) + smallestLpd;
            const dp = new Array(maxSum + 1).fill(null);
            dp[0] = { count: 0, usage: {}, lastLpd: null };

            for (let i = 1; i <= maxSum; i++) {
                let bestStateForI = null;
                for (const lpd of validLpdsWithSlots) {
                    const prevSum = i - lpd;
                    if (prevSum >= 0 && dp[prevSum] !== null) {
                        const prevState = dp[prevSum];
                        const currentLpdUsageInThisPath = (prevState.usage[lpd] || 0) + 1;
                        const slotsAvailable = remainingSlotsMap[lpd];

                         if (slotsAvailable === Infinity || currentLpdUsageInThisPath <= slotsAvailable) {
                            const newTotalCount = prevState.count + 1;
                            if (bestStateForI === null || newTotalCount < bestStateForI.count) {
                                const newUsage = { ...prevState.usage }; newUsage[lpd] = currentLpdUsageInThisPath;
                                bestStateForI = { count: newTotalCount, usage: newUsage, lastLpd: lpd };
                            }
                        }
                    }
                }
                dp[i] = bestStateForI;
            }

            let minAbsDiff = Infinity; let closestSum = -1; let bestReachableState = null;
            for (let i = target; i >= 0; i--) { if (dp[i] !== null) { const diff = Math.abs(target - i); if (diff < minAbsDiff || (diff === minAbsDiff && dp[i].count < bestReachableState.count)) { minAbsDiff = diff; closestSum = i; bestReachableState = dp[i]; } if (diff > minAbsDiff && closestSum !== -1) break; } }
            for (let i = target + 1; i <= maxSum; i++) { if (dp[i] !== null) { const diff = Math.abs(i - target); if (diff < minAbsDiff || (diff === minAbsDiff && dp[i].count < bestReachableState.count)) { minAbsDiff = diff; closestSum = i; bestReachableState = dp[i]; } if (diff >= minAbsDiff && closestSum !== -1) break; } }

             if (closestSum === -1) {
                 if (target === 0 && dp[0] !== null) {
                     closestSum = 0; bestReachableState = dp[0];
                 } else {
                     return { sum: 0, difference: 0 - target, combination: [], error: "Não foi possível alcançar a soma alvo ou valor próximo" };
                 }
             }

            const combination = []; let currentSum = closestSum; let currentState = bestReachableState; let safetyCounter = 0; const maxLoops = (currentState?.count || 0) + validLpdsWithSlots.length + 100;
            while (currentSum > 0 && currentState?.lastLpd && safetyCounter < maxLoops) { const usedLpd = currentState.lastLpd; combination.push(usedLpd); const prevSum = currentSum - usedLpd; if (prevSum >= 0 && dp[prevSum] !== null) { currentState = dp[prevSum]; currentSum = prevSum; } else { console.error(`Erro de Backtracking DP: Estado faltando para soma ${prevSum}`); return { sum: closestSum, difference: closestSum - target, combination: combination.sort((a, b) => a - b), error: `Erro de backtracking: Estado faltando para soma ${prevSum}` }; } safetyCounter++; }
             if (safetyCounter >= maxLoops) { console.error("Limite de segurança de backtracking DP atingido."); return { sum: closestSum, difference: closestSum - target, combination: combination.sort((a, b) => a - b), error: "Limite de segurança de backtracking atingido" }; }
             if (currentSum !== 0 && closestSum !== 0) { console.error(`Backtracking DP incompleto (soma final ${currentSum})`); return { sum: closestSum, difference: closestSum - target, combination: combination.sort((a, b) => a - b), error: `Backtracking incompleto (soma final ${currentSum})` }; }
             const reconstructedSum = combination.reduce((a, b) => a + b, 0); if (reconstructedSum !== closestSum) { console.error(`Incompatibilidade na reconstrução DP: ${reconstructedSum} != ${closestSum}`); return { sum: closestSum, difference: closestSum - target, combination: combination.sort((a, b) => a - b), error: `Erro de reconstrução (${reconstructedSum} != ${closestSum})` }; }
             const finalUsageCheck = {}; for(const lpd of combination) { finalUsageCheck[lpd] = (finalUsageCheck[lpd] || 0) + 1; if (remainingSlotsMap[lpd] !== Infinity && finalUsageCheck[lpd] > remainingSlotsMap[lpd]) { console.error(`Limite de imagens violado para Plano ${lpd} na verificação (${finalUsageCheck[lpd]} > ${remainingSlotsMap[lpd]})`); return { sum: closestSum, difference: closestSum - target, combination: combination.sort((a, b) => a - b), error: `Limite de imagens violado para Plano ${lpd} na verificação final` }; } }

             return { sum: closestSum, difference: closestSum - target, combination: combination.sort((a, b) => a - b) };
        }
        function calculateMaxVariation(items, allocations) { // calcularVariacaoMaxima
            let maxAbsPercentage = 0; if (!items || !allocations || items.length === 0 || items.length !== allocations.length) return Infinity; // Handle empty/mismatch
            for (let i = 0; i < items.length; i++) { const item = items[i]; const alloc = allocations[i]; if (!alloc || alloc.error || alloc.difference === undefined) continue; const targetAmount = item.amount; const difference = alloc.difference; let currentAbsPercentage = 0; if (targetAmount > 0) { currentAbsPercentage = Math.abs(difference / targetAmount); } else if (alloc.sum !== 0) { currentAbsPercentage = Infinity; } if (currentAbsPercentage > maxAbsPercentage) { maxAbsPercentage = currentAbsPercentage; } }
            return maxAbsPercentage;
         }
        function calculateAverageVariation(items, allocations) { // calcularVariacaoMedia
            let totalPercentageSum = 0; let validItemCount = 0; if (!items || !allocations || items.length === 0 || items.length !== allocations.length) return 0; // Handle empty/mismatch
            for (let i = 0; i < items.length; i++) { const item = items[i]; const alloc = allocations[i]; if (alloc && !alloc.error && alloc.difference !== undefined && item.amount > 0) { const absPercentage = Math.abs(alloc.difference / item.amount); totalPercentageSum += absPercentage; validItemCount++; } }
            return validItemCount > 0 ? totalPercentageSum / validItemCount : 0;
        }
        /**
         * Formats a number using the 'pt-BR' locale ('.' for thousands, ',' for decimals).
         * Rounds to the nearest integer for display in tables.
         * Gracefully handles non-numeric inputs.
         * @param {number|string} value The number to format.
         * @returns {string} The formatted number string or the original value if not a valid number.
         */
        function formatNumberPtBR(value) {
            if (typeof value !== 'number' || isNaN(value)) {
                // If it's already a string (like 'N/A', 'Erro') or invalid, return it as is
                return String(value);
            }
            // Round to nearest integer and format
            try {
                 // Use maximumFractionDigits: 0 to ensure integer output for these tables
                 return Math.round(value).toLocaleString('pt-BR', { maximumFractionDigits: 0 });
            } catch (e) {
                 console.warn("Error formatting number:", value, e);
                 return String(Math.round(value)); // Fallback to unformatted rounded number
            }
        }

        // --- Helper Function to Generate Plan Assembly Data ---
        /**
         * Generates the structured data for plan assembly based on final allocations.
         * @param {Array} finalItems - The items array used in the allocation (ordered by processing).
         * @param {Array} finalAllocations - The corresponding allocation results.
         * @param {Array} userLpdCombinationWithDuplicatesLocal - The original LPD combination used.
         * @param {number|Infinity} maxSlotsNum - Max slots per instance.
         * @returns {Array|null} An array of objects representing each plan instance and its items, or null on error.
         */
        function generatePlanAssemblyData(finalItems, finalAllocations, userLpdCombinationWithDuplicatesLocal, maxSlotsNum) {
            if (!finalItems || !finalAllocations || !userLpdCombinationWithDuplicatesLocal) {
                console.error("generatePlanAssemblyData: Missing input data.");
                return null;
            }
            const maxSlotsIsFinite = maxSlotsNum !== Infinity;
            let planAssemblyDataForExport = [];
            try {
                const allLpdUses = [];
                finalItems.forEach((item, i) => {
                    const finalAlloc = finalAllocations[i];
                    // Only consider successful allocations with combinations
                    if (finalAlloc && !finalAlloc.error && finalAlloc.combination && finalAlloc.combination.length > 0) {
                        finalAlloc.combination.forEach(lpdVal => {
                            allLpdUses.push({ itemIndex: i, itemDetails: item.details, lpdValue: lpdVal, assignedInstanceKey: null });
                        });
                    }
                });

                const lpdInstanceCounters = {};
                const breakdownByInstance = {}; // Temporary map

                // Ensure userLpdCombinationWithDuplicatesLocal is iterable
                 if (!Array.isArray(userLpdCombinationWithDuplicatesLocal)) {
                    console.error("generatePlanAssemblyData: userLpdCombinationWithDuplicatesLocal is not an array.");
                    return null; // Cannot iterate if not an array
                 }

                userLpdCombinationWithDuplicatesLocal.forEach(lpdInputVal => {
                    const currentInstanceNum = (lpdInstanceCounters[lpdInputVal] || 0) + 1;
                    lpdInstanceCounters[lpdInputVal] = currentInstanceNum;
                    const instanceKey = `${lpdInputVal}_${currentInstanceNum}`;
                    breakdownByInstance[instanceKey] = { lpdValue: lpdInputVal, instanceNum: currentInstanceNum }; // Initialize temporary structure

                    let assignedToThisInstance = 0;
                    for (let use of allLpdUses) {
                        if (use.lpdValue === lpdInputVal && use.assignedInstanceKey === null) {
                            if (!maxSlotsIsFinite || assignedToThisInstance < maxSlotsNum) {
                                use.assignedInstanceKey = instanceKey;
                                assignedToThisInstance++;
                            }
                            if (maxSlotsIsFinite && assignedToThisInstance >= maxSlotsNum) break;
                        }
                    }
                });

                Object.keys(breakdownByInstance).forEach(instanceKey => {
                    const instanceDataTemp = breakdownByInstance[instanceKey];
                    const usesForThisInstance = allLpdUses.filter(use => use.assignedInstanceKey === instanceKey);
                    const totalUsedInInstance = usesForThisInstance.length;

                    // Only add if items were actually assigned
                    if (totalUsedInInstance > 0) {
                        const itemsMap = {};
                        usesForThisInstance.forEach(use => { itemsMap[use.itemDetails] = (itemsMap[use.itemDetails] || 0) + 1; });
                        const itemsArray = Object.entries(itemsMap).map(([details, count]) => ({ details, count })).sort((a, b) => a.details.localeCompare(b.details));

                        planAssemblyDataForExport.push({
                            planValue: instanceDataTemp.lpdValue,
                            instanceNum: instanceDataTemp.instanceNum,
                            totalUsed: totalUsedInInstance,
                            maxSlots: maxSlotsIsFinite ? maxSlotsNum : Infinity,
                            items: itemsArray
                        });
                    }
                });

                planAssemblyDataForExport.sort((a, b) => a.planValue - b.planValue || a.instanceNum - b.instanceNum);

                // Check for unassigned uses (optional, for debugging)
                const unassignedUses = allLpdUses.filter(use => use.assignedInstanceKey === null);
                if (unassignedUses.length > 0) {
                    console.warn(`generatePlanAssemblyData: ${unassignedUses.length} LPD uses were not assigned to an instance.`);
                }

            } catch (error) {
                console.error("Error during generatePlanAssemblyData:", error);
                return null; // Return null on error
            }
            return planAssemblyDataForExport;
        }
        // --- End Helper Function ---


        // --- FUNÇÃO FINDER DE COMBINAÇÃO (findBestLpdCombination) ---
        function findBestLpdCombination(parsedItemsData, maxSlotsForTargetCalc, requestedCombinationSize) {
             const functionLog = []; let foundCombination = null; let finderStatus = "OK";
             // ... (rest of function remains the same) ...
             if (!parsedItemsData || parsedItemsData.length === 0) { return { combination: null, log: '<span class="error">Erro do Finder: Nenhum dado de Especificação processado.</span>', status: "Error" }; }
             if (isNaN(maxSlotsForTargetCalc) || maxSlotsForTargetCalc <= 0) { return { combination: null, log: '<span class="error">Erro do Finder: Imagens Máx. Inválidas.</span>', status: "Error" }; }
             if (isNaN(requestedCombinationSize) || requestedCombinationSize < 1) { return { combination: null, log: `<span class="error">Erro do Finder: Tamanho Combo Inválido (>= 1).</span>`, status: "Error" }; }
             const lpdFrequencies = {}; const validRawAmounts = []; let minAmountFound = Infinity; let sumAmounts = 0;
             parsedItemsData.forEach(item => { const amount = item.amount; validRawAmounts.push(amount); sumAmounts += amount; if (amount < minAmountFound) minAmountFound = amount; const lpd = Math.round(amount / 2); if (lpd >= MIN_LPD_VALUE) { lpdFrequencies[lpd] = (lpdFrequencies[lpd] || 0) + 1; } });
             if (validRawAmounts.length === 0) { return { combination: null, log: `<span class="error">Erro do Finder: Nenhuma quantidade válida.</span>`, status: "Error"}; }
             if (sumAmounts === 0 && validRawAmounts.some(a => a !== 0)) { functionLog.push(`<span class="warning">Aviso do Finder: Soma 0 apesar de itens não-zero.</span>`); }
             else if (sumAmounts === 0) { functionLog.push(`Info do Finder: Soma total 0.`); }
             const uniqueValidLpdListWithFreq = Object.entries(lpdFrequencies).map(([lpd, freq]) => ({ value: parseInt(lpd), frequency: freq })).sort((a, b) => b.frequency - a.frequency || b.value - a.value);
             functionLog.push(`--- Registro do Finder de Combinação (Método 'Melhor') ---`);
             functionLog.push(`Qtd Mín Bruta: ${minAmountFound === Infinity ? 'N/A' : minAmountFound}, Soma Total: ${sumAmounts}`);
             functionLog.push(`Imagens Máx (Alvo): ${maxSlotsForTargetCalc}, Tam. Combo Req.: ${requestedCombinationSize}`);
             functionLog.push(`Planos Válidos Únicos (>=${MIN_LPD_VALUE}): ${uniqueValidLpdListWithFreq.length}`);
             functionLog.push(`Planos (Freq/Valor Ord.): ${uniqueValidLpdListWithFreq.map(l => `${l.value}(${l.frequency})`).join(', ')}`);
             let minLpdValueFound = Infinity; uniqueValidLpdListWithFreq.forEach(lpdObj => { if (lpdObj.value < minLpdValueFound) minLpdValueFound = lpdObj.value; });
             functionLog.push(`Plano Mín Válido: ${minLpdValueFound === Infinity ? 'Nenhum' : minLpdValueFound}`);
             const obligatoryCandidates = minLpdValueFound === Infinity ? [] : uniqueValidLpdListWithFreq.filter(lpdObj => Math.abs(lpdObj.value - minLpdValueFound) <= OBLIGATORY_RANGE).sort((a, b) => a.value - b.value);
             functionLog.push(`Candidatos Próximos ao Mín (+/- ${OBLIGATORY_RANGE}): ${obligatoryCandidates.length} [${obligatoryCandidates.map(c=>c.value).join(', ')}]`);

              if (obligatoryCandidates.length === 0 && requestedCombinationSize > 1) { /* --- FALLBACK MDC --- */
                 functionLog.push(`<span class="fallback-gcd">ALERTA: Nenhum Plano próximo ao mín. Usando Fallback MDC.</span>`);
                 let fallbackLog = [`<div class="fallback-section">--- Cálculo Fallback MDC ---`];
                 const baseTargetAmount = sumAmounts / maxSlotsForTargetCalc; fallbackLog.push(`Quantidade Alvo Base: ${baseTargetAmount.toFixed(2)}`);
                 if (validRawAmounts.length < 1) { fallbackLog.push(`<span class="error">Erro: Nenhuma quantidade válida para MDC.</span>`); finderStatus = "Error"; }
                 else { const gcdAmounts = arrayGcd(validRawAmounts); fallbackLog.push(`MDC das quantidades: ${gcdAmounts}`);
                     if (gcdAmounts <= 0) { fallbackLog.push(`<span class="error">Erro: MDC <= 0 (${gcdAmounts}).</span>`); finderStatus = "Error"; }
                     else { const fallbackTarget = baseTargetAmount === 0 ? 0 : roundToNearest(baseTargetAmount, gcdAmounts); fallbackLog.push(`Alvo Fallback (múltiplo MDC): ${fallbackTarget}`);
                         if (fallbackTarget < 0) { fallbackLog.push(`<span class="error">Erro: Alvo Fallback < 0.</span>`); finderStatus = "Error"; }
                         else { const fallbackK = fallbackTarget === 0 ? 0 : Math.round(fallbackTarget / gcdAmounts);
                             if (fallbackK < 0) { fallbackLog.push(`<span class="error">Erro: Unidades MDC < 0.</span>`); finderStatus = "Error"; }
                             else { fallbackLog.push(`Unidades MDC necessárias: ${fallbackK}`); foundCombination = fallbackK > 0 ? Array(fallbackK).fill(gcdAmounts) : []; fallbackLog.push(`<span class="highlight fallback-gcd">Resultado Fallback MDC: [${foundCombination.join(', ')}]</span> (Tamanho: ${fallbackK})`); }
                         }
                     }
                 }
                 functionLog.push(fallbackLog.join('\n') + `</div>`);
              } else { /* --- PADRÃO / FALLBACK PROPORCIONAL --- */
                 let standardSearchAttempted = false; let overallBestCombination = null; let overallBestFrequencyScore = -1; let overallBestTargetSum = null;
                 if (obligatoryCandidates.length > 0) {
                     standardSearchAttempted = true; functionLog.push(`<span class="info">Estratégia padrão selecionada.</span>`);
                     const baseTargetLPD = sumAmounts / maxSlotsForTargetCalc; const lowerBound = baseTargetLPD - TARGET_RANGE_BELOW; const upperBound = baseTargetLPD + TARGET_RANGE_ABOVE; const targetsToTest = []; const firstMultiple = Math.ceil(lowerBound / TARGET_STEP) * TARGET_STEP; const lastMultiple = Math.floor(upperBound / TARGET_STEP) * TARGET_STEP; for (let target = firstMultiple; target <= lastMultiple; target += TARGET_STEP) { if (target > 0 || (target === 0 && baseTargetLPD === 0)) targetsToTest.push(target); }
                     functionLog.push(`Plano Alvo Base: ${baseTargetLPD.toFixed(2)}, Intervalo [${lowerBound.toFixed(2)}, ${upperBound.toFixed(2)}]`);
                     if (targetsToTest.length === 0) { functionLog.push(`<span class="warning">Aviso: Nenhum múltiplo alvo no intervalo. Tentando Proporcional.</span>`); }
                     else { functionLog.push(`Somas Alvo para Testar: [${targetsToTest.join(', ')}]`); const neededOtherLpds = requestedCombinationSize - 1; functionLog.push(`--- Busca de Combinação (Método Padrão, Precisa de ${neededOtherLpds} outros) ---`);
                         for (const currentTargetSum of targetsToTest) { functionLog.push(`<div class="target-section">--- Testando Soma Alvo: ${currentTargetSum} ---`); let foundCombinationForThisTarget = false;
                             for (const currentObligatoryCandidate of obligatoryCandidates) { const currentObligatoryLpdValue = currentObligatoryCandidate.value; functionLog.push(`<div class="candidate-section">=== Tentando Plano Obrigatório: ${currentObligatoryLpdValue} ===`); const searchLpdList = uniqueValidLpdListWithFreq.filter(lpdObj => lpdObj.value !== currentObligatoryLpdValue);
                                  if (neededOtherLpds > 0 && searchLpdList.length < neededOtherLpds) { functionLog.push(`   Pulando: Não há outros suficientes (${searchLpdList.length}) para tamanho ${requestedCombinationSize}.`); functionLog.push(`</div>`); continue; }
                                  const targetForRecursion = currentTargetSum - currentObligatoryLpdValue; functionLog.push(`   Alvo para os ${neededOtherLpds} restantes: ${targetForRecursion.toFixed(2)}`);
                                  if (neededOtherLpds === 0) {
                                      if (Math.abs(targetForRecursion) < 0.01) {
                                          const currentFullCombination = [currentObligatoryLpdValue]; const currentFrequencyScore = getFrequencyScore(currentFullCombination, lpdFrequencies); functionLog.push(`   <span class="success">Encontrada Soma Exata (Tam 1): [${currentFullCombination.join(', ')}] (Soma: ${currentTargetSum}, Freq: ${currentFrequencyScore})</span>`); foundCombinationForThisTarget = true; if (overallBestCombination === null || currentFrequencyScore > overallBestFrequencyScore || (currentFrequencyScore === overallBestFrequencyScore && currentTargetSum < overallBestTargetSum)) { functionLog.push(`   <span class="info">   ** Nova MELHOR GERAL Encontrada **</span>`); overallBestCombination = currentFullCombination; overallBestFrequencyScore = currentFrequencyScore; overallBestTargetSum = currentTargetSum; }
                                       } else { functionLog.push(`   -> Alvo (${currentTargetSum}) != Plano (${currentObligatoryLpdValue}).`); }
                                    } else if (targetForRecursion >= -0.01) {
                                      const adjustedTargetForRecursion = Math.max(0, targetForRecursion);
                                      let foundKMinus1Combination = findSumCombinationRecursive(searchLpdList, adjustedTargetForRecursion, neededOtherLpds, 0, []);
                                     if (foundKMinus1Combination !== null) { const currentFullCombination = [...foundKMinus1Combination, currentObligatoryLpdValue].sort((a, b) => a - b); const currentFrequencyScore = getFrequencyScore(currentFullCombination, lpdFrequencies); functionLog.push(`   <span class="success">Combo Encontrado: [${currentFullCombination.join(', ')}] (Soma: ${currentTargetSum}, Freq: ${currentFrequencyScore})</span>`); foundCombinationForThisTarget = true; if (overallBestCombination === null || currentFrequencyScore > overallBestFrequencyScore || (currentFrequencyScore === overallBestFrequencyScore && currentTargetSum < overallBestTargetSum)) { functionLog.push(`   <span class="info">   ** Nova MELHOR GERAL Encontrada **</span>`); overallBestCombination = currentFullCombination; overallBestFrequencyScore = currentFrequencyScore; overallBestTargetSum = currentTargetSum; } } else { functionLog.push(`   -> Nenhuma combo de ${neededOtherLpds} encontrada para ${adjustedTargetForRecursion.toFixed(2)}.`); }
                                  } else { functionLog.push(`   -> Alvo restante (${targetForRecursion.toFixed(2)}) negativo.`); } functionLog.push(`</div>`);
                              } if (!foundCombinationForThisTarget) { functionLog.push(`   <span class="info">Nenhuma combinação encontrada para o alvo ${currentTargetSum}.</span>`); } functionLog.push(`</div>`);
                         }
                     }
                 }
                 if (overallBestCombination !== null) {
                      functionLog.push(`--- Resultado do Método Padrão ---`); functionLog.push(`<span class="highlight">Melhor Encontrada: [${overallBestCombination.join(', ')}]</span>`); functionLog.push(`(Soma Alvo: ${overallBestTargetSum}, Pontuação Freq: ${overallBestFrequencyScore})`); foundCombination = overallBestCombination;
                 } else { /* --- FALLBACK PROPORCIONAL --- */
                     if (standardSearchAttempted) { functionLog.push(`<span class="error">Método Padrão Falhou. Tentando Proporcional.</span>`); }
                     else if (requestedCombinationSize > 1) { functionLog.push(`<span class="info">Padrão Pulado (Sem candidatos próx. ao min). Tentando Proporcional.</span>`); }
                     functionLog.push(`<span class="fallback-prop">ALERTA: Usando Fallback Proporcional (Arredondar para ${PROPORTIONAL_ROUNDING_STEP}).</span>`);
                     let propFallbackLog = [`<div class="proportional-fallback-section">--- Cálculo Fallback Proporcional ---`];
                     const averageValuePerSlot = (maxSlotsForTargetCalc > 0 && sumAmounts > 0) ? (sumAmounts / maxSlotsForTargetCalc) : 0; propFallbackLog.push(`Valor Médio por Imagem: ${averageValuePerSlot.toFixed(2)}`);
                     if (requestedCombinationSize === 1) { propFallbackLog.push(`Tam. combo 1: Usando média arredondada.`); const roundedAverage = roundToNearest(averageValuePerSlot, PROPORTIONAL_ROUNDING_STEP); if (roundedAverage <= 0 && averageValuePerSlot > 0) { propFallbackLog.push(`<span class="error">Erro: Média arredondada <= 0.</span>`); finderStatus = "Error"; } else if (roundedAverage <= 0) { propFallbackLog.push(`Info: Média arredondada <= 0. Usando combo vazia.`); foundCombination = []; } else { foundCombination = [roundedAverage]; } if (foundCombination !== null) propFallbackLog.push(`Combo Calculada (Tam 1): [${foundCombination.join(', ')}]`);
                     } else { if (uniqueValidLpdListWithFreq.length < requestedCombinationSize) { propFallbackLog.push(`<span class="error">Erro: Planos únicos insuficientes (${uniqueValidLpdListWithFreq.length}) para tamanho ${requestedCombinationSize}.</span>`); finderStatus = "Error"; }
                         else { const selectedTopLpds = uniqueValidLpdListWithFreq.slice(0, requestedCombinationSize); const selectedLpdValues = selectedTopLpds.map(lpd => lpd.value); propFallbackLog.push(`Top ${requestedCombinationSize} Planos: [${selectedLpdValues.join(', ')}]`); const totalLpdValueMass = selectedLpdValues.reduce((sum, val) => sum + val, 0); propFallbackLog.push(`Soma dos Planos (Base): ${totalLpdValueMass}`);
                             if (totalLpdValueMass <= 0) { propFallbackLog.push(`<span class="error">Erro: Soma dos Planos <= 0.</span>`); finderStatus = "Error"; }
                             else if (averageValuePerSlot <= 0) { propFallbackLog.push(`Info: Valor médio <= 0. Resultado vazio.`); foundCombination = []; }
                             else { propFallbackLog.push(`Distribuindo Valor Médio (${averageValuePerSlot.toFixed(2)})...`); const proportionalCombination = selectedLpdValues.map(lpdVal => roundToNearest(averageValuePerSlot * (lpdVal / totalLpdValueMass), PROPORTIONAL_ROUNDING_STEP)); const finalProportionalCombination = proportionalCombination.filter(v => v > 0);
                                 if (finalProportionalCombination.length === 0) { propFallbackLog.push(`<span class="warning">Aviso: Proporcional resultou em nenhum Plano positivo. Usando vazio.</span>`); foundCombination = []; }
                                 else if (finalProportionalCombination.length < requestedCombinationSize) { propFallbackLog.push(`<span class="warning">Aviso: Proporcional resultou em apenas ${finalProportionalCombination.length} Planos positivos (req ${requestedCombinationSize}). Usando valores positivos.</span>`); foundCombination = finalProportionalCombination.sort((a,b) => a - b); }
                                 else { foundCombination = finalProportionalCombination.sort((a,b) => a - b).slice(0, requestedCombinationSize); }
                                 if (foundCombination !== null) { const sumOfProp = foundCombination.reduce((sum, val) => sum + val, 0); propFallbackLog.push(`Combo Proporcional Calculada (Arred., >0): [${foundCombination.join(', ')}]`); propFallbackLog.push(`Soma: ${sumOfProp} (vs Média Imagem: ${averageValuePerSlot.toFixed(2)})`); }
                             }
                         }
                     } functionLog.push(propFallbackLog.join('\n') + `</div>`);
                 }
              }
             return { combination: foundCombination, log: functionLog.join('\n'), status: finderStatus };
        }
        
        // --- FUNÇÃO DE COMBINAÇÃO PROPORCIONAL DIRETA ---
        function calculateDirectProportionalCombination(parsedItemsData, maxSlotsForTargetCalc, requestedCombinationSize) {
            const functionLog = [];
            let foundCombination = null;
            let finderStatus = "OK";
             // ... (rest of function remains the same) ...
            if (!parsedItemsData || parsedItemsData.length === 0) { return { combination: null, log: '<span class="error">Erro Calc Prop: Nenhum dado de Especificação processado.</span>', status: "Error" }; }
            if (isNaN(maxSlotsForTargetCalc) || maxSlotsForTargetCalc <= 0) { return { combination: null, log: '<span class="error">Erro Calc Prop: Imagens Máx. Inválidas.</span>', status: "Error" }; }
            if (isNaN(requestedCombinationSize) || requestedCombinationSize < 1) { return { combination: null, log: `<span class="error">Erro Calc Prop: Tamanho Combo Inválido (>= 1).</span>`, status: "Error" }; }
            const lpdFrequencies = {}; const validRawAmounts = []; const allValidLpds = [];
            let sumAmounts = 0; let minAmountFound = Infinity;
            parsedItemsData.forEach(item => { const amount = item.amount; validRawAmounts.push(amount); sumAmounts += amount; if (amount < minAmountFound) minAmountFound = amount; const lpd = Math.round(amount / 2); if (lpd >= MIN_LPD_VALUE) { lpdFrequencies[lpd] = (lpdFrequencies[lpd] || 0) + 1; allValidLpds.push(lpd); } });
            if (validRawAmounts.length === 0) { return { combination: null, log: `<span class="error">Erro Calc Prop: Nenhuma quantidade válida.</span>`, status: "Error"}; }
             if (sumAmounts === 0 && validRawAmounts.some(a => a !== 0)) { functionLog.push(`<span class="warning">Aviso Calc Prop: Soma 0 apesar de itens não-zero.</span>`); }
             else if (sumAmounts === 0) { functionLog.push(`Info Calc Prop: Soma total 0.`); }
            const uniqueValidLpdListWithFreq = Object.entries(lpdFrequencies).map(([lpd, freq]) => ({ value: parseInt(lpd), frequency: freq })).sort((a, b) => b.frequency - a.frequency || b.value - a.value);
            let minLpdValueFound = Infinity; if (allValidLpds.length > 0) { minLpdValueFound = Math.min(...allValidLpds); }
            const nearMinLpds = minLpdValueFound === Infinity ? [] : uniqueValidLpdListWithFreq.filter(lpdObj => Math.abs(lpdObj.value - minLpdValueFound) <= OBLIGATORY_RANGE).sort((a, b) => b.frequency - a.frequency || a.value - b.value);

            functionLog.push(`--- Registro de Cálculo Proporcional Direto ---`);
            functionLog.push(`Qtd Mín Bruta: ${minAmountFound === Infinity ? 'N/A' : minAmountFound}, Soma Total: ${sumAmounts}`);
            functionLog.push(`Imagens Máx (Alvo): ${maxSlotsForTargetCalc}, Tam. Combo Req.: ${requestedCombinationSize}`);
            functionLog.push(`Planos Válidos Únicos (>=${MIN_LPD_VALUE}): ${uniqueValidLpdListWithFreq.length}`);
            functionLog.push(`Planos (Freq/Valor Ord.): ${uniqueValidLpdListWithFreq.map(l => `${l.value}(${l.frequency})`).join(', ')}`);
            functionLog.push(`Plano Mín Válido: ${minLpdValueFound === Infinity ? 'Nenhum' : minLpdValueFound}`);
            functionLog.push(`Candidatos Próximos ao Mín (+/- ${OBLIGATORY_RANGE}): ${nearMinLpds.length} [${nearMinLpds.map(c=>c.value + '(' + c.frequency + ')').join(', ')}]`);

            if (uniqueValidLpdListWithFreq.length < requestedCombinationSize && requestedCombinationSize > 0) {
                 functionLog.push(`<span class="error">Erro: Planos válidos únicos insuficientes (${uniqueValidLpdListWithFreq.length}) disponíveis para o tamanho solicitado ${requestedCombinationSize}.</span>`);
                 return { combination: null, log: functionLog.join('\n'), status: "Error" };
             }

            functionLog.push(`--- Selecionando Planos para Cálculo Proporcional ---`);
            let selectionLog = [];
            let finalSelectedLpdsForProportion = [];
            if (requestedCombinationSize === 1) {
                selectionLog.push(`Tam. combo 1: Ajuste da regra do Plano Mín não aplicado à seleção.`);
                if (uniqueValidLpdListWithFreq.length > 0) { finalSelectedLpdsForProportion = [uniqueValidLpdListWithFreq[0]]; selectionLog.push(`(Usando valor médio; Plano Top para referência: ${finalSelectedLpdsForProportion[0].value})`); }
                else { selectionLog.push(`(Nenhum Plano único encontrado).`); }
            } else if (requestedCombinationSize > 1) {
                const initialTopLpds = uniqueValidLpdListWithFreq.slice(0, requestedCombinationSize);
                selectionLog.push(`Top ${requestedCombinationSize} Planos Iniciais (por Freq/Valor): [${initialTopLpds.map(l => `${l.value}(${l.frequency})`).join(', ')}]`);
                const initialSelectionValues = initialTopLpds.map(lpd => lpd.value);
                const meetsMinLpdRule = nearMinLpds.length === 0 || initialSelectionValues.some(val => nearMinLpds.some(nearLpd => nearLpd.value === val));

                if (meetsMinLpdRule) {
                    selectionLog.push(`<span class="info">Regra do Plano Mín Atendida: Seleção inicial inclui Plano próximo ao mín (ou nenhum existe).</span>`);
                    finalSelectedLpdsForProportion = initialTopLpds;
                } else {
                    selectionLog.push(`<span class="warning">Regra do Plano Mín NÃO Atendida: Tentando substituição.</span>`);
                    if (nearMinLpds.length > 0) {
                        const bestNearMinLpd = nearMinLpds[0];
                        selectionLog.push(`   - Melhor Candidato Próximo ao Mín: ${bestNearMinLpd.value}(${bestNearMinLpd.frequency})`);
                        let indexToReplace = -1; let minFreq = Infinity; let minValueAtMinFreq = Infinity;
                        for(let i = 0; i < initialTopLpds.length; i++) { const lpd = initialTopLpds[i]; if (nearMinLpds.some(near => near.value === lpd.value)) continue; if (lpd.frequency < minFreq) { minFreq = lpd.frequency; minValueAtMinFreq = lpd.value; indexToReplace = i; } else if (lpd.frequency === minFreq && lpd.value < minValueAtMinFreq) { minValueAtMinFreq = lpd.value; indexToReplace = i; } }
                        if (indexToReplace !== -1) {
                            const lpdToReplace = initialTopLpds[indexToReplace];
                            selectionLog.push(`   - Plano a Substituir (Menor Freq): ${lpdToReplace.value}(${lpdToReplace.frequency})`);
                            let adjustedSelectedTopLpds = [...initialTopLpds]; adjustedSelectedTopLpds[indexToReplace] = bestNearMinLpd;
                            adjustedSelectedTopLpds.sort((a, b) => b.frequency - a.frequency || a.value - b.value);
                            finalSelectedLpdsForProportion = adjustedSelectedTopLpds;
                            selectionLog.push(`<span class="info">   => Planos Finais para Cálculo: [${finalSelectedLpdsForProportion.map(l => `${l.value}(${l.frequency})`).join(', ')}]</span>`);
                        } else {
                             selectionLog.push(`<span class="warning">   - Não foi possível encontrar Plano adequado para substituir. Usando seleção inicial.</span>`);
                             finalSelectedLpdsForProportion = initialTopLpds;
                        }
                    } else {
                        selectionLog.push(`<span class="warning">   - Nenhum candidato próximo ao mínimo disponível para substituição. Usando seleção inicial.</span>`);
                        finalSelectedLpdsForProportion = initialTopLpds;
                    }
                }
            } else {
                 selectionLog.push(`Tamanho de combinação solicitado é 0. O resultado será vazio.`);
                 finalSelectedLpdsForProportion = [];
            }
            functionLog.push(selectionLog.join('\n'));

            functionLog.push(`<div class="proportional-direct-section">--- Cálculo Proporcional ---`);
            let propCalcLog = []; // <<< Declare propCalcLog HERE
            const averageValuePerSlot = (maxSlotsForTargetCalc > 0 && sumAmounts > 0) ? (sumAmounts / maxSlotsForTargetCalc) : 0;
            propCalcLog.push(`Valor Médio por Imagem: ${averageValuePerSlot.toFixed(2)}`);

            if (requestedCombinationSize === 1) {
                propCalcLog.push(`Tam. combo 1: Usando média arredondada.`);
                const roundedAverage = roundToNearest(averageValuePerSlot, PROPORTIONAL_ROUNDING_STEP);
                 if (roundedAverage <= 0 && averageValuePerSlot > 0) { propCalcLog.push(`<span class="error">Erro: Média arredondada <= 0.</span>`); finderStatus = "Error"; }
                 else if (roundedAverage <= 0) { propCalcLog.push(`Info: Média arredondada <= 0. Usando combo vazia.`); foundCombination = []; }
                 else { foundCombination = [roundedAverage]; }
                 if (foundCombination !== null) propCalcLog.push(`Combo Calculada (Tam 1): [${foundCombination.join(', ')}]`);
            } else if (requestedCombinationSize > 1) {
                const selectedLpdValues = finalSelectedLpdsForProportion.map(lpd => lpd.value);
                propCalcLog.push(`Usando Valores de Planos para Proporções: [${selectedLpdValues.join(', ')}] (Da etapa de seleção)`);
                const totalLpdValueMass = selectedLpdValues.reduce((sum, val) => sum + val, 0);
                propCalcLog.push(`Soma dos Planos (Base): ${totalLpdValueMass}`);
                if (totalLpdValueMass <= 0) { propCalcLog.push(`<span class="error">Erro: Soma dos Planos selecionados <= 0.</span>`); finderStatus = "Error"; }
                else if (averageValuePerSlot <= 0) { propCalcLog.push(`Info: Valor médio <= 0. Resultado vazio.`); foundCombination = []; }
                else {
                    propCalcLog.push(`Distribuindo Valor Médio (${averageValuePerSlot.toFixed(2)})...`);
                    const proportionalCombination = selectedLpdValues.map(lpdVal => roundToNearest(averageValuePerSlot * (lpdVal / totalLpdValueMass), PROPORTIONAL_ROUNDING_STEP));
                    const finalProportionalCombination = proportionalCombination.filter(v => v > 0);
                    if (finalProportionalCombination.length === 0) { propCalcLog.push(`<span class="warning">Aviso: Proporcional resultou em nenhum Plano positivo. Usando vazio.</span>`); foundCombination = []; }
                    else if (finalProportionalCombination.length < requestedCombinationSize) { propCalcLog.push(`<span class="warning">Aviso: Apenas ${finalProportionalCombination.length} Planos positivos resultaram (req ${requestedCombinationSize}). Usando valores positivos.</span>`); foundCombination = finalProportionalCombination.sort((a,b) => a - b); }
                    else { foundCombination = finalProportionalCombination.sort((a,b) => a - b).slice(0, requestedCombinationSize); }
                    if (foundCombination !== null) { const sumOfProp = foundCombination.reduce((sum, val) => sum + val, 0); propCalcLog.push(`Combo Proporcional Calculada (Arred., >0): [${foundCombination.join(', ')}]`); propCalcLog.push(`Soma: ${sumOfProp} (vs Média Imagem: ${averageValuePerSlot.toFixed(2)})`); } // Push to propCalcLog
                }
            } else {
                 propCalcLog.push(`Tam. combo 0 solicitado. Resultado vazio.`);
                 foundCombination = [];
            }
            // --- CORRECTION HERE ---
            // Use propCalcLog instead of propFallbackLog
            functionLog.push(propCalcLog.join('\n') + `</div>`);
            // --- END CORRECTION ---

            return { combination: foundCombination, log: functionLog.join('\n'), status: finderStatus };
        }
        // --- LÓGICA CENTRAL DO ALOCADOR (runAllocationProcess) ---
        function runAllocationProcess(itemsToProcess, userLpdCombinationWithDuplicates, maxSlotsPerInstance) {
             console.log(`[runAllocationProcess] START. items: ${itemsToProcess?.length}, LPDs: ${userLpdCombinationWithDuplicates?.length}, MaxSlots: ${maxSlotsPerInstance}`); // Log inputs

             const logs = { adjustment: '', variation: '' };
             const maxSlotsIsFinite = maxSlotsPerInstance !== Infinity;
             const maxSlotsDisplayLocal = maxSlotsIsFinite ? maxSlotsPerInstance : "Ilimitado";

             // --- Input validation ---
             if (!Array.isArray(itemsToProcess)) {
                console.error("[runAllocationProcess] FATAL: itemsToProcess is not an array!", itemsToProcess);
                return { itemAllocations: [], cumulativeUsage: {}, remainingSlots: {}, logs: { adjustment: '<span class="error">Erro interno: Dados de itens inválidos.</span>', variation: '' }, error: "Dados de itens inválidos (não é array)." };
             }
             if (!Array.isArray(userLpdCombinationWithDuplicates)) {
                 console.warn("[runAllocationProcess] userLpdCombinationWithDuplicates is not an array, using [].");
                 userLpdCombinationWithDuplicates = [];
             }
             // --- End Input validation ---


             const uniqueLpdValuesLocal = [...new Set(userLpdCombinationWithDuplicates)].filter(lpd => typeof lpd === 'number' && !isNaN(lpd) && lpd > 0).sort((a, b) => a - b); // Ensure only valid positive numbers
             const lpdInstanceCountsLocal = {};
             userLpdCombinationWithDuplicates.forEach(lpd => { if(typeof lpd === 'number' && !isNaN(lpd)) lpdInstanceCountsLocal[lpd] = (lpdInstanceCountsLocal[lpd] || 0) + 1; });
             const initialTotalSlotsPerValueLocal = {};
             uniqueLpdValuesLocal.forEach(lpd => { const instances = lpdInstanceCountsLocal[lpd] || 0; initialTotalSlotsPerValueLocal[lpd] = maxSlotsIsFinite ? (instances * maxSlotsPerInstance) : Infinity; });

             // Initialize remaining slots carefully
             const currentRemainingSlots = {};
              uniqueLpdValuesLocal.forEach(lpd => {
                 currentRemainingSlots[lpd] = initialTotalSlotsPerValueLocal[lpd] ?? (maxSlotsIsFinite ? 0 : Infinity);
              });
             console.log("[runAllocationProcess] Initial unique LPDs:", uniqueLpdValuesLocal);
             console.log("[runAllocationProcess] Initial remaining slots:", JSON.stringify(currentRemainingSlots));


             // Ensure allocation array matches item count
             const currentItemAllocations = new Array(itemsToProcess.length).fill(null).map(() => ({ sum: 0, difference: 0, combination: [], finalUsageCounts: {}, error: null }));
             console.log("[runAllocationProcess] Initialized currentItemAllocations array, length:", currentItemAllocations.length);


             logs.adjustment += `--- Passo 1: Alocação DP Inicial (Imagens Máx/Instância: ${maxSlotsDisplayLocal}) ---\n`;
             let step1Failed = false;
             itemsToProcess.forEach((item, i) => {
                 if (step1Failed) return; // Stop processing if a fatal error occurred

                 // Basic check for item validity
                 if (!item || typeof item.details === 'undefined' || typeof item.amount === 'undefined' || typeof item.originalIndex === 'undefined') {
                     const errorMsg = `Item inválido no índice de processamento ${i}`;
                     logs.adjustment += `<span class="error">Erro: ${errorMsg}</span>\n`;
                     console.error(`[runAllocationProcess] Passo 1: ${errorMsg}. Item data:`, item);
                     currentItemAllocations[i] = { sum: 0, difference: 0, combination: [], finalUsageCounts: {}, error: "Item inválido" };
                     // Decide if this is fatal? Maybe not, allow others to proceed?
                     // step1Failed = true; // Uncomment if one invalid item should halt everything
                     return; // Skip this item
                 }
                 logs.adjustment += `[${i+1}] Espec ${item.originalIndex + 1} ('${item.details}', Alvo: ${item.amount}): `;
                 console.log(`[runAllocationProcess] Passo 1, Item ${i+1}: Alvo=${item.amount}. Calling findClosestSum...`);

                 // Call findClosestSum and log result
                 const allocation = findClosestSumWithRepetitionAndSlots(
                      [...uniqueLpdValuesLocal], // Pass copy of unique LPDs
                      item.amount,
                      currentRemainingSlots // Pass current state of slots
                 );
                 console.log(`[runAllocationProcess] Passo 1, Item ${i+1}: findClosestSum Result:`, JSON.parse(JSON.stringify(allocation))); // Log deep copy

                 // Process allocation result
                 currentItemAllocations[i] = {
                    sum: allocation.sum ?? 0, // Default sum to 0 if undefined
                    difference: allocation.difference ?? (0 - item.amount), // Calculate difference if undefined
                    combination: allocation.combination ? [...allocation.combination] : [], // Copy combination or use empty
                    finalUsageCounts: {},
                    error: allocation.error || null
                 };

                 if (allocation.error) {
                    logs.adjustment += `<span class="error">Erro DP: ${allocation.error}</span>\n`;
                    // Check if it's a "no path found" type error vs. something more critical
                     if (allocation.error.includes("Não foi possível alcançar") || allocation.error.includes("nenhum Plano tem imagens")) {
                         console.warn(`[runAllocationProcess] Passo 1, Item ${i+1}: DP could not find solution for target ${item.amount}. Error: ${allocation.error}`);
                     } else {
                         // Potentially more critical error from DP
                         console.error(`[runAllocationProcess] Passo 1, Item ${i+1}: CRITICAL DP Error for target ${item.amount}. Error: ${allocation.error}`);
                         // Consider setting step1Failed = true; here if DP logic errors should halt
                     }

                 } else if (allocation.combination && allocation.combination.length > 0) {
                    logs.adjustment += `Soma Enc ${allocation.sum} (Dif: ${allocation.difference}), Combo: [${allocation.combination.join(', ')}]\n`;
                    // Update remaining slots
                    let slotUpdateError = false;
                    allocation.combination.forEach(lpd => {
                        if (currentRemainingSlots.hasOwnProperty(lpd)) {
                            if (maxSlotsIsFinite) {
                                if (currentRemainingSlots[lpd] > 0) {
                                    currentRemainingSlots[lpd]--;
                                } else {
                                    console.error(`[runAllocationProcess] Passo 1, Item ${i+1}: SLOT ERROR! Tried to use LPD ${lpd} for item ${item.details} when remaining slots were 0!`);
                                    logs.adjustment += `<span class="error">ERRO SLOT para ${lpd}!</span>\n`;
                                    currentItemAllocations[i].error = (currentItemAllocations[i].error || "") + ` ERRO: Usou ${lpd} além dos slots!`;
                                    slotUpdateError = true; // Flag error
                                }
                            } // No decrement needed for Infinity case
                        } else {
                            console.error(`[runAllocationProcess] Passo 1, Item ${i+1}: LOGIC ERROR! Used LPD ${lpd} not found in remaining slots map!`);
                            logs.adjustment += `<span class="error">ERRO LÓGICA para ${lpd}!</span>\n`;
                            currentItemAllocations[i].error = (currentItemAllocations[i].error || "") + ` ERRO: LPD ${lpd} inválido!`;
                            slotUpdateError = true; // Flag error
                        }
                    });
                     if (slotUpdateError) {
                         // Maybe halt if slot logic fails?
                         // step1Failed = true;
                     }
                 } else {
                      // Allocation successful but combination is empty (likely target was 0)
                      logs.adjustment += `Soma Enc ${allocation.sum} (Dif: ${allocation.difference}), Combo: []\n`;
                 }
             }); // End forEach item in Passo 1

             if (step1Failed) {
                 console.error("[runAllocationProcess] Halting after fatal error in Passo 1.");
                 // Return partial results indicating failure
                 return { itemAllocations: currentItemAllocations, cumulativeUsage: {}, remainingSlots: currentRemainingSlots, logs: logs, error: "Falha crítica no Passo 1." };
             }
             console.log("[runAllocationProcess] Passo 1 Complete. Final allocations:", JSON.parse(JSON.stringify(currentItemAllocations)));
             console.log("[runAllocatorProcess] Passo 1 Complete. Final remaining slots:", JSON.stringify(currentRemainingSlots));
             logs.adjustment += `Imagens Rem Após Passo 1: ${JSON.stringify(currentRemainingSlots)}\n`;


             // Passo 2: Preenchimento de Imagens
             console.log("[runAllocatorProcess] Starting Passo 2 (Slot Filling)...");
             let adjustmentLogHTML = `--- Passo 2: Preenchimento de Imagens (Imagens Máx/Instância: ${maxSlotsDisplayLocal}) ---`;
             if (maxSlotsIsFinite) {
                 // ... (Rest of Passo 2 logic remains the same) ...
                 adjustmentLogHTML += `\nImagens Rem Iniciais Passo 2: ${JSON.stringify(currentRemainingSlots, null, 0)}`;
                 let totalRemainingPass2 = Object.values(currentRemainingSlots).reduce((sum, count) => count === Infinity ? sum : sum + count, 0);
                 adjustmentLogHTML += `\nTotal Imagens Finitas Rem: ${totalRemainingPass2}`;
                 let adjustmentSafetyCounter = 0;
                 const maxAdjustments = totalRemainingPass2 + itemsToProcess.length * uniqueLpdValuesLocal.length + 50;
                 while (totalRemainingPass2 > 0 && adjustmentSafetyCounter < maxAdjustments) {
                    adjustmentSafetyCounter++;
                    let bestMove = { lpdToAdd: null, itemIndex: -1, minImpact: Infinity, currentAbsDiff: Infinity };
                    for (const lpd of uniqueLpdValuesLocal) {
                        if (currentRemainingSlots[lpd] > 0) {
                            for (let i = 0; i < currentItemAllocations.length; i++) {
                                const currentAlloc = currentItemAllocations[i];
                                if (!currentAlloc || currentAlloc.error || currentAlloc.sum === undefined) continue; // Skip invalid/error items
                                // Ensure item exists for target amount
                                const item = itemsToProcess[i]; if (!item) continue;
                                const originalAmount = item.amount;
                                const currentSum = currentAlloc.sum;
                                const currentAbsDifference = Math.abs(currentAlloc.difference);
                                const newSum = currentSum + lpd;
                                const newAbsDifference = Math.abs(newSum - originalAmount);
                                const impact = newAbsDifference - currentAbsDifference;
                                if (impact < bestMove.minImpact || (impact === bestMove.minImpact && currentAbsDifference > bestMove.currentAbsDiff)) {
                                    bestMove = { lpdToAdd: lpd, itemIndex: i, minImpact: impact, currentAbsDiff: currentAbsDifference };
                                }
                            }
                        }
                    }
                    if (bestMove.lpdToAdd !== null) {
                        const lpd = bestMove.lpdToAdd;
                        const itemIdx = bestMove.itemIndex;
                        if (itemIdx < 0 || itemIdx >= currentItemAllocations.length || !currentItemAllocations[itemIdx] || !itemsToProcess[itemIdx]) {
                            console.error(`Passo 2: Índice de item inválido (${itemIdx}) para melhor movimento.`); adjustmentLogHTML += `\n<span class="error">Erro interno no Passo 2.</span>`; break; // Stop if index is bad
                        }
                        adjustmentLogHTML += `<div class="adjustment-step">Passo ${adjustmentSafetyCounter}: Adic Plano <span class="info">${lpd}</span> ao Especificação ${itemsToProcess[itemIdx].originalIndex + 1} ('${itemsToProcess[itemIdx].details}') (Impacto: ${bestMove.minImpact >= 0 ? '+' : ''}${bestMove.minImpact.toFixed(0)})`;
                        currentItemAllocations[itemIdx].combination.push(lpd);
                        currentItemAllocations[itemIdx].combination.sort((a, b) => a - b);
                        currentItemAllocations[itemIdx].sum += lpd;
                        currentItemAllocations[itemIdx].difference = currentItemAllocations[itemIdx].sum - itemsToProcess[itemIdx].amount;
                        currentRemainingSlots[lpd]--; // Decrease even if Infinity (though it won't change Infinity)
                        totalRemainingPass2--;
                        adjustmentLogHTML += `\n   -> Nova Soma: ${currentItemAllocations[itemIdx].sum}, Dif: ${currentItemAllocations[itemIdx].difference.toFixed(0)}, Imagens Rem ${lpd}: ${currentRemainingSlots[lpd]}</div>`;
                    } else { adjustmentLogHTML += `\n<span class="warning">Parado Passo 2 (Iter ${adjustmentSafetyCounter}): Nenhum movimento benéfico. ${totalRemainingPass2} imagens finitas restantes.</span>`; break; }
                 }
                 if (adjustmentSafetyCounter >= maxAdjustments) { adjustmentLogHTML += `\n<span class="error">Parado Passo 2: Limite de segurança (${maxAdjustments}) atingido.</span>`; }
                 adjustmentLogHTML += `\nImagens Rem Após Passo 2: ${JSON.stringify(currentRemainingSlots)}`;
             } else { adjustmentLogHTML += `\n(Pulado: Imagens Máx Ilimitadas)`; }
             logs.adjustment = adjustmentLogHTML;
             console.log("[runAllocatorProcess] Passo 2 Complete.");


             // Passo 3: Correção de Variação
             console.log("[runAllocatorProcess] Starting Passo 3 (Variation Correction)...");
             let variationLogHTML = `--- Passo 3: Correção de Variação (Alvo: ±${(VARIATION_LIMIT_PASS_3 * 100).toFixed(0)}%) ---`;
             let madeVariationAdjustment = true; let variationLoopCounter = 0;
             const maxVariationLoops = itemsToProcess.length * uniqueLpdValuesLocal.length * 3 + 50;
             while (madeVariationAdjustment && variationLoopCounter < maxVariationLoops) {
                 // ... (Rest of Passo 3 logic remains the same) ...
                variationLoopCounter++; madeVariationAdjustment = false;
                let worstViolation = { index: -1, percentageDiff: 0, absDifference: 0 };
                currentItemAllocations.forEach((alloc, i) => {
                     if (alloc && !alloc.error && alloc.difference !== undefined) {
                        const item = itemsToProcess[i]; if (!item) return;
                        const targetAmount = item.amount; let currentAbsPercentage = 0; const currentAbsDifference = Math.abs(alloc.difference);
                        if (targetAmount > 0) { currentAbsPercentage = currentAbsDifference / targetAmount; } else if (alloc.sum !== 0) { currentAbsPercentage = Infinity; }
                        if (currentAbsPercentage > VARIATION_LIMIT_PASS_3) { if (currentAbsPercentage > worstViolation.percentageDiff || (currentAbsPercentage === worstViolation.percentageDiff && currentAbsDifference > worstViolation.absDifference)) { worstViolation = { index: i, percentageDiff: currentAbsPercentage, absDifference: currentAbsDifference }; } }
                    }
                });

                if (worstViolation.index === -1) { variationLogHTML += `\nIter ${variationLoopCounter}: Nenhum item > ±${(VARIATION_LIMIT_PASS_3 * 100).toFixed(0)}%. Passo 3 completo.`; break; }
                const itemIdx = worstViolation.index; const currentAlloc = currentItemAllocations[itemIdx];
                if (!currentAlloc || !itemsToProcess[itemIdx]) { console.error(`Passo 3: Índice inválido (${itemIdx}) ou item/alocação ausente.`); variationLogHTML += `\n<span class="error">Erro interno no Passo 3 (índice ${itemIdx}).</span>`; break; }
                const originalAmount = itemsToProcess[itemIdx].amount;
                variationLogHTML += `<div class="variation-step">Iter ${variationLoopCounter}: Corrigindo Especificação ${itemsToProcess[itemIdx].originalIndex + 1} ('${itemsToProcess[itemIdx].details}') - Dif: ${currentAlloc.difference.toFixed(0)} (${(worstViolation.percentageDiff * 100).toFixed(1)}%)`;

                let bestFix = { action: null, lpd: null, finalAbsDiff: Math.abs(currentAlloc.difference), finalPercDiff: worstViolation.percentageDiff };
                const currentCombinationCopy = Array.isArray(currentAlloc.combination) ? [...currentAlloc.combination] : []; // Ensure it's an array before copying

                // Try removing
                for (const lpdToRemove of new Set(currentCombinationCopy)) {
                    if (!lpdToRemove || typeof lpdToRemove !== 'number') continue; // Skip invalid LPDs
                    const newSum = currentAlloc.sum - lpdToRemove; const newAbsDiff = Math.abs(newSum - originalAmount); let newPercentageDiff = originalAmount > 0 ? newAbsDiff / originalAmount : (newSum === 0 ? 0 : Infinity);
                    if (newPercentageDiff <= VARIATION_LIMIT_PASS_3) { if (newAbsDiff < bestFix.finalAbsDiff) { bestFix = { action: 'remove', lpd: lpdToRemove, finalAbsDiff: newAbsDiff, finalPercDiff: newPercentageDiff }; } }
                    else if (bestFix.action === null && newAbsDiff < bestFix.finalAbsDiff) { bestFix = { action: 'remove', lpd: lpdToRemove, finalAbsDiff: newAbsDiff, finalPercDiff: newPercentageDiff }; }
                }
                // Try adding
                for (const lpdToAdd of uniqueLpdValuesLocal) { // uniqueLpdValuesLocal should only contain valid numbers now
                    if (maxSlotsIsFinite && currentRemainingSlots[lpdToAdd] <= 0) continue;
                    const newSum = currentAlloc.sum + lpdToAdd; const newAbsDiff = Math.abs(newSum - originalAmount); let newPercentageDiff = originalAmount > 0 ? newAbsDiff / originalAmount : (newSum === 0 ? 0 : Infinity);
                    if (newPercentageDiff <= VARIATION_LIMIT_PASS_3) { if (newAbsDiff < bestFix.finalAbsDiff) { bestFix = { action: 'add', lpd: lpdToAdd, finalAbsDiff: newAbsDiff, finalPercDiff: newPercentageDiff }; } }
                    else if (bestFix.action === null && newAbsDiff < bestFix.finalAbsDiff) { bestFix = { action: 'add', lpd: lpdToAdd, finalAbsDiff: newAbsDiff, finalPercDiff: newPercentageDiff }; }
                }

                if (bestFix.action) {
                     madeVariationAdjustment = true; const lpd = bestFix.lpd;
                     variationLogHTML += ` -> Ação: <span class="info">${bestFix.action === 'remove' ? 'REMOVER' : 'ADICIONAR'} ${lpd}</span>`;
                     if (bestFix.action === 'remove') {
                        const indexToRemove = currentItemAllocations[itemIdx].combination.indexOf(lpd);
                        if (indexToRemove > -1) {
                            currentItemAllocations[itemIdx].combination.splice(indexToRemove, 1); currentItemAllocations[itemIdx].sum -= lpd; currentItemAllocations[itemIdx].difference -= lpd;
                            if (maxSlotsIsFinite) { currentRemainingSlots[lpd]++; }
                        } else { console.error(`Erro VFix: remover ${lpd} não encontrado em ${itemIdx}`); variationLogHTML += ` <span class="error">(Erro!)</span>`; madeVariationAdjustment = false; }
                     } else { // Add
                        currentItemAllocations[itemIdx].combination.push(lpd); currentItemAllocations[itemIdx].combination.sort((a, b) => a - b); currentItemAllocations[itemIdx].sum += lpd; currentItemAllocations[itemIdx].difference += lpd;
                        if (maxSlotsIsFinite) { currentRemainingSlots[lpd]--; }
                     }
                     const finalPercDiffCheck = originalAmount > 0 ? Math.abs(currentItemAllocations[itemIdx].difference / originalAmount) : (currentItemAllocations[itemIdx].sum === 0 ? 0 : Infinity);
                     variationLogHTML += ` -> Nova Dif: ${currentItemAllocations[itemIdx].difference.toFixed(0)} (${(finalPercDiffCheck * 100).toFixed(1)}%)`;
                     if (finalPercDiffCheck <= VARIATION_LIMIT_PASS_3) { variationLogHTML += ` <span class="success">(OK)</span>`; } else { variationLogHTML += ` <span class="warning">(Ainda Alto)</span>`; }
                     if (maxSlotsIsFinite) { variationLogHTML += `, Imagens Rem ${lpd}: ${currentRemainingSlots[lpd]}`; }
                } else { variationLogHTML += ` -> <span class="warning">Nenhuma correção encontrada. Parando Passo 3.</span>`; madeVariationAdjustment = false; }
                variationLogHTML += `</div>`;
             }
             if (variationLoopCounter >= maxVariationLoops) { variationLogHTML += `\n<span class="error">Parado Passo 3: Limite de loop (${maxVariationLoops}) atingido.</span>`; }
             logs.variation = variationLogHTML;
             console.log("[runAllocatorProcess] Passo 3 Complete.");


             // Contagem Final
             console.log("[runAllocatorProcess] Starting Final Count...");
             let finalCumulativeUsage = {}; uniqueLpdValuesLocal.forEach(lpd => { finalCumulativeUsage[lpd] = 0; });
             currentItemAllocations.forEach(alloc => {
                 alloc.finalUsageCounts = {}; // Initialize usage counts for this item
                 if (alloc && !alloc.error && Array.isArray(alloc.combination)) { // Check alloc exists, no error, and combination is array
                    alloc.combination.forEach(lpd => {
                        if (typeof lpd === 'number' && !isNaN(lpd)) { // Check LPD is valid number
                            alloc.finalUsageCounts[lpd] = (alloc.finalUsageCounts[lpd] || 0) + 1;
                            if (finalCumulativeUsage.hasOwnProperty(lpd)) { finalCumulativeUsage[lpd]++; }
                            else { console.error(`Erro Lógica Contagem Final: Plano ${lpd} usado mas não na lista única (${uniqueLpdValuesLocal.join(',')}).`); }
                        } else {
                            console.warn("Skipping invalid LPD during final count:", lpd);
                        }
                     });
                 }
             });
             console.log("[runAllocatorProcess] Final Count Complete. Cumulative Usage:", JSON.stringify(finalCumulativeUsage));


             // Return final results
             console.log("[runAllocationProcess] END. Returning results.");
             // Ensure itemAllocations exists before returning
             const finalItemAllocations = Array.isArray(currentItemAllocations) ? currentItemAllocations : [];
             return { itemAllocations: finalItemAllocations, cumulativeUsage: finalCumulativeUsage, remainingSlots: currentRemainingSlots, logs: logs };
        }


        // --- Função da Fase do Alocador ---
        function runAllocatorPhase() {
            console.log("[runAllocatorPhase] START"); // Log function start
            const statusAreaDiv = document.getElementById('statusArea');
            const strategyComparisonDiv = document.getElementById('strategyComparison');
            const allocationResultsDiv = document.getElementById('allocationResults');

            // --- Clear previous results immediately ---
             console.log("[runAllocatorPhase] Clearing previous results...");
             strategyComparisonDiv.innerHTML = ''; allocationResultsDiv.innerHTML = '';
             document.getElementById('adjustmentLog').innerHTML = ''; document.getElementById('variationLog').innerHTML = ''; document.getElementById('cumulativeUsage').innerHTML = '';
             document.getElementById('lpdBreakdown').innerHTML = ''; document.getElementById('finalSummaryTableDiv').innerHTML = '';
             // Also clear the new refinement log div
             const refinementLogDivClear = document.getElementById('refinementLog');
             if (refinementLogDivClear) refinementLogDivClear.innerHTML = '';
             document.getElementById('detailsTitle').innerHTML = 'Resultados Detalhados da Alocação'; globalCurrentlyDisplayedStrategyName = null;
             console.log("[runAllocatorPhase] Clearing complete.");
            // --- End clearing ---

            // Validation checks
            console.log("[runAllocatorPhase] Performing validation checks...");
            if (!globalOriginalItems || globalOriginalItems.length === 0) { statusAreaDiv.innerHTML = `<span class="error">Erro Alocador: Especificações processados ausentes.</span>`; console.error("[runAllocatorPhase] Validation failed: globalOriginalItems missing."); return; }
            if (!globalUserLpdCombinationWithDuplicates) { console.warn("[runAllocatorPhase] globalUserLpdCombinationWithDuplicates undefined, initializing."); globalUserLpdCombinationWithDuplicates = []; }
            else if (globalUserLpdCombinationWithDuplicates.length === 0) { console.warn("[runAllocatorPhase] globalUserLpdCombinationWithDuplicates is empty."); }
            // Ensure necessary globals are arrays/objects even if empty
            if (!globalUniqueLpdValues) globalUniqueLpdValues = [];
            if (!globalInitialTotalSlotsPerValue) globalInitialTotalSlotsPerValue = {};
            console.log("[runAllocatorPhase] Validations complete.");

            // --- Pre-calculate values needed for new heuristics ---
            console.log("[runAllocatorPhase] Pre-calculating heuristic values...");
            let averageLPDValue = 0;
            let smallestPositiveLPD = Infinity;
            let potentialDifferences = new Map(); // Map originalIndex -> { potentialDiff, preliminarySum }

            if (globalUserLpdCombinationWithDuplicates && globalUserLpdCombinationWithDuplicates.length > 0) {
                let sumLPDs = 0;
                let positiveLPDs = [];
                globalUserLpdCombinationWithDuplicates.forEach(lpd => {
                    if (typeof lpd === 'number' && !isNaN(lpd)) {
                        sumLPDs += lpd;
                        if (lpd > 0) {
                            positiveLPDs.push(lpd);
                            if (lpd < smallestPositiveLPD) { smallestPositiveLPD = lpd; }
                        }
                    } else { console.warn("[runAllocatorPhase] Non-numeric LPD found in combination:", lpd); }
                });
                if (globalUserLpdCombinationWithDuplicates.length > 0) { averageLPDValue = sumLPDs / globalUserLpdCombinationWithDuplicates.length; }
                if (smallestPositiveLPD === Infinity) smallestPositiveLPD = 0;

                // Calculate potential differences
                console.log("[runAllocatorPhase] Calculating potential differences...");
                const initialSlotsCopy = { ...globalInitialTotalSlotsPerValue };
                if (globalOriginalItems && Array.isArray(globalOriginalItems)) {
                    globalOriginalItems.forEach(item => {
                        if (!item || typeof item.originalIndex === 'undefined') { console.warn("[runAllocatorPhase] Skipping invalid item during potential difference calculation:", item); return; }
                        if (!globalUniqueLpdValues || globalUniqueLpdValues.length === 0) {
                             potentialDifferences.set(item.originalIndex, { potentialDiff: Math.abs(item.amount || 0), preliminarySum: 0, prelimError: "No LPDs" }); return;
                        }
                         const prelimResult = findClosestSumWithRepetitionAndSlots(globalUniqueLpdValues, item.amount, initialSlotsCopy);
                         potentialDifferences.set(item.originalIndex, { potentialDiff: Math.abs(prelimResult.difference === undefined ? (item.amount || 0) : prelimResult.difference), preliminarySum: prelimResult.sum, prelimError: prelimResult.error });
                     });
                    console.log("[runAllocatorPhase] Potential differences calculation loop finished.");
                 } else { console.error("[runAllocatorPhase] globalOriginalItems is not a valid array for potential difference calculation."); }
                 console.log("[runAllocatorPhase] Potential differences map:", potentialDifferences);

            } else { console.warn("[runAllocatorPhase] No LPD combination available for heuristic pre-calculation."); smallestPositiveLPD = 0; }
             console.log(`[runAllocatorPhase] Pre-calculation complete. AvgLPD: ${averageLPDValue.toFixed(2)}, Smallest+LPD: ${smallestPositiveLPD}`);
            // --- End Pre-calculation ---


             // Strategy Definitions - Including NEW Heuristics
             const strategies = [
                 // Existing Strategies
                 { name: "Ordem Original de Entrada", sortFn: (items) => [...items] }, { name: "Quantidade Ascendente", sortFn: (items) => [...items].sort((a, b) => a.amount - b.amount) }, { name: "Quantidade Descendente", sortFn: (items) => [...items].sort((a, b) => b.amount - a.amount) }, { name: "Especificação Ascendente (A-Z)", sortFn: (items) => [...items].sort((a, b) => a.details.localeCompare(b.details)) }, { name: "Especificação Descendente (Z-A)", sortFn: (items) => [...items].sort((a, b) => b.details.localeCompare(a.details)) }, { name: "Quantidade Meio-para-Fora (Baixo/Cima)", sortFn: (items) => { const s = [...items].sort((a, b) => a.amount - b.amount), r = [], n = s.length; if (n === 0) return []; const m = Math.floor(n / 2); r.push(s[m]); let l = m - 1, g = m + 1; while (l >= 0 || g < n) { if (l >= 0) r.push(s[l--]); if (g < n) r.push(s[g++]); } return r; }}, { name: "Quantidade Meio-para-Fora (Cima/Baixo)", sortFn: (items) => { const s = [...items].sort((a, b) => a.amount - b.amount), r = [], n = s.length; if (n === 0) return []; const m = Math.floor(n / 2); r.push(s[m]); let l = m - 1, g = m + 1; while (l >= 0 || g < n) { if (g < n) r.push(s[g++]); if (l >= 0) r.push(s[l--]); } return r; }}, { name: "Especificação Meio-para-Fora (Baixo/Cima)", sortFn: (items) => { const s = [...items].sort((a,b)=>a.details.localeCompare(b.details)), r = [], n = s.length; if (n === 0) return []; const m = Math.floor(n / 2); r.push(s[m]); let l = m - 1, g = m + 1; while (l >= 0 || g < n) { if (l >= 0) r.push(s[l--]); if (g < n) r.push(s[g++]); } return r; }}, { name: "Especificação Meio-para-Fora (Cima/Baixo)", sortFn: (items) => { const s = [...items].sort((a,b)=>a.details.localeCompare(b.details)), r = [], n = s.length; if (n === 0) return []; const m = Math.floor(n / 2); r.push(s[m]); let l = m - 1, g = m + 1; while (l >= 0 || g < n) { if (g < n) r.push(s[g++]); if (l >= 0) r.push(s[l--]); } return r; }}, { name: "Quantidade Fora-para-Dentro (Intercalado)", sortFn: (items) => { const s = [...items].sort((a,b)=>a.amount - b.amount), r = []; let l = 0, g = s.length - 1; while(l <= g) { r.push(s[l++]); if (l <= g) { r.push(s[g--]); } } return r; }}, { name: "Especificação Fora-para-Dentro (Intercalado)", sortFn: (items) => { const s = [...items].sort((a,b)=>a.details.localeCompare(b.details)), r = []; let l = 0, g = s.length - 1; while(l <= g) { r.push(s[l++]); if (l <= g) { r.push(s[g--]); } } return r; }}, { name: "Qtd Asc, Especificação Asc (Desempate)", sortFn: (items) => [...items].sort((a, b) => a.amount - b.amount || a.details.localeCompare(b.details)) }, { name: "Qtd Asc, Índice Asc (Desempate)", sortFn: (items) => [...items].sort((a, b) => a.amount - b.amount || a.originalIndex - b.originalIndex) }, { name: "Qtd Asc, Índice Desc (Desempate)", sortFn: (items) => [...items].sort((a, b) => a.amount - b.amount || b.originalIndex - a.originalIndex) }, { name: "Qtd Desc, Índice Asc (Desempate)", sortFn: (items) => [...items].sort((a, b) => b.amount - a.amount || a.originalIndex - b.originalIndex) }, { name: "Qtd Desc, Índice Desc (Desempate)", sortFn: (items) => [...items].sort((a, b) => b.amount - a.amount || b.originalIndex - a.originalIndex) }, { name: "Quantidade por Último Dígito", sortFn: (items) => [...items].sort((a, b) => (a.amount % 10) - (b.amount % 10) || a.amount - b.amount) }, { name: "Quantidade por Primeiro Dígito", sortFn: (items) => { const fd = (n) => {n=Math.abs(n); if(n===0) return 0; while(n>=10) n=Math.floor(n/10); return n;}; return [...items].sort((a, b) => fd(a.amount) - fd(b.amount) || a.amount - b.amount); }}, { name: "Qtd Asc (Processa Terços P->G->M)", sortFn: (items) => { const s = [...items].sort((a,b)=>a.amount-b.amount), n=s.length, t=Math.ceil(n/3); return [...s.slice(0,t), ...s.slice(n-t), ...s.slice(t,n-t)]; }}, { name: "Qtd Desc (Processa Terços G->P->M)", sortFn: (items) => { const s = [...items].sort((a,b)=>b.amount-a.amount), n=s.length, t=Math.ceil(n/3); return [...s.slice(0,t), ...s.slice(n-t), ...s.slice(t,n-t)]; }}, { name: "Qtd Asc (Intercala por 3: 0,3.. 1,4.. 2,5..)", sortFn: (items) => { const s=[...items].sort((a,b)=>a.amount-b.amount), r=[], n=s.length; for(let k=0;k<3;k++) for(let i=k;i<n;i+=3) r.push(s[i]); return r; }}, { name: "Qtd Desc (Intercala por 3: 0,3.. 1,4.. 2,5..)", sortFn: (items) => { const s=[...items].sort((a,b)=>b.amount-a.amount), r=[], n=s.length; for(let k=0;k<3;k++) for(let i=k;i<n;i+=3) r.push(s[i]); return r; }}, { name: "Desvio da Média Qtd (Mais Próximo Primeiro)", sortFn: (items) => { if(items.length===0) return []; const avg = items.reduce((sum,i)=>sum+i.amount,0)/items.length; return [...items].sort((a,b)=>Math.abs(a.amount-avg)-Math.abs(b.amount-avg)); }}, { name: "Desvio da Média Qtd (Mais Distante Primeiro)", sortFn: (items) => { if(items.length===0) return []; const avg = items.reduce((sum,i)=>sum+i.amount,0)/items.length; return [...items].sort((a,b)=>Math.abs(b.amount-avg)-Math.abs(a.amount-avg)); }},
                 { name: "Maior Dificuldade Potencial Primeiro", sortFn: (items) => [...items].sort((a, b) => { const diffB = (potentialDifferences.get(b.originalIndex) || { potentialDiff: 0 }).potentialDiff; const diffA = (potentialDifferences.get(a.originalIndex) || { potentialDiff: 0 }).potentialDiff; return diffB - diffA; }) },
                 { name: "Menor Dificuldade Potencial Primeiro", sortFn: (items) => [...items].sort((a, b) => { const diffA = (potentialDifferences.get(a.originalIndex) || { potentialDiff: 0 }).potentialDiff; const diffB = (potentialDifferences.get(b.originalIndex) || { potentialDiff: 0 }).potentialDiff; return diffA - diffB; }) },
                 { name: "Maior Demanda Estimada Primeiro (Avg LPD)", sortFn: (items) => [...items].sort((a, b) => { const demandB = averageLPDValue > 0 ? (b.amount / averageLPDValue) : (b.amount > 0 ? Infinity : 0); const demandA = averageLPDValue > 0 ? (a.amount / averageLPDValue) : (a.amount > 0 ? Infinity : 0); return demandB - demandA; }) },
                 { name: "Menor Flexibilidade Primeiro (LPDs <= Alvo)", sortFn: (items) => [...items].sort((a, b) => { const countA = globalUniqueLpdValues.filter(lpd => lpd > 0 && lpd <= a.amount).length; const countB = globalUniqueLpdValues.filter(lpd => lpd > 0 && lpd <= b.amount).length; return countA - countB || a.amount - b.amount; }) },
                 { name: "Maior Granularidade Necessária Primeiro (Alvo/MenorLPD)", sortFn: (items) => [...items].sort((a, b) => { const ratioA = smallestPositiveLPD > 0 ? (a.amount / smallestPositiveLPD) : (a.amount > 0 ? Infinity : 0); const ratioB = smallestPositiveLPD > 0 ? (b.amount / smallestPositiveLPD) : (b.amount > 0 ? Infinity : 0); return ratioA - ratioB || a.amount - b.amount; }) },
                 { name: "Dependência LPD Crítico Mais Raro Primeiro", sortFn: (items) => {
                      const findCriticalLPD = (itemAmount) => { let maxFound = -1; for (const lpd of globalUniqueLpdValues) { if (lpd > 0 && lpd <= itemAmount && lpd > maxFound) { maxFound = lpd; } } return maxFound > 0 ? maxFound : 0; };
                      return [...items].sort((a, b) => {
                          const criticalLPD_A = findCriticalLPD(a.amount); const criticalLPD_B = findCriticalLPD(b.amount);
                          const availabilityA = (criticalLPD_A > 0 && globalInitialTotalSlotsPerValue.hasOwnProperty(criticalLPD_A)) ? globalInitialTotalSlotsPerValue[criticalLPD_A] : Infinity;
                          const availabilityB = (criticalLPD_B > 0 && globalInitialTotalSlotsPerValue.hasOwnProperty(criticalLPD_B)) ? globalInitialTotalSlotsPerValue[criticalLPD_B] : Infinity;
                           if (availabilityA === Infinity && availabilityB !== Infinity) return 1; if (availabilityA !== Infinity && availabilityB === Infinity) return -1;
                           if (availabilityA !== Infinity && availabilityB !== Infinity) { const availabilityDiff = availabilityA - availabilityB; if (availabilityDiff !== 0) return availabilityDiff; }
                           const amountDiff = b.amount - a.amount; if (amountDiff !== 0) return amountDiff; return a.originalIndex - b.originalIndex;
                      }); }
                 }
             ];
             console.log("[runAllocatorPhase] Final strategies array defined, NEW count:", strategies ? strategies.length : 'undefined');
             if (!strategies || strategies.length === 0) { /* ... error handling ... */ return; }

            let localStrategyResults = []; // Initialize results array here
            const comboString = globalUserLpdCombinationWithDuplicates.length > 0 ? `[${globalUserLpdCombinationWithDuplicates.join(', ')}]` : '[Vazia]';
            if(statusAreaDiv) statusAreaDiv.innerHTML = `Executando alocação para ${strategies.length} estratégias (${comboString})... Preparando processamento...`;
            console.log(`[runAllocatorPhase] Status updated. Setting timeout to process ${strategies.length} strategies.`);

            setTimeout(() => {
                 console.log("[runAllocatorPhase] ---> setTimeout CALLBACK START <---");
                 if (!strategies || strategies.length === 0) { /* ... error handling ... */ return; }
                 console.log("[runAllocatorPhase] Inside setTimeout: strategies count =", strategies.length);
                 if(statusAreaDiv) statusAreaDiv.innerHTML = `Processando ${strategies.length} estratégias... (0%)`;

                try {
                    // --- Step 1: Run strategies, generate results & assembly data ---
                    for (let i = 0; i < strategies.length; i++) {
                        const strategy = strategies[i];
                        console.log(`[runAllocatorPhase] --- Loop Start: Strategy [${i+1}/${strategies.length}] ${strategy.name} ---`);

                        let currentItemsOrdered;
                        try {
                             currentItemsOrdered = strategy.sortFn([...globalOriginalItems]).map((item, idx) => ({ ...item, index: idx }));
                        } catch (sortError) {
                             console.error(`[runAllocatorPhase] [${i}] ERROR during sortFn for ${strategy.name}:`, sortError);
                             localStrategyResults.push({ strategyName: strategy.name, hasAllocationError: true, resultData: { error: `Sort Error: ${sortError.message}` }, maxVariation: Infinity, avgVariation: Infinity, meetsLimit: false, planAssemblyDataForExport: null, displayMaxVarStr: '', displayAvgVarStr: '', displayOutcomeStr: `<span class="error">Sort Error</span>`, isDuplicateResult: false });
                             continue;
                        }

                        let result;
                        try {
                             result = runAllocationProcess(currentItemsOrdered, [...globalUserLpdCombinationWithDuplicates], globalMaxSlotsPerInstance);
                             if (!result) console.warn(`[runAllocatorPhase] [${i}] runAllocationProcess returned null/undefined.`);
                         } catch (allocError) {
                             console.error(`[runAllocatorPhase] [${i}] ERROR during runAllocationProcess for ${strategy.name}:`, allocError);
                             result = { error: `Allocation Error: ${allocError.message}`, itemAllocations: null };
                         }

                        // Error checks...
                        let hasAllocationError = false; let firstErrorMessage = "";
                        if (!result || !result.itemAllocations) {
                             hasAllocationError = true;
                             firstErrorMessage = result ? (result.error || "Item allocations missing.") : "Allocation result missing.";
                        } else {
                            for(let itemAllocIdx = 0; itemAllocIdx < result.itemAllocations.length; itemAllocIdx++) {
                                const alloc = result.itemAllocations[itemAllocIdx]; const item = currentItemsOrdered[itemAllocIdx];
                                if (!alloc) { hasAllocationError = true; firstErrorMessage = "Objeto aloc ausente"; break; }
                                if (alloc.error) { hasAllocationError = true; if (!firstErrorMessage) firstErrorMessage = alloc.error; }
                                if (!alloc.error && item && item.amount > 0 && alloc.sum === 0 && alloc.combination && alloc.combination.length === 0) { hasAllocationError = true; const zeroSumError = "Soma 0 para alvo > 0 (Falha DP?)"; alloc.error = zeroSumError; if (!firstErrorMessage) firstErrorMessage = zeroSumError; }
                            }
                        }
                        if (hasAllocationError && !firstErrorMessage && result && result.error) { firstErrorMessage = result.error; }
                        if (hasAllocationError) console.warn(`[runAllocatorPhase] [${i}] Allocation error detected for ${strategy.name}. First: "${firstErrorMessage}"`);

                        // Calculate Metrics
                        let maxVariation = Infinity, avgVariation = Infinity;
                        if (!hasAllocationError && result && result.itemAllocations){
                            try {
                                maxVariation = calculateMaxVariation(currentItemsOrdered, result.itemAllocations);
                                avgVariation = calculateAverageVariation(currentItemsOrdered, result.itemAllocations);
                            } catch (metricError){
                                console.error(`[runAllocatorPhase] [${i}] Error calculating metrics for ${strategy.name}:`, metricError);
                                hasAllocationError = true; if (!firstErrorMessage) firstErrorMessage = `Metric Calc Error: ${metricError.message}`;
                                maxVariation = Infinity; avgVariation = Infinity;
                            }
                        }
                        const meetsLimit = !hasAllocationError && maxVariation <= REPROCESS_VARIATION_LIMIT;

                        // Generate Assembly Data using Helper
                        let planAssemblyData = null;
                        if (!hasAllocationError && result && result.itemAllocations) {
                            try {
                                planAssemblyData = generatePlanAssemblyData(currentItemsOrdered, result.itemAllocations, globalUserLpdCombinationWithDuplicates, globalMaxSlotsPerInstance);
                            } catch (assemblyError) {
                                console.error(`[runAllocatorPhase] [${i}] ERROR during generatePlanAssemblyData for ${strategy.name}:`, assemblyError);
                                if (!firstErrorMessage && !hasAllocationError) firstErrorMessage = `Assembly Gen Error: ${assemblyError.message}`;
                            }
                        }

                        // Store the result
                        const resultEntry = {
                            strategyName: strategy.name, itemsUsed: currentItemsOrdered, resultData: result,
                            maxVariation: maxVariation, avgVariation: avgVariation, meetsLimit: meetsLimit,
                            hasAllocationError: hasAllocationError,
                            planAssemblyDataForExport: planAssemblyData,
                            displayMaxVarStr: '', displayAvgVarStr: '', displayOutcomeStr: '',
                            isDuplicateResult: false
                        };
                        localStrategyResults.push(resultEntry);

                        // Update progress
                        const progress = Math.round(((i + 1) / strategies.length) * 100);
                        if(statusAreaDiv) statusAreaDiv.innerHTML = `Processando ${strategies.length} estratégias... (${progress}%)`;

                    } // End for loop strategies

                    console.log("[runAllocatorPhase] Finished running all strategies. Local results count:", localStrategyResults.length);
                    if(localStrategyResults.length !== strategies.length) { console.error(`CRITICAL: Number of results (${localStrategyResults.length}) !== strategies (${strategies.length})!`); }

                    // --- Step 2: Sort results ---
                    console.log("[runAllocatorPhase] Sorting results...");
                    const successResults = [], highVarResults = [], errorResults = [];
                    localStrategyResults.forEach(res => {
                         if (res.hasAllocationError) errorResults.push(res);
                         else if (res.meetsLimit) successResults.push(res);
                         else highVarResults.push(res);
                    });
                    const sortByAvgVar = (a, b) => a.avgVariation - b.avgVariation;
                    successResults.sort(sortByAvgVar); highVarResults.sort(sortByAvgVar); errorResults.sort(sortByAvgVar);
                    const sortedResults = [...successResults, ...highVarResults, ...errorResults];
                    console.log("[runAllocatorPhase] Sorting complete. Sorted results count:", sortedResults.length);

                     // --- Step 3: Identify Duplicates & Pre-calculate Display Strings ---
                     console.log("[runAllocatorPhase] Identifying duplicates and pre-calculating display strings...");
                     const encounteredAssemblies = new Set(); const encounteredDisplaySummaries = new Set();
                     let duplicateCount = 0;

                     sortedResults.forEach((res, index) => {
                         try {
                            // Pre-calculate display strings
                            if (res.hasAllocationError) {
                                res.displayOutcomeStr = `<span class="error">Erro</span>`;
                                res.displayMaxVarStr = '?'; res.displayAvgVarStr = '?';
                            } else {
                                if (res.maxVariation === Infinity) { res.displayMaxVarStr = '<span class="violation">Infinita</span>'; }
                                else { res.displayMaxVarStr = (res.maxVariation * 100).toFixed(1) + '%'; if (!res.meetsLimit) res.displayMaxVarStr = `<span class="warning">${res.displayMaxVarStr}</span>`; }
                                res.displayAvgVarStr = (res.avgVariation * 100).toFixed(1) + '%';
                                if (res.meetsLimit) { res.displayOutcomeStr = `<span class="success">Sucesso</span>`; }
                                else { res.displayOutcomeStr = `<span class="warning">Var Alta</span>`; }
                            }
                            const displaySummarySignature = `${res.displayMaxVarStr}-${res.displayAvgVarStr}-${res.displayOutcomeStr}`;

                            const assemblyString = res.planAssemblyDataForExport ? JSON.stringify(res.planAssemblyDataForExport) : 'null_assembly';

                            // Check for duplication based on *previous* encounters
                            let isAssemblyDuplicate = false;
                            if (assemblyString !== 'null_assembly') { isAssemblyDuplicate = encounteredAssemblies.has(assemblyString); }
                            const isDisplaySummaryDuplicate = encounteredDisplaySummaries.has(displaySummarySignature);

                            // Check OR condition
                            if (isAssemblyDuplicate || isDisplaySummaryDuplicate) {
                                res.isDuplicateResult = true; duplicateCount++;
                                let reason = [];
                                if (isAssemblyDuplicate) reason.push("Assembly"); if (isDisplaySummaryDuplicate) reason.push("Display Summary");
                                if (reason.length > 0) { console.log(`[${index}] Marking ${res.strategyName} as duplicate (Reason: ${reason.join(' & ')})`); }
                                else { console.warn(`[${index}] Marked ${res.strategyName} duplicate without specific reason? AssemblyNull: ${assemblyString === 'null_assembly'}, DispDup: ${isDisplaySummaryDuplicate}`); }
                            } else { res.isDuplicateResult = false; /* console.log(`[${index}] ${res.strategyName} is unique so far.`); */ }

                            // Add the current signatures to the sets *after* checking.
                            if (assemblyString !== 'null_assembly') { encounteredAssemblies.add(assemblyString); }
                            encounteredDisplaySummaries.add(displaySummarySignature);

                         } catch (duplicateCheckError) { console.error(`Error during duplicate check for strategy ${res.strategyName} (index ${index}):`, duplicateCheckError); res.isDuplicateResult = false; }
                     });
                     console.log(`[runAllocatorPhase] Finished duplicate checks. Found ${duplicateCount} duplicates.`);

                     // --- Step 4: Set final global results and determine default view ---
                     console.log("[runAllocatorPhase] Setting global results and determining default view...");
                     globalStrategyResults = sortedResults;
                     let finalResultToShow = null; let statusMessage = "";
                     finalResultToShow = globalStrategyResults.find(r => r.meetsLimit && !r.hasAllocationError && !r.isDuplicateResult);
                     if (!finalResultToShow) { finalResultToShow = globalStrategyResults.find(r => !r.hasAllocationError && !r.isDuplicateResult); }
                     if (!finalResultToShow) { finalResultToShow = globalStrategyResults.find(r => !r.isDuplicateResult); }
                     if (!finalResultToShow && globalStrategyResults.length > 0) { finalResultToShow = globalStrategyResults[0]; }
                     console.log("[runAllocatorPhase] Default strategy to show:", finalResultToShow ? finalResultToShow.strategyName : "None");

                     // Generate status message
                      if (finalResultToShow) {
                        const selected = globalStrategyResults.find(r => r.strategyName === finalResultToShow.strategyName);
                        if (selected) {
                            if (selected.meetsLimit && !selected.hasAllocationError && !selected.isDuplicateResult) { statusMessage = `<span class="success">Visão Padrão: Primeira estratégia c/ resultado único dentro do limite: ${selected.strategyName}</span>. Clique abaixo...`; }
                            else if (!selected.hasAllocationError && !selected.isDuplicateResult) { const vStr = selected.displayMaxVarStr; const avgStr = selected.displayAvgVarStr; statusMessage = `<span class="warning">Visão Padrão: Nenhuma estratégia c/ resultado único atendeu ao limite. Mostrando primeira <span class="info">única sem erro</span>:</span> <span class="info">${selected.strategyName}</span> (Máx: ${vStr}, Média: ${avgStr}). Clique abaixo...`; }
                            else if (!selected.isDuplicateResult) { const vStr = selected.displayMaxVarStr; const avgStr = selected.displayAvgVarStr; statusMessage = `<span class="error">Visão Padrão: Nenhuma estratégia c/ resultado único sem erro. Mostrando primeira <span class="info">única (com erro)</span>:</span> <span class="info">${selected.strategyName}</span> (Máx: ${vStr}, Média: ${avgStr}). Clique abaixo...`; }
                            else { const vStr = selected.displayMaxVarStr; const avgStr = selected.displayAvgVarStr; statusMessage = `<span class="error">Visão Padrão: Todas as estratégias parecem duplicadas? Mostrando a primeira:</span> <span class="info">${selected.strategyName}</span> (Máx: ${vStr}, Média: ${avgStr}). Clique abaixo...`; }
                        } else { statusMessage = `<span class="error">Erro: Falha ao encontrar detalhes da estratégia padrão selecionada.</span>`; }
                     } else { statusMessage = `<span class="error">Erro: Nenhum resultado de estratégia gerado ou selecionado.</span>`; }
                     if(statusAreaDiv) statusAreaDiv.innerHTML = statusMessage; // Update status with final outcome

                    // --- Step 4.5: Apply Iterative Refinement to the Best Result ---
                    let refinementLogContent = "Nenhum refinamento aplicado (nenhuma estratégia selecionada ou erro inicial)."; // Default log
                    if (finalResultToShow && !finalResultToShow.hasAllocationError) { // Only refine if a result was selected AND it didn't have initial errors
                        console.log(`[runAllocatorPhase] Applying refinement to selected strategy: ${finalResultToShow.strategyName}`);
                        try {
                            // Pass a DEEP COPY to refineAllocationResult to avoid modifying the original if refinement fails midway
                            const resultToRefineCopy = JSON.parse(JSON.stringify(finalResultToShow));
                            const refinementOutcome = refineAllocationResult(resultToRefineCopy);

                            // Update the entry in globalStrategyResults with the refined one *only if successful*
                            if (refinementOutcome && refinementOutcome.refinedResultEntry) {
                                const indexToUpdate = globalStrategyResults.findIndex(r => r.strategyName === finalResultToShow.strategyName);
                                if (indexToUpdate !== -1) {
                                    // Update the global results array with the refined data
                                    globalStrategyResults[indexToUpdate] = refinementOutcome.refinedResultEntry;
                                    // Update finalResultToShow to point to the refined entry in the global array
                                    finalResultToShow = globalStrategyResults[indexToUpdate];
                                    console.log(`[runAllocatorPhase] Updated globalStrategyResults with refined data for index ${indexToUpdate}.`);
                                    refinementLogContent = refinementOutcome.log; // Get log from successful refinement
                                } else {
                                    console.error(`[runAllocatorPhase] Could not find strategy ${finalResultToShow.strategyName} in global results to update after refinement!`);
                                    refinementLogContent = `<span class='error'>Erro interno: Falha ao atualizar estratégia pós-refinamento.</span>`;
                                }
                            } else {
                                 console.error(`[runAllocatorPhase] Refinement function returned invalid outcome for ${finalResultToShow.strategyName}.`);
                                 refinementLogContent = `<span class='error'>Erro: Função de refinamento falhou.</span>`;
                            }
                        } catch (refinementError) {
                            console.error(`[runAllocatorPhase] Error during refinement call for ${finalResultToShow.strategyName}:`, refinementError);
                            refinementLogContent = `<span class='error'>Erro durante o processo de refinamento: ${refinementError.message}</span>`;
                        }
                    } else if (finalResultToShow && finalResultToShow.hasAllocationError) {
                        refinementLogContent = `<span class='warning'>Refinamento não aplicado pois a estratégia selecionada (${finalResultToShow.strategyName}) continha erros iniciais.</span>`;
                        console.warn(`[runAllocatorPhase] Skipping refinement for selected strategy ${finalResultToShow.strategyName} due to initial errors.`);
                    } else {
                         console.warn("[runAllocatorPhase] No strategy selected for refinement.");
                    }
                    // Update the refinement log display area
                    const refinementLogDiv = document.getElementById('refinementLog');
                    if (refinementLogDiv) {
                        refinementLogDiv.innerHTML = refinementLogContent;
                        console.log("[runAllocatorPhase] Refinement log displayed.");
                    } else { console.error("[runAllocatorPhase] Refinement log div not found!"); }
                    // --- END REFINEMENT BLOCK ---

                    // --- Step 5: Generate Comparison Table HTML ---
                    console.log("[runAllocatorPhase] Generating comparison table HTML (using potentially refined metrics)...");
                    let comparisonHTML = `<div class="comparison-title">--- Resumo da Comparação de Estratégias ---</div>`;
                    comparisonHTML += `<div id="comparisonTableContainer" class="comparison-table-container hide-errors hide-duplicates">`;
                    comparisonHTML += `<table id="comparisonTable"><thead><tr><th>Estratégia</th><th>Var Máx (%)</th><th>Var Média (%)</th><th>Resultado</th></tr></thead><tbody>`;

                    let errorCount = 0; let finalDuplicateCount = 0;
                    if (globalStrategyResults && globalStrategyResults.length > 0) {
                        globalStrategyResults.forEach((res, index) => {
                             try {
                                // Retrieve pre-calculated or REFINED display strings/metrics
                                // Note: refineAllocationResult updates meetsLimit flag, but not display strings directly. Regenerate outcome here.
                                const maxVarStr = res.displayMaxVarStr || '?';
                                const avgVarStr = res.displayAvgVarStr || '?';
                                let outcomeStr = ''; // Recalculate based on potentially refined state
                                 if (res.hasAllocationError) { outcomeStr = `<span class="error">Erro</span>`; errorCount++; }
                                 else if (res.meetsLimit) { outcomeStr = `<span class="success">Sucesso</span>`; }
                                 else { outcomeStr = `<span class="warning">Var Alta</span>`; }

                                let rowClass = '';
                                if (res.hasAllocationError) { rowClass = 'strategy-error-row'; /* errorCount already incremented */ }
                                if (res.isDuplicateResult) { rowClass += ' strategy-duplicate-row'; finalDuplicateCount++; }

                                // Check against the potentially updated finalResultToShow
                                const isSelectedStrategy = (finalResultToShow && res.strategyName === finalResultToShow.strategyName);
                                if (isSelectedStrategy) rowClass += ' best-effort';

                                comparisonHTML += `<tr class="${rowClass.trim()}"><td class="strategy-name" onclick="displayStrategyDetails('${encodeURIComponent(res.strategyName)}')">${res.strategyName} ${isSelectedStrategy ? '(Selecionado)' : ''}</td><td>${maxVarStr}</td><td>${avgVarStr}</td><td>${outcomeStr}</td></tr>`;
                             } catch(tableGenError) {
                                 console.error(`Error generating table row for strategy ${res ? res.strategyName : 'Unknown'} (index ${index}):`, tableGenError);
                                 comparisonHTML += `<tr><td colspan="4"><span class="error">Erro ao gerar linha para estratégia ${res ? res.strategyName : 'Desconhecida'}</span></td></tr>`;
                             }
                        });
                    } else {
                        comparisonHTML += '<tr><td colspan="4">Nenhum resultado de estratégia para exibir.</td></tr>';
                    }
                    comparisonHTML += `</tbody></table></div>`; // Close table and container

                    comparisonHTML += `<div class="toggle-buttons-container" style="margin-top: 0.5rem;">`;
                     if (errorCount > 0) { comparisonHTML += `<button id="toggleErrorsBtn" onclick="toggleErrorStrategies()">Mostrar ${errorCount} Estrat. c/ Erro...</button>`; }
                     if (finalDuplicateCount > 0) { comparisonHTML += `<button id="toggleDuplicatesBtn" onclick="toggleDuplicateStrategies()" class="secondary">Mostrar ${finalDuplicateCount} Estrat. c/ Resultados Idênticos...</button>`; }
                    comparisonHTML += `</div>`;

                    console.log("[runAllocatorPhase] Setting strategyComparisonDiv innerHTML...");
                    if(strategyComparisonDiv) strategyComparisonDiv.innerHTML = comparisonHTML;
                    else console.error("strategyComparisonDiv not found!");
                    console.log("[runAllocatorPhase] Finished setting strategyComparisonDiv innerHTML.");

                    // --- Step 6: Display the details of the selected (and potentially refined) default strategy ---
                    if (finalResultToShow) {
                         console.log(`[runAllocatorPhase] Calling displayStrategyDetails for final selected/refined strategy: ${finalResultToShow.strategyName}`);
                         try {
                            displayStrategyDetails(encodeURIComponent(finalResultToShow.strategyName));
                            console.log(`[runAllocatorPhase] Finished calling displayStrategyDetails for ${finalResultToShow.strategyName}`);
                         } catch (displayDetailsError) {
                              console.error(`Error calling displayStrategyDetails for ${finalResultToShow.strategyName}:`, displayDetailsError);
                              if(statusAreaDiv) statusAreaDiv.innerHTML += ` <span class="error">Erro ao exibir detalhes da estratégia selecionada.</span>`;
                              if(allocationResultsDiv) allocationResultsDiv.innerHTML = '<span class="error">Erro ao exibir detalhes.</span>';
                              const lpdBD = document.getElementById('lpdBreakdown'); if(lpdBD) lpdBD.innerHTML = '';
                              const finalSum = document.getElementById('finalSummaryTableDiv'); if(finalSum) finalSum.innerHTML = '';
                         }
                    } else {
                         console.warn("[runAllocatorPhase] No final strategy selected to display details for.");
                         if(allocationResultsDiv) allocationResultsDiv.innerHTML = 'Nenhuma estratégia padrão disponível para exibir.';
                         const lpdBD = document.getElementById('lpdBreakdown'); if(lpdBD) lpdBD.innerHTML = '';
                         const finalSum = document.getElementById('finalSummaryTableDiv'); if(finalSum) finalSum.innerHTML = '';
                    }

                    console.log("[runAllocatorPhase] ---> setTimeout CALLBACK END <---");

                } catch (allocatorError) {
                     console.error("[runAllocatorPhase] CRITICAL ERROR inside setTimeout callback:", allocatorError);
                     if(statusAreaDiv) statusAreaDiv.innerHTML = `<span class="error">Erro GERAL na fase do Alocador. Verifique o console. Err: ${allocatorError.message}</span>`;
                     if (strategyComparisonDiv && !strategyComparisonDiv.innerHTML) { strategyComparisonDiv.innerHTML = '<span class="error">Falha ao gerar comparação.</span>'; }
                 }
            }, 10); // End setTimeout

            console.log("[runAllocatorPhase] END (setTimeout scheduled)");

        } // Fim runAllocatorPhase


        // --- NEW: Iterative Refinement Function ---
        /**
         * Attempts to improve an allocation result by swapping LPDs between
         * items with large positive and negative differences.
         * @param {object} resultEntry - The strategy result object to refine.
         * @returns {{refinedResultEntry: object, log: string}} - Object containing the potentially refined result and the log.
         */
        function refineAllocationResult(resultEntry) {
            console.log(`[refineAllocationResult] START for strategy: ${resultEntry.strategyName}`);
            let refinementLog = [`--- Registro de Refinamento Iterativo (Estratégia: ${resultEntry.strategyName}) ---`];

            // --- Configuration ---
            const MAX_REFINEMENT_PASSES = 5; // Max number of times to iterate looking for swaps
            const MIN_IMPROVEMENT_THRESHOLD = 1; // Minimum reduction in total absolute diff to accept a swap
            const SWAP_VIOLATION_THRESHOLD = VARIATION_LIMIT_PASS_3; // Don't make items worse than this limit if possible

            // --- Input Validation ---
            if (!resultEntry || !resultEntry.resultData || !resultEntry.resultData.itemAllocations || !resultEntry.itemsUsed) {
                refinementLog.push("<span class='error'>Erro: Dados de entrada inválidos para refinamento.</span>");
                console.error("[refineAllocationResult] Invalid input resultEntry:", resultEntry);
                return { refinedResultEntry: resultEntry, log: refinementLog.join('\n') };
            }
            if (resultEntry.hasAllocationError) {
                 refinementLog.push("<span class='warning'>Aviso: Refinamento pulado pois a estratégia inicial continha erros de alocação.</span>");
                 console.log(`[refineAllocationResult] Skipping refinement for ${resultEntry.strategyName} due to initial allocation errors.`);
                 return { refinedResultEntry: resultEntry, log: refinementLog.join('\n') };
            }


            // --- Make deep copies to work on ---
            // We modify these copies and only update the original resultEntry at the end if improvements were made.
            let currentAllocations = JSON.parse(JSON.stringify(resultEntry.resultData.itemAllocations));
            let items = resultEntry.itemsUsed; // No need to deep copy itemsUsed, just reference it

            let overallImprovementMade = false;

            // --- Refinement Loop ---
            for (let pass = 1; pass <= MAX_REFINEMENT_PASSES; pass++) {
                refinementLog.push(`\n--- Passe de Refinamento ${pass}/${MAX_REFINEMENT_PASSES} ---`);
                let swapsMadeInPass = 0;

                // 1. Identify candidate items (significant positive/negative differences)
                let positiveDiffItems = [];
                let negativeDiffItems = [];
                currentAllocations.forEach((alloc, index) => {
                    if (alloc && !alloc.error && alloc.difference !== undefined) {
                        if (alloc.difference > MIN_IMPROVEMENT_THRESHOLD) { // Need some positive diff to give
                            positiveDiffItems.push({ index, alloc });
                        } else if (alloc.difference < -MIN_IMPROVEMENT_THRESHOLD) { // Need some negative diff to receive
                            negativeDiffItems.push({ index, alloc });
                        }
                    }
                });

                if (positiveDiffItems.length === 0 || negativeDiffItems.length === 0) {
                    refinementLog.push("Nenhum par de itens com diferenças opostas significativas encontrado.");
                    break; // No potential swaps possible
                }

                // Sort candidates by magnitude of difference (largest absolute diff first)
                positiveDiffItems.sort((a, b) => b.alloc.difference - a.alloc.difference);
                negativeDiffItems.sort((a, b) => Math.abs(b.alloc.difference) - Math.abs(a.alloc.difference));

                refinementLog.push(`Candidatos (+): ${positiveDiffItems.length}, Candidatos (-): ${negativeDiffItems.length}`);

                // 2. Iterate through potential swaps
                // Use flags to avoid swapping the same item multiple times per pass
                let itemSwappedFlags = new Array(currentAllocations.length).fill(false);

                for (let posItemData of positiveDiffItems) {
                    if (itemSwappedFlags[posItemData.index]) continue; // Already swapped this source item

                    for (let negItemData of negativeDiffItems) {
                        if (itemSwappedFlags[negItemData.index]) continue; // Already swapped this target item
                        if (posItemData.index === negItemData.index) continue; // Cannot swap with self

                        let bestSwapForPair = {
                            lpdToSwap: null,
                            improvement: -Infinity // Maximize the reduction (negative value)
                        };

                        const posIndex = posItemData.index;
                        const negIndex = negItemData.index;
                        const posAlloc = posItemData.alloc;
                        const negAlloc = negItemData.alloc;
                        const posItemTarget = items[posIndex]?.amount ?? 0; // Get original target amount
                        const negItemTarget = items[negIndex]?.amount ?? 0; // Get original target amount

                        // Ensure combinations are arrays
                        const posCombination = Array.isArray(posAlloc.combination) ? posAlloc.combination : [];
                        const negCombination = Array.isArray(negAlloc.combination) ? negAlloc.combination : [];


                        // Check each LPD in the positive item's combination
                        for (let lpdIndex = 0; lpdIndex < posCombination.length; lpdIndex++) {
                            const lpd = posCombination[lpdIndex];
                            if (!lpd || lpd <= 0) continue; // Skip invalid LPDs

                            // Calculate potential new differences
                            const newPosDiff = posAlloc.difference - lpd;
                            const newNegDiff = negAlloc.difference + lpd;

                            // Calculate current and new total absolute differences for the pair
                            const currentTotalAbsDiff = Math.abs(posAlloc.difference) + Math.abs(negAlloc.difference);
                            const newTotalAbsDiff = Math.abs(newPosDiff) + Math.abs(newNegDiff);

                            // Calculate improvement (negative value indicates reduction)
                            const improvement = newTotalAbsDiff - currentTotalAbsDiff;

                            // --- Check Swap Validity Conditions ---
                            // Condition 1: Must provide a minimum improvement
                            if (improvement > -MIN_IMPROVEMENT_THRESHOLD) {
                                continue; // Not a good enough improvement
                            }

                             // Condition 2: (Optional but recommended) Avoid making a non-violating item violate the threshold
                             const currentPosViolates = posItemTarget > 0 && Math.abs(posAlloc.difference / posItemTarget) > SWAP_VIOLATION_THRESHOLD;
                             const currentNegViolates = negItemTarget > 0 && Math.abs(negAlloc.difference / negItemTarget) > SWAP_VIOLATION_THRESHOLD;
                             const newPosViolates = posItemTarget > 0 && Math.abs(newPosDiff / posItemTarget) > SWAP_VIOLATION_THRESHOLD;
                             const newNegViolates = negItemTarget > 0 && Math.abs(newNegDiff / negItemTarget) > SWAP_VIOLATION_THRESHOLD;

                             // Don't allow swap if it MAKES a previously non-violating item violate, UNLESS the other item *stops* violating
                             let makesWorseViolation = false;
                             if ((!currentPosViolates && newPosViolates && !currentNegViolates) || // Pos becomes violator, Neg stays ok/improves
                                 (!currentNegViolates && newNegViolates && !currentPosViolates)) { // Neg becomes violator, Pos stays ok/improves
                                 makesWorseViolation = true;
                             }
                             // Allow if violation status improves for one and doesn't worsen for other, or both improve
                             if (makesWorseViolation && !( (currentPosViolates && !newPosViolates) || (currentNegViolates && !newNegViolates) ) ) {
                                 // refinementLog.push(`   - Tentativa de swap ${lpd} (${posIndex+1} -> ${negIndex+1}) rejeitada: Pioraria violação.`);
                                 continue; // Skip this LPD
                             }
                            // --- End Validity Checks ---


                            // If this swap is better than the best found so far for this pair
                            if (improvement < bestSwapForPair.improvement) {
                                bestSwapForPair.lpdToSwap = lpd;
                                bestSwapForPair.improvement = improvement;
                                // Store the LPD index to remove it correctly later if duplicates exist
                                bestSwapForPair.lpdIndexInPos = lpdIndex;
                            }
                        } // End loop through LPDs in positive item

                        // If a best swap was found for this pair
                        if (bestSwapForPair.lpdToSwap !== null) {
                            const lpd = bestSwapForPair.lpdToSwap;
                            const lpdIdxToRemove = bestSwapForPair.lpdIndexInPos;

                            refinementLog.push(`<div class='adjustment-step'>Swap: Mover Plano <span class='info'>${lpd}</span> de Espec ${posIndex + 1} ('${items[posIndex]?.details}') para Espec ${negIndex + 1} ('${items[negIndex]?.details}') (Melhora: ${(-bestSwapForPair.improvement).toFixed(0)})`);

                            // --- Execute the swap on the copied allocations ---
                            // Remove from positive item
                            posAlloc.combination.splice(lpdIdxToRemove, 1);
                            posAlloc.sum -= lpd;
                            posAlloc.difference -= lpd;
                            posAlloc.finalUsageCounts[lpd] = (posAlloc.finalUsageCounts[lpd] || 1) - 1;
                            if (posAlloc.finalUsageCounts[lpd] <= 0) delete posAlloc.finalUsageCounts[lpd];

                            // Add to negative item
                            negAlloc.combination.push(lpd);
                            negAlloc.combination.sort((a, b) => a - b); // Keep sorted
                            negAlloc.sum += lpd;
                            negAlloc.difference += lpd;
                            negAlloc.finalUsageCounts[lpd] = (negAlloc.finalUsageCounts[lpd] || 0) + 1;
                            // --- End Execute Swap ---

                            refinementLog.push(`   -> Espec ${posIndex + 1}: Nova Dif ${posAlloc.difference.toFixed(0)}`);
                            refinementLog.push(`   -> Espec ${negIndex + 1}: Nova Dif ${negAlloc.difference.toFixed(0)}</div>`);

                            swapsMadeInPass++;
                            overallImprovementMade = true;
                            itemSwappedFlags[posIndex] = true; // Mark items as swapped for this pass
                            itemSwappedFlags[negIndex] = true;
                            break; // Move to the next positive difference item after finding a swap for this one
                        }
                    } // End loop through negative items
                } // End loop through positive items

                refinementLog.push(`Swaps realizados neste passe: ${swapsMadeInPass}`);
                if (swapsMadeInPass === 0) {
                    refinementLog.push("Nenhuma melhoria adicional encontrada neste passe.");
                    break; // Exit refinement loop if no swaps were made
                }
            } // End refinement passes loop

            // --- Final Step: Update original result if improvements were made ---
            if (overallImprovementMade) {
                refinementLog.push("\n<span class='success'>Refinamento concluído. Aplicando melhorias.</span>");
                console.log(`[refineAllocationResult] Improvements made for ${resultEntry.strategyName}. Updating resultEntry.`);
                // Update the original resultEntry's allocation data
                resultEntry.resultData.itemAllocations = currentAllocations;
                // Recalculate metrics based on refined allocations (optional but good practice)
                resultEntry.maxVariation = calculateMaxVariation(items, currentAllocations);
                resultEntry.avgVariation = calculateAverageVariation(items, currentAllocations);
                resultEntry.meetsLimit = !resultEntry.hasAllocationError && resultEntry.maxVariation <= REPROCESS_VARIATION_LIMIT; // Re-check limit
                console.log(`[refineAllocationResult] Recalculated metrics: MaxVar=${resultEntry.maxVariation.toFixed(4)}, AvgVar=${resultEntry.avgVariation.toFixed(4)}, MeetsLimit=${resultEntry.meetsLimit}`);
            } else {
                refinementLog.push("\nNenhuma melhoria encontrada ou aplicada durante o refinamento.");
                console.log(`[refineAllocationResult] No improvements made for ${resultEntry.strategyName}.`);
            }

            console.log(`[refineAllocationResult] END for strategy: ${resultEntry.strategyName}`);
            return { refinedResultEntry: resultEntry, log: refinementLog.join('\n') };
        }
        // --- END Refinement Function ---

        // --- FUNÇÃO PRINCIPAL DE CONTROLE ---
        function initiateProcess(mode) {
            console.clear();
            console.log(`--- Iniciando Processo (Modo: ${mode}) ---`);
            const tableDataInput = document.getElementById('tableData').value.trim();
            const maxSlotsInput = document.getElementById('maxSlots').value.trim();
            const combinationSizeInput = document.getElementById('combinationSize').value.trim();
            const finderResultsLogDiv = document.getElementById('finderResultsLog');
            const foundCombinationDisplayDiv = document.getElementById('foundCombinationDisplay');
            const statusAreaDiv = document.getElementById('statusArea');
            const strategyComparisonDiv = document.getElementById('strategyComparison');
            const allocationResultsDiv = document.getElementById('allocationResults');
            const adjustmentLogDiv = document.getElementById('adjustmentLog');
            const variationLogDiv = document.getElementById('variationLog');
            const cumulativeUsageDiv = document.getElementById('cumulativeUsage');
            const lpdBreakdownDiv = document.getElementById('lpdBreakdown');
            const finalSummaryTableDiv = document.getElementById('finalSummaryTableDiv');
            const detailsTitleH2 = document.getElementById('detailsTitle');

            // Clear previous results
            finderResultsLogDiv.innerHTML = `Processando Combinação (Modo: ${mode})...`;
            foundCombinationDisplayDiv.innerHTML = "";
            statusAreaDiv.innerHTML = "Aguardando Combinação...";
            strategyComparisonDiv.innerHTML = ""; allocationResultsDiv.innerHTML = ""; adjustmentLogDiv.innerHTML = ""; variationLogDiv.innerHTML = ""; cumulativeUsageDiv.innerHTML = ""; lpdBreakdownDiv.innerHTML = ""; finalSummaryTableDiv.innerHTML = ""; detailsTitleH2.innerHTML = 'Resultados Detalhados da Alocação';
             globalCurrentlyDisplayedStrategyName = null; // Reseta estratégia selecionada

            // Reset Globals
            globalStrategyResults = []; globalOriginalItems = []; globalUniqueLpdValues = []; globalUserLpdCombinationWithDuplicates = []; globalLpdInstanceCounts = {}; globalInitialTotalSlotsPerValue = {}; globalMaxSlotsPerInstance = Infinity; globalMaxSlotsDisplay = "Ilimitado";

            if (!tableDataInput) { finderResultsLogDiv.innerHTML = '<span class="error">Erro: Dados da tabela vazios.</span>'; return; }
            if (!maxSlotsInput) { finderResultsLogDiv.innerHTML = '<span class="error">Erro: "Imagens no Plano" é obrigatório.</span>'; return; }
            if (!combinationSizeInput) { finderResultsLogDiv.innerHTML = '<span class="error">Erro: "Quantidade de Planos" é obrigatório.</span>'; return; }
            let maxSlotsPerInstance; let combinationSize;
             try { maxSlotsPerInstance = parseInt(maxSlotsInput); if (isNaN(maxSlotsPerInstance) || maxSlotsPerInstance < 1) throw new Error('"Imagens no Plano" >= 1.'); globalMaxSlotsPerInstance = maxSlotsPerInstance; globalMaxSlotsDisplay = String(maxSlotsPerInstance); } catch (e) { finderResultsLogDiv.innerHTML = `<span class="error">Erro de Entrada: ${e.message}</span>`; return; }
             try { combinationSize = parseInt(combinationSizeInput); if (isNaN(combinationSize) || combinationSize < 1) throw new Error('"Quantidade de Planos" >= 1.'); } catch (e) { finderResultsLogDiv.innerHTML = `<span class="error">Erro de Entrada: ${e.message}</span>`; return; }

            // Input Parsing (Robust version)
            let parsedItems = []; let parseErrors = []; const lines = tableDataInput.split('\n'); let minRawAmount = Infinity, maxRawAmount = -Infinity, sumRawAmount = 0, validItemCount = 0;
            lines.forEach((line, index) => {
                line = line.trim(); if (!line) return;
                let details = ''; let amountStrRaw = ''; let parts = line.split('\t');
                if (parts.length >= 2) { amountStrRaw = parts[parts.length - 1]; details = parts.slice(0, -1).join('\t'); }
                else { const lastSpaceIndex = line.lastIndexOf(' ');
                    if (lastSpaceIndex === -1 || lastSpaceIndex === 0) { parts = line.split(/\s+/); if (parts.length >= 2) { amountStrRaw = parts[parts.length - 1]; details = parts.slice(0, -1).join(' '); } else { parseErrors.push(`L${index + 1}: Formato inválido: "${line}"`); return; } }
                    else { amountStrRaw = line.substring(lastSpaceIndex + 1); details = line.substring(0, lastSpaceIndex); }
                }
                let amountStrClean = amountStrRaw.replace(/[R$€]/g, '').trim();
                let amountStrParsed = amountStrClean.replace(/\./g, '').replace(/,/g, '.');
                const amount = parseFloat(amountStrParsed);
                if (isNaN(amount)) { parseErrors.push(`L${index + 1}: Quantidade inválida ('${amountStrRaw}') para "${details}"`); return; }
                if (amount < 0) { parseErrors.push(`L${index + 1}: Quantidade negativa (${amount}) para "${details}"`); return; }
                const roundedAmount = Math.round(amount);
                parsedItems.push({ details: details, amount: roundedAmount, originalIndex: index });
                sumRawAmount += roundedAmount; validItemCount++;
                if (roundedAmount < minRawAmount) minRawAmount = roundedAmount;
                if (roundedAmount > maxRawAmount) maxRawAmount = roundedAmount;
            });

            if (parseErrors.length > 0) { finderResultsLogDiv.innerHTML = `<span class="error">Erros ao Processar Entradas:</span>\n${parseErrors.join('\n')}`; return; }
            if (parsedItems.length === 0) { finderResultsLogDiv.innerHTML = `<span class="error">Erro: Nenhuma Especificação válida processada. Verifique o formato da entrada.</span>`; return; }
            globalOriginalItems = parsedItems;
            console.log(`Processados ${validItemCount} Especificações. Soma: ${sumRawAmount}, Mín: ${minRawAmount === Infinity ? 'N/A' : minRawAmount}, Máx: ${maxRawAmount === -Infinity ? 'N/A' : maxRawAmount}`);

            // Generate Combination
            finderResultsLogDiv.innerHTML = `Gerando Combinação (Modo: ${mode})...`;
            setTimeout(() => {
                try {
                    let combinationResult = null;
                    let combinationMethodDescription = "";

                    if (mode === 'findBest') {
                        console.log("Chamando findBestLpdCombination...");
                        combinationResult = findBestLpdCombination(globalOriginalItems, maxSlotsPerInstance, combinationSize);
                        combinationMethodDescription = "Otimização por Frequência de Divisores";
                    } else if (mode === 'forceProportional') {
                        console.log("Chamando calculateDirectProportionalCombination...");
                        combinationResult = calculateDirectProportionalCombination(globalOriginalItems, maxSlotsPerInstance, combinationSize);
                        combinationMethodDescription = "Distribuição Proporcional Direta";
                    } else { throw new Error(`Modo desconhecido: ${mode}`); }

                    finderResultsLogDiv.innerHTML = combinationResult.log;

                    if (combinationResult.status === "Error" || !combinationResult.combination) {
                        foundCombinationDisplayDiv.innerHTML = `<span class="error">Geração da Combinação falhou (Modo: ${mode}). Verifique o log acima.</span>`;
                        statusAreaDiv.innerHTML = "Alocador Abortado (Falha na Combinação).";
                        return;
                    } else if (combinationResult.combination.length === 0) {
                         foundCombinationDisplayDiv.innerHTML = `<span class="warning">Geração da Combinação resultou em lista vazia []. Prosseguindo para Alocador sem Planos.</span>`;
                         statusAreaDiv.innerHTML = "Combinação vazia. Executando Alocador...";
                         globalUserLpdCombinationWithDuplicates = [];
                         globalUniqueLpdValues = [];
                         globalLpdInstanceCounts = {};
                         globalInitialTotalSlotsPerValue = {};
                    } else {
                        globalUserLpdCombinationWithDuplicates = combinationResult.combination;
                        globalUniqueLpdValues = [...new Set(globalUserLpdCombinationWithDuplicates)].sort((a, b) => a - b);
                        globalLpdInstanceCounts = {}; globalUserLpdCombinationWithDuplicates.forEach(lpd => { globalLpdInstanceCounts[lpd] = (globalLpdInstanceCounts[lpd] || 0) + 1; });
                        globalInitialTotalSlotsPerValue = {}; globalUniqueLpdValues.forEach(lpd => { const instances = globalLpdInstanceCounts[lpd] || 0; globalInitialTotalSlotsPerValue[lpd] = globalMaxSlotsPerInstance !== Infinity ? (instances * globalMaxSlotsPerInstance) : Infinity; });

                        console.log("Resultado Combinação (Valores):", globalUserLpdCombinationWithDuplicates);
                        console.log("Resultado Combinação (Únicos):", globalUniqueLpdValues);
                        console.log("Resultado Combinação (Contagens):", globalLpdInstanceCounts);
                        console.log("Resultado Combinação (Imagens Iniciais):", globalInitialTotalSlotsPerValue);

                        foundCombinationDisplayDiv.innerHTML = `Combinação Gerada (<span class="info">${combinationMethodDescription}</span>): <b>[${globalUserLpdCombinationWithDuplicates.join(', ')}]</b> (Tamanho: ${globalUserLpdCombinationWithDuplicates.length})`;
                        statusAreaDiv.innerHTML = `Combinação completa (Modo: ${mode}). Executando Alocador...`;
                    }

                    // Run Allocator Phase
                    runAllocatorPhase();

                } catch (combinationError) {
                    console.error(`Erro durante Geração da Combinação (Modo: ${mode}):`, combinationError);
                    finderResultsLogDiv.innerHTML += `\n<span class="error">Ocorreu um erro inesperado durante a geração da combinação: ${combinationError.message}</span>`;
                    foundCombinationDisplayDiv.innerHTML = `<span class="error">Geração da combinação falhou (Modo: ${mode}).</span>`;
                    statusAreaDiv.innerHTML = "Alocador Abortado (Falha na Combinação).";
                }
            }, 10); // End setTimeout for Combination

        } // Fim initiateProcess

        // --- toggleErrorStrategies function ---
        function toggleErrorStrategies() {
             const container = document.getElementById('comparisonTableContainer');
             const button = document.getElementById('toggleErrorsBtn');
             if (container && button && globalStrategyResults) {
                 // Count errors accurately from the final global results - DO THIS ONCE
                 const errorRowCount = globalStrategyResults.filter(r => r.hasAllocationError).length;
                 if (errorRowCount === 0) return; // No need to toggle if count is 0

                 const hiding = container.classList.toggle('hide-errors');

                 // Set text based on the NEW state (hiding or showing)
                 if (hiding) {
                     button.textContent = `Mostrar ${errorRowCount} Estrat. c/ Erro...`;
                 } else {
                     button.textContent = `Ocultar ${errorRowCount} Estrat. c/ Erro...`;
                 }
             } else {
                 console.warn("Could not toggle errors: container, button, or global results missing.");
             }
         }

        // --- toggleDuplicateStrategies function ---
        function toggleDuplicateStrategies() {
            const container = document.getElementById('comparisonTableContainer');
            const button = document.getElementById('toggleDuplicatesBtn');
            if (container && button && globalStrategyResults) {
                // Count duplicates accurately from the final global results - DO THIS ONCE
                const duplicateRowCount = globalStrategyResults.filter(r => r.isDuplicateResult).length;
                if (duplicateRowCount === 0) return; // No need to toggle if count is 0

                const hiding = container.classList.toggle('hide-duplicates');

                // Set text based on the NEW state (hiding or showing)
                 if (hiding) {
                    button.textContent = `Mostrar ${duplicateRowCount} Estrat. c/ Resultados Idênticos...`;
                 } else {
                    button.textContent = `Ocultar ${duplicateRowCount} Estrat. c/ Resultados Idênticos...`;
                 }
            } else {
                 console.warn("Could not toggle duplicates: container, button, or global results missing.");
            }
        }

        // --- Function to highlight the selected strategy in the comparison table ---
        function updateComparisonTableHighlight(selectedStrategyName) {
            const table = document.getElementById('comparisonTable');
            if (!table) { console.warn("updateComparisonTableHighlight: comparisonTable not found."); return; }
            const tbody = table.getElementsByTagName('tbody')[0];
            if (!tbody) { console.warn("updateComparisonTableHighlight: tbody not found in comparisonTable."); return; }
            const rows = tbody.getElementsByTagName('tr');
            console.log(`[updateComparisonTableHighlight] Highlighting: ${selectedStrategyName}. Found ${rows.length} rows.`); // Add log

            for (let row of rows) {
                row.classList.remove('best-effort'); // Remove highlight from all rows first
                const firstCell = row.cells[0];
                if (firstCell && firstCell.classList.contains('strategy-name')) { // Check if it's the strategy name cell
                    // Remove existing (Selecionado) text more reliably
                    let currentStrategyName = firstCell.textContent.replace(/\s*\(Selecionado\)$/, '').trim();

                    // Add highlight if names match
                    if (currentStrategyName === selectedStrategyName) {
                        console.log(`[updateComparisonTableHighlight] Applying highlight to row for: ${currentStrategyName}`);
                        row.classList.add('best-effort');
                        firstCell.textContent = `${currentStrategyName} (Selecionado)`; // Add indicator text
                    } else {
                        // Ensure indicator text is removed if name doesn't match (handles re-clicks)
                        firstCell.textContent = currentStrategyName;
                    }
                } else if (firstCell) {
                    // This might happen if the table structure is unexpected
                    // console.warn("[updateComparisonTableHighlight] Row's first cell doesn't have 'strategy-name' class:", row);
                } else {
                     // Should not happen with a valid table
                    console.warn("[updateComparisonTableHighlight] Row doesn't have a first cell:", row);
                }
            }
            console.log(`[updateComparisonTableHighlight] Finished highlighting for: ${selectedStrategyName}`);
        }


        // --- FUNÇÕES DE EXIBIÇÃO DO ALOCADOR ---
        function displayStrategyDetails(encodedStrategyName) { // exibirDetalhesEstrategia
             const strategyName = decodeURIComponent(encodedStrategyName);
             globalCurrentlyDisplayedStrategyName = strategyName; // Store the name
             console.log(`[displayStrategyDetails] START for: ${strategyName}`);

             // Get references to DOM elements
             const statusAreaDiv = document.getElementById('statusArea');
             const detailsTitle = document.getElementById('detailsTitle');
             const allocationResultsDiv = document.getElementById('allocationResults');
             const adjustmentLogDiv = document.getElementById('adjustmentLog');
             const variationLogDiv = document.getElementById('variationLog');
             const cumulativeUsageDiv = document.getElementById('cumulativeUsage');
             const lpdBreakdownDiv = document.getElementById('lpdBreakdown');
             const finalSummaryTableDiv = document.getElementById('finalSummaryTableDiv');

             // Find the result data for the selected strategy FROM GLOBAL RESULTS
             // Ensure globalStrategyResults is available before filtering
             const selectedResult = globalStrategyResults && globalStrategyResults.find(res => res.strategyName === strategyName);
             console.log(`[displayStrategyDetails] Found selectedResult:`, selectedResult ? 'Yes' : 'No');


             // Reset UI elements
             allocationResultsDiv.innerHTML = 'Carregando...';
             adjustmentLogDiv.innerHTML = '';
             variationLogDiv.innerHTML = '';
             cumulativeUsageDiv.innerHTML = '';
             lpdBreakdownDiv.innerHTML = '';
             finalSummaryTableDiv.innerHTML = '';

             // Validate if result data exists
             if (!selectedResult) {
                 if(statusAreaDiv) statusAreaDiv.innerHTML = `<span class="error">Erro: Não foi possível encontrar resultados para "${strategyName}".</span>`;
                 if(detailsTitle) detailsTitle.innerHTML = 'Resultados Detalhados';
                 if(allocationResultsDiv) allocationResultsDiv.innerHTML = ''; // Clear loading message
                 globalCurrentlyDisplayedStrategyName = null; // Reset on error
                 console.error(`[displayStrategyDetails] No selectedResult found for ${strategyName}. Aborting.`);
                 return;
             }
             // Check if the core allocation data exists (resultData might be null if allocation failed badly)
             if (!selectedResult.resultData || !selectedResult.resultData.itemAllocations) {
                 if(statusAreaDiv) statusAreaDiv.innerHTML = `<span class="error">Erro: Dados de alocação incompletos ou ausentes para "${strategyName}".</span>`;
                 if(detailsTitle) detailsTitle.innerHTML = `Resultados Detalhados (Erro de Dados - ${strategyName})`;
                 if(allocationResultsDiv) allocationResultsDiv.innerHTML = '<span class="error">Dados de alocação principal ausentes. A estratégia pode ter falhado.</span>';
                 globalCurrentlyDisplayedStrategyName = null; // Reset on error
                 // Attempt to display logs even if allocation failed
                 if(adjustmentLogDiv) adjustmentLogDiv.innerHTML = (selectedResult.resultData && selectedResult.resultData.logs && selectedResult.resultData.logs.adjustment) || "Nenhum registro de ajuste.";
                 if(variationLogDiv) variationLogDiv.innerHTML = (selectedResult.resultData && selectedResult.resultData.logs && selectedResult.resultData.logs.variation) || "Nenhum registro de variação.";
                 console.error(`[displayStrategyDetails] Incomplete resultData for ${strategyName}. Aborting detailed display.`);
                 // Still try to update highlight in case comparison table rendered
                 try { updateComparisonTableHighlight(strategyName); } catch(e) { console.error("Error calling updateHighlight on incomplete data:", e); }
                 return; // Stop further processing for this strategy display
             }

             console.log(`[displayStrategyDetails] Starting detailed display for ${strategyName}.`);
             // Start displaying results
             try {
                 if(statusAreaDiv) statusAreaDiv.innerHTML = `Exibindo detalhes para estratégia: <span class="info">${strategyName}</span>`; // Update status only if showing details
                 if(detailsTitle) detailsTitle.innerHTML = `Resultados Detalhados da Alocação (Estratégia: ${strategyName})`;

                 // Destructure necessary data from the selected result
                 const finalItems = selectedResult.itemsUsed;
                 const finalAllocations = selectedResult.resultData.itemAllocations;
                 const finalCumulativeUsage = selectedResult.resultData.cumulativeUsage || {}; // Default to empty obj
                 const finalRemainingSlots = selectedResult.resultData.remainingSlots || {}; // Default to empty obj
                 const finalLogs = selectedResult.resultData.logs || { adjustment: '', variation: ''}; // Default
                 const uniqueLpdValuesDisplay = globalUniqueLpdValues || []; // Use global
                 const maxSlotsDisplayLocal = globalMaxSlotsDisplay; // Use global
                 const originalItemsUnsorted = globalOriginalItems || []; // Use global
                 const initialTotalSlotsPerValueLocal = globalInitialTotalSlotsPerValue || {}; // Use global
                 const lpdInstanceCountsLocal = globalLpdInstanceCounts || {}; // Use global
                 const userLpdCombinationWithDuplicatesLocal = globalUserLpdCombinationWithDuplicates || []; // Use global
                 const maxSlotsNum = globalMaxSlotsPerInstance; // Use global
                 const maxSlotsIsFinite = globalMaxSlotsPerInstance !== Infinity; // Use global

                 // --- Retrieve PRE-GENERATED Assembly Data ---
                 const planAssemblyDataForExport = selectedResult.planAssemblyDataForExport;
                 console.log(`[displayStrategyDetails] Retrieved planAssemblyDataForExport (is null? ${planAssemblyDataForExport === null})`);
                 // --- End Retrieval ---


                 // Display Adjustment and Variation Logs
                 if(adjustmentLogDiv) adjustmentLogDiv.innerHTML = finalLogs.adjustment || "Nenhum registro de ajuste.";
                 if(variationLogDiv) variationLogDiv.innerHTML = finalLogs.variation || "Nenhum registro de variação.";

                 // --- 1. Generate HTML for Final Item Allocations (Log View) ---
                 let finalAllocationHTML = `--- Alocações Finais por Especificação (Estratégia: ${selectedResult.strategyName}) ---`;
                 if (finalItems && finalAllocations && finalItems.length === finalAllocations.length) {
                     finalItems.forEach((item, i) => {
                         finalAllocationHTML += `<div class="item-allocation">`;
                         finalAllocationHTML += `<b>${i + 1}. ${item ? item.details : 'Item Inválido'}</b> (Linha Orig: ${item ? item.originalIndex + 1 : 'N/A'}, Alvo: ${formatNumberPtBR(item ? item.amount : 0)})\n`;
                         const finalAlloc = finalAllocations[i];
                         if (!finalAlloc) { finalAllocationHTML += `<span class="error">Dados de aloc. ausentes para este item.</span>\n`; }
                         else if (finalAlloc.error) { finalAllocationHTML += `<span class="error">Erro Aloc: ${finalAlloc.error}</span>\n`; }
                         else if (finalAlloc.sum !== undefined) {
                             const itemAmount = item ? item.amount : 0; // Use 0 if item is missing
                             const finalPercDiff = itemAmount > 0 ? (finalAlloc.difference / itemAmount) : (finalAlloc.sum === 0 ? 0 : Infinity);
                             const absFinalPercDiff = Math.abs(finalPercDiff);
                             let diffClass = finalAlloc.difference === 0 ? 'zero-diff' : (finalAlloc.difference > 0 ? 'positive-diff' : 'negative-diff');
                             let diffSign = finalAlloc.difference > 0 ? '+' : '';
                             finalAllocationHTML += `<span class="highlight">Soma: ${formatNumberPtBR(finalAlloc.sum)}</span> (Dif: <span class="${diffClass}">${diffSign}${formatNumberPtBR(finalAlloc.difference)}</span>`;
                             if (itemAmount > 0 && isFinite(finalPercDiff)) { // Check if percentage is finite
                                 finalAllocationHTML += ` / ${(finalPercDiff * 100).toFixed(1)}%`;
                                 if (absFinalPercDiff > REPROCESS_VARIATION_LIMIT) { finalAllocationHTML += ` <span class="violation">>±${(REPROCESS_VARIATION_LIMIT * 100).toFixed(0)}%</span>`; }
                                 else if (absFinalPercDiff > VARIATION_LIMIT_PASS_3) { finalAllocationHTML += ` <span class="warning">>±${(VARIATION_LIMIT_PASS_3 * 100).toFixed(0)}%</span>`; }
                             } else if (itemAmount <= 0 && finalAlloc.sum !== 0) { finalAllocationHTML += ` / <span class="violation">N/A (Alvo 0)</span>`; }
                             else if (itemAmount > 0 && !isFinite(finalPercDiff)) { finalAllocationHTML += ` / <span class="violation">Inf%</span>`; }
                             finalAllocationHTML += `)\n`;
                             if (finalAlloc.combination && finalAlloc.combination.length > 0) {
                                 finalAllocationHTML += `   Combo (${finalAlloc.combination.length}): [${finalAlloc.combination.map(formatNumberPtBR).join(', ')}]`;
                                 if (finalAlloc.finalUsageCounts && Object.keys(finalAlloc.finalUsageCounts).length > 0) { finalAllocationHTML += `\n   Uso: { ${Object.entries(finalAlloc.finalUsageCounts).map(([lpd, count]) => `"${formatNumberPtBR(lpd)}": ${formatNumberPtBR(count)}`).join(', ')} }`; }
                                 else { finalAllocationHTML += `\n   Uso: {}`; }
                             } else { finalAllocationHTML += `   (Nenhum Plano alocado)`; }
                         } else { finalAllocationHTML += "<span class='error'>Estrutura Aloc Inválida</span>"; }
                         finalAllocationHTML += `</div>`;
                     });
                 } else { finalAllocationHTML += '<span class="error">Incompatibilidade Especificação/Aloc.</span>'; }
                 if(allocationResultsDiv) allocationResultsDiv.innerHTML = finalAllocationHTML;

                 // --- 2. Generate HTML for Cumulative Usage (Log View) ---
                  let usageSummaryHTML = `<div class="usage-summary">--- Uso Acumulado de Planos (Estrat: ${selectedResult.strategyName}, Imagens Máx/Inst: ${maxSlotsDisplayLocal}) ---<ul>`;
                  if (uniqueLpdValuesDisplay && uniqueLpdValuesDisplay.length > 0) {
                      uniqueLpdValuesDisplay.forEach(lpd => {
                          const initialTotal = initialTotalSlotsPerValueLocal[lpd] || 0;
                          const usedTotal = finalCumulativeUsage[lpd] || 0;
                          let remainingTotal = Infinity; // Default for Infinity case
                          if(maxSlotsIsFinite) { remainingTotal = finalRemainingSlots.hasOwnProperty(lpd) ? finalRemainingSlots[lpd] : (initialTotal - usedTotal); }
                          const numInstances = lpdInstanceCountsLocal[lpd] || 0;
                          usageSummaryHTML += `<li>Plano <b>${formatNumberPtBR(lpd)}</b> (${formatNumberPtBR(numInstances)} inst): Usado <b>${formatNumberPtBR(usedTotal)}</b>`;
                          if (maxSlotsIsFinite) {
                              usageSummaryHTML += ` (Inicial: ${formatNumberPtBR(initialTotal)}, Rem: ${formatNumberPtBR(remainingTotal)})`;
                              if (remainingTotal < 0) { usageSummaryHTML += ` <span class="error">(Erro de Imagem!)</span>`; }
                              else if (usedTotal + remainingTotal !== initialTotal && initialTotal !== Infinity) { console.warn(`Incompatibilidade Imagem Plano ${lpd}: Usado ${usedTotal}, Rem ${remainingTotal}, Inicial ${initialTotal}. Estrat: ${strategyName}`); usageSummaryHTML += ` <span class="warning">(Incompatibilidade Contagem?)</span>`; }
                          }
                          usageSummaryHTML += `</li>`;
                      });
                  } else { usageSummaryHTML += "<li>Nenhum Plano para rastrear.</li>"; }
                  usageSummaryHTML += "</ul></div>";
                 if(cumulativeUsageDiv) cumulativeUsageDiv.innerHTML = usageSummaryHTML;


                 // --- 3. Generate HTML for Plan Assembly (Montagem dos Planos) USING PRE-GENERATED DATA ---
                 let lpdBreakdownHTML = `<div class="lpd-section-title" style="text-align: center; font-size: 1.1em; margin-bottom: 1rem;">--- Montagem dos Planos (Estratégia: ${selectedResult.strategyName}) ---</div>`;
                 let totalGlobalSheets = 0; // <<< NOVO: Inicializa total de folhas
                 if (planAssemblyDataForExport && planAssemblyDataForExport.length > 0) {
                     let overallPlanIndex = 0;
                     planAssemblyDataForExport.forEach(instance => {
                         if (instance.items && instance.items.length > 0 || instance.totalUsed > 0) { // Check items array exists too
                             overallPlanIndex++;
                             lpdBreakdownHTML += `<div class="plan-container">`;
                             lpdBreakdownHTML += `<h1>Plano ${overallPlanIndex} - ${formatNumberPtBR(instance.planValue)} Folhas</h1>`;
                             lpdBreakdownHTML += `<table><thead><tr><th>Item</th><th>Img</th><th>Qtd</th></tr></thead><tbody>`;
                             let totalInstanceQtd = 0;
                             if (instance.items && instance.items.length > 0) {
                                 instance.items.forEach(item => {
                                     const itemQtd = (item.count || 0) * (instance.planValue || 0); // Safety check for count/value
                                     totalInstanceQtd += itemQtd;
                                     lpdBreakdownHTML += `<tr><td>${item.details || 'N/A'}</td><td>${formatNumberPtBR(item.count || 0)}</td><td>${formatNumberPtBR(itemQtd)}</td></tr>`;
                                 });
                             } else { lpdBreakdownHTML += `<tr><td colspan="3">(Nenhum item para este plano)</td></tr>`; }
                             lpdBreakdownHTML += `<tr class="total-row"><td><strong>TOTAL</strong></td><td><strong>${formatNumberPtBR(instance.totalUsed || 0)}</strong></td><td><strong>${formatNumberPtBR(totalInstanceQtd)}</strong></td></tr>`;
                             lpdBreakdownHTML += `</tbody></table></div>`;

                             // <<< NOVO: Acumula total de folhas dos planos exibidos
                             if (typeof instance.planValue === 'number' && instance.planValue > 0) {
                                 totalGlobalSheets += instance.planValue;
                             }
                         }
                     });
                     if (overallPlanIndex === 0) { lpdBreakdownHTML += "<p style='text-align: center; color: var(--text-muted);'>Nenhuma instância de plano com itens alocados para exibir.</p>"; }

                     // <<< NOVO: Adiciona o HTML do total geral DEPOIS do loop
                     lpdBreakdownHTML += `<div class="total-sheets-summary">
                                             Total Geral (Todos os Planos): ${formatNumberPtBR(totalGlobalSheets)} Folhas
                                          </div>`;

                 } else {
                      lpdBreakdownHTML += "<p style='text-align: center; color: var(--text-muted);'>Dados da montagem dos planos não disponíveis ou vazios.</p>";
                      if(selectedResult.hasAllocationError) { lpdBreakdownHTML += `<p style='text-align: center; color: var(--warning);'>(Nota: A alocação para esta estratégia encontrou erros.)</p>`; }
                 }
                 if(lpdBreakdownDiv) lpdBreakdownDiv.innerHTML = lpdBreakdownHTML;


                 // --- 4. Generate HTML for Final Summary Table (Tabela Comparativa) ---
                 console.log(`[displayStrategyDetails] Generating summary table for ${strategyName}.`);
                 let summaryTableHTML = `<div class="lpd-section-title">--- Tabela Comparativa (Estrat: ${selectedResult.strategyName}) ---</div><table id="finalSummaryTable"><thead><tr><th>Especificação</th><th>Quantidade</th><th>Empenho</th><th>Dif</th><th>Var (%)</th></tr></thead><tbody>`;
                 const allocationMap = new Map();
                 finalItems.forEach((item, i) => { if(item) allocationMap.set(item.originalIndex, { itemData: item, allocationData: finalAllocations[i] }); });

                 let totalOriginal = 0; let totalEmpenhado = 0;

                 if (originalItemsUnsorted && originalItemsUnsorted.length > 0) {
                     originalItemsUnsorted.forEach(originalItem => {
                         if (!originalItem) { console.warn("Skipping invalid original item in summary table gen."); return; } // Skip if original item invalid
                         totalOriginal += originalItem.amount;
                         const resultEntry = allocationMap.get(originalItem.originalIndex);
                         let Especificação = originalItem.details;
                         let quantidadeNum = originalItem.amount;
                         let quantidadeFmt = formatNumberPtBR(quantidadeNum);
                         let empenhoHtml = '<span class="warning">N/A</span>'; let difHtml = '<span class="warning">N/A</span>'; let varHtml = '<span class="warning">N/A</span>';

                         if (resultEntry && resultEntry.allocationData) {
                             const finalAlloc = resultEntry.allocationData;
                             if (!finalAlloc.error && finalAlloc.sum !== undefined) {
                                 const empenhoNum = finalAlloc.sum; empenhoHtml = formatNumberPtBR(empenhoNum); totalEmpenhado += empenhoNum;
                                 const difNum = finalAlloc.difference; let difClass = difNum === 0 ? 'zero-diff' : (difNum > 0 ? 'positive-diff' : 'negative-diff'); let difSign = difNum > 0 ? '+' : '';
                                 difHtml = `<span class="${difClass}">${difSign}${formatNumberPtBR(difNum)}</span>`;
                                 if (quantidadeNum > 0) { const percentage = (difNum / quantidadeNum); if (isFinite(percentage)){ const percentageFmt = (percentage * 100).toFixed(1) + '%'; varHtml = `<span class="${difClass}">${percentageFmt}</span>`; if (Math.abs(percentage) > REPROCESS_VARIATION_LIMIT) { varHtml = `<span class="violation">${percentageFmt}</span>`; } else if (Math.abs(percentage) > VARIATION_LIMIT_PASS_3) { varHtml = `<span class="warning">${percentageFmt}</span>`; } } else { varHtml = `<span class="violation">Inf%</span>`; } }
                                 else if (empenhoNum !== 0) { varHtml = `<span class="violation">N/A</span>`; }
                                 else { varHtml = '<span class="zero-diff">0.0%</span>'; }
                             } else if (finalAlloc.error) { empenhoHtml = `<span class="error">Erro</span>`; let shortError = finalAlloc.error.length > 50 ? finalAlloc.error.substring(0, 47) + '...' : finalAlloc.error; difHtml = `<span class="error" title="${finalAlloc.error}">${shortError}</span>`; varHtml = `<span class="error">Erro</span>`; }
                         }
                         summaryTableHTML += `<tr><td>${Especificação}</td><td>${quantidadeFmt}</td><td>${empenhoHtml}</td><td>${difHtml}</td><td>${varHtml}</td></tr>`;
                     });
                 } else {
                      summaryTableHTML += '<tr><td colspan="5">Nenhum item original encontrado para exibir.</td></tr>';
                 }
                 summaryTableHTML += `</tbody>`;

                 // Add Total Row
                 const totalDiferenca = totalEmpenhado - totalOriginal;
                 let totalDifClass = totalDiferenca === 0 ? 'zero-diff' : (totalDiferenca > 0 ? 'positive-diff' : 'negative-diff');
                 let totalDifSign = totalDiferenca > 0 ? '+' : '';
                 let totalVarHtml = '';
                 if (totalOriginal > 0) { const totalPercentage = (totalDiferenca / totalOriginal) * 100; if (isFinite(totalPercentage)) { totalVarHtml = `<span class="${totalDifClass}">${totalPercentage.toFixed(1)}%</span>`; } else { totalVarHtml = `<span class="violation">Inf%</span>`; } }
                 else if (totalEmpenhado === 0) { totalVarHtml = `<span class="zero-diff">0.0%</span>`; }
                 else { totalVarHtml = `<span class="positive-diff">N/A</span>`; }

                 summaryTableHTML += `<tfoot><tr>
                                        <th>TOTAL</th>
                                        <td>${formatNumberPtBR(totalOriginal)}</td>
                                        <td>${formatNumberPtBR(totalEmpenhado)}</td>
                                        <td><span class="${totalDifClass}">${totalDifSign}${formatNumberPtBR(totalDiferenca)}</span></td>
                                        <td>${totalVarHtml}</td>
                                     </tr></tfoot>`;
                 summaryTableHTML += `</table>`;
                 if(finalSummaryTableDiv) finalSummaryTableDiv.innerHTML = summaryTableHTML;
                 console.log(`[displayStrategyDetails] Finished generating summary table for ${strategyName}.`);

                 // --- 5. Update Strategy Comparison Highlight ---
                 console.log(`[displayStrategyDetails] Calling updateComparisonTableHighlight for ${strategyName}.`);
                 updateComparisonTableHighlight(strategyName); // Ensure this is called *after* table is in DOM
                 console.log(`[displayStrategyDetails] Finished updateComparisonTableHighlight for ${strategyName}.`);


             // --- Error Handling for Display ---
             } catch (e) {
                 console.error(`[displayStrategyDetails] CRITICAL Error while displaying details for ${strategyName}:`, e);
                 if(statusAreaDiv) statusAreaDiv.innerHTML = `<span class="error">Erro CRÍTICO ao exibir detalhes para "${strategyName}". Verifique o console. Err: ${e.message}</span>`;
                 // Clear potentially broken output areas
                 if(allocationResultsDiv) allocationResultsDiv.innerHTML = '<span class="error">Erro de Exibição</span>';
                 if(adjustmentLogDiv) adjustmentLogDiv.innerHTML = ''; if(variationLogDiv) variationLogDiv.innerHTML = '';
                 if(cumulativeUsageDiv) cumulativeUsageDiv.innerHTML = ''; if(lpdBreakdownDiv) lpdBreakdownDiv.innerHTML = ''; if(finalSummaryTableDiv) finalSummaryTableDiv.innerHTML = '';
                 if(detailsTitle) detailsTitle.innerHTML = `Resultados Detalhados (Erro)`;
                 globalCurrentlyDisplayedStrategyName = null; // Reset on error
             }
             console.log(`[displayStrategyDetails] END for: ${strategyName}`);
        } // End displayStrategyDetails

    </script>

</body>
</html>