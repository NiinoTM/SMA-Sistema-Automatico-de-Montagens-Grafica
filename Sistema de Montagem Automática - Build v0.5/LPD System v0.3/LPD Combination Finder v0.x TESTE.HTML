<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <!-- CHANGE: Updated Title -->
    <title>LPD Combination Finder v0.3.7 (Proportional + Min LPD Rule)</title>
    <style>
        /* Basic styling (same as v0.3.6) */
        body { font-family: sans-serif; padding: 20px; }
        label { display: block; margin-top: 10px; margin-bottom: 5px; font-weight: bold; }
        textarea { width: 90%; min-height: 150px; margin-bottom: 10px; font-family: monospace; }
        input[type="number"] { padding: 8px; margin-bottom: 10px; width: 120px; }
        button { padding: 10px 15px; cursor: pointer; background-color: #007bff; color: white; border: none; border-radius: 4px; margin-top: 10px; }
        button:hover { background-color: #0056b3; }
        #results { margin-top: 20px; padding: 15px; border: 1px solid #ccc; background-color: #f9f9f9; white-space: pre-wrap; font-family: monospace; }
        .error { color: red; font-weight: bold; }
        .info { color: blue; }
        .warning { color: darkorange; font-weight: bold; } /* Added for substitution message */
        .fallback-prop { color: purple; font-weight: bold; }
        .input-group { margin-bottom: 15px; }
        .highlight { background-color: yellow; font-weight: bold; }
        .proportional-section { border-top: 2px solid purple; padding-top: 10px; margin-top: 15px; }
    </style>
</head>
<body>

    <!-- CHANGE: Updated Header/Description -->
    <h1>LPD Combination Finder (Proportional, Min LPD Rule, Round to 50, Allow Combo Size 1, >=2000)</h1>
    <p>Calculates LPD combination using the Proportional method. Selects top LPDs by frequency/value, but ensures at least one LPD within +/- 500 of the minimum valid LPD is included if possible (by substitution if necessary). Rounds result to nearest 50.</p>

    <!-- Input fields (remain the same) -->
    <div class="input-group">
        <label for="tableData">Table Data (Details + Amount, one per line):</label>
        <textarea id="tableData" placeholder="Example:
Item A 10000
Item B 7500
Item C 20000
..."></textarea>
    </div>
    <div class="input-group">
        <label for="maxSlots">Max Slots per LPD Instance (Cumulative):</label>
        <input type="number" id="maxSlots" min="1" placeholder="e.g., 8" required>
    </div>
    <div class="input-group">
        <label for="combinationSize">Number of Distinct LPDs in Combination:</label>
        <input type="number" id="combinationSize" value="1" min="1">
    </div>
    <button onclick="findProportionalCombination()">Find Proportional Combination</button>

    <!-- Output area -->
    <div id="results">Proportional LPD Combination results will appear here...</div>

    <script>
        // --- CONFIGURATION RULES ---
        const MIN_LPD_VALUE = 2000;
        const PROPORTIONAL_ROUNDING_STEP = 50;
        const OBLIGATORY_RANGE = 500; // Rule for proximity to minimum LPD
        // --- ---

        // --- Helper Functions ---
        function roundToNearest(value, multiple) {
             if (multiple <= 0) return Math.round(value); return Math.round(value / multiple) * multiple;
        }

        // --- Main Processing Function ---
        function findProportionalCombination() {
            // 1. Read and Validate Inputs
            const tableDataInput = document.getElementById('tableData').value.trim();
            const maxSlotsInput = document.getElementById('maxSlots').value.trim();
            const combinationSizeInput = document.getElementById('combinationSize').value;
            const resultsDiv = document.getElementById('results');

            resultsDiv.innerHTML = `Processing Proportional LPD Combination (>= ${MIN_LPD_VALUE}, Min LPD Rule +/-${OBLIGATORY_RANGE}, Round to ${PROPORTIONAL_ROUNDING_STEP})...`;

            // Input validation (same as v0.3.6)
            if (!tableDataInput) { resultsDiv.innerHTML = '<span class="error">Error: Table data cannot be empty.</span>'; return; }
            if (!maxSlotsInput) { resultsDiv.innerHTML = '<span class="error">Error: Max Slots value is required.</span>'; return; }


            // 2. Parse Table Data
            // (Parsing logic same as v0.3.6)
            const lines = tableDataInput.split('\n');
            const lpdFrequencies = {};
            const validRawAmounts = [];
            let parseErrors = [];
            let sumAmounts = 0;
            const allValidLpds = []; // Keep track of all valid LPDs for min calculation

            lines.forEach((line, index) => {
                line = line.trim(); if (!line) return;
                let parts = line.split('\t'); if (parts.length < 2) parts = line.split(/\s+/);
                if (parts.length < 2) { parseErrors.push(`L${index + 1}: Cannot split line: "${line}"`); return; }
                const amountStr = parts[parts.length - 1];
                const amount = parseInt(amountStr);
                if (isNaN(amount)) { parseErrors.push(`L${index + 1}: Amount NaN: "${amountStr}"`); return; }
                if (amount <= 0) { parseErrors.push(`L${index + 1}: Amount <= 0: "${amount}"`); return; }

                validRawAmounts.push(amount);
                sumAmounts += amount;

                const lpd = Math.round(amount / 2);
                if (lpd >= MIN_LPD_VALUE) {
                    lpdFrequencies[lpd] = (lpdFrequencies[lpd] || 0) + 1;
                    allValidLpds.push(lpd); // Add to list for finding minimum
                }
            });
            // Input data validation (same as v0.3.6)
             if (parseErrors.length > 0) { resultsDiv.innerHTML = `<span class="error">Input Data Parse Errors:</span>\n${parseErrors.join('\n')}`; return; }
             if (validRawAmounts.length === 0) { resultsDiv.innerHTML = `<span class="error">Error: No valid amounts found in the table data.</span>`; return; }
             if (sumAmounts === 0) { resultsDiv.innerHTML = `<span class="error">Error: Total sum of amounts is zero.</span>`; return; }


            // 3. Prepare Base Data and Validate Inputs
            const maxSlots = parseInt(maxSlotsInput);
             if (isNaN(maxSlots) || maxSlots <= 0) { resultsDiv.innerHTML = '<span class="error">Error: Invalid Max Slots value.</span>'; return; }
            const combinationSize = parseInt(combinationSizeInput);
             if (isNaN(combinationSize) || combinationSize < 1) {
                 resultsDiv.innerHTML = `<span class="error">Error: Invalid Number of Distinct LPDs (must be >= 1).</span>`;
                 return;
             }

            // Prepare uniqueValidLpdListWithFreq (sorted by freq/value desc)
            const uniqueValidLpdListWithFreq = Object.entries(lpdFrequencies)
                                      .map(([lpd, freq]) => ({ value: parseInt(lpd), frequency: freq }));
            uniqueValidLpdListWithFreq.sort((a, b) => {
                 if (b.frequency !== a.frequency) return b.frequency - a.frequency; return b.value - b.value; // Higher freq first, then higher value
             });

            // --- NEW: Find Minimum LPD and Near Minimum LPDs ---
            let minLpdValueFound = Infinity;
            if (allValidLpds.length > 0) {
                 minLpdValueFound = Math.min(...allValidLpds);
            }
            const nearMinLpds = minLpdValueFound === Infinity ? [] : uniqueValidLpdListWithFreq.filter(lpdObj => {
                 const diff = Math.abs(lpdObj.value - minLpdValueFound);
                 return diff <= OBLIGATORY_RANGE;
            }).sort((a, b) => b.frequency - a.frequency || b.value - a.value); // Sort near-min by freq/value desc too


            // 4. Log Initial Setup Info (Including Min LPD info)
            let initialLog = [];
            initialLog.push(`--- Input Summary & LPD Analysis ---`);
            initialLog.push(`Total Sum of Amounts: ${sumAmounts}`);
            initialLog.push(`Max Slots: ${maxSlots}`);
            initialLog.push(`Required Combination Size: ${combinationSize}`);
            initialLog.push(`Unique Valid LPDs (>=${MIN_LPD_VALUE}) Found: ${uniqueValidLpdListWithFreq.length} values.`);
            if (uniqueValidLpdListWithFreq.length > 0) {
                let frequencyLog = `Unique Valid LPDs Sorted by Freq/Value: ${uniqueValidLpdListWithFreq.map(l => `${l.value}(${l.frequency})`).join(', ')}`;
                initialLog.push(frequencyLog);
            }
             // Add Min LPD info logging
            initialLog.push(`Minimum Valid LPD Value Found: ${minLpdValueFound === Infinity ? 'None' : minLpdValueFound}`);
            initialLog.push(`Found ${nearMinLpds.length} candidate LPD(s) within +/- ${OBLIGATORY_RANGE} of Min LPD: [${nearMinLpds.map(c=>c.value + '(' + c.frequency + ')').join(', ')}]`);

            resultsDiv.innerHTML = initialLog.join('\n'); // Display initial setup log

            // --- Check if enough unique LPDs exist BEFORE proceeding ---
            if (uniqueValidLpdListWithFreq.length < combinationSize) {
                 resultsDiv.innerHTML += `\n\n<span class="error">Error: Not enough unique valid LPDs (${uniqueValidLpdListWithFreq.length}) available for the requested combination size of ${combinationSize}. Cannot proceed.</span>`;
                 return;
            }

            // 5. --- Determine LPDs for Proportional Calculation (Apply Min LPD Rule) ---
            resultsDiv.innerHTML += `\n\n<hr>\n`
                                + `<span class="fallback-prop">Determining LPDs for Proportional Calculation...</span>`;

            let selectionLog = []; // Log for this step
            let finalSelectedLpdsForProportion = [];

            // Handle combinationSize = 1 separately (no selection logic needed beyond average)
            if (combinationSize === 1) {
                selectionLog.push(`Combination size is 1. Min LPD rule does not apply to selection. Using Average Value Per Slot directly.`);
                 // For consistency, we can still note the top LPD if it exists
                if (uniqueValidLpdListWithFreq.length > 0) {
                    finalSelectedLpdsForProportion = [uniqueValidLpdListWithFreq[0]]; // Technically not used for calc, but can log
                    selectionLog.push(`(Top LPD by frequency/value: ${finalSelectedLpdsForProportion[0].value})`);
                } else {
                    selectionLog.push(`(No unique LPDs found to list as 'top')`);
                }
            } else { // combinationSize > 1
                // Step 5.1: Select Initial Top LPDs
                const initialTopLpds = uniqueValidLpdListWithFreq.slice(0, combinationSize);
                selectionLog.push(`Initial Top ${combinationSize} LPDs (by Freq/Value): [${initialTopLpds.map(l => `${l.value}(${l.frequency})`).join(', ')}]`);

                // Step 5.2: Check if Min LPD Rule is met
                const initialSelectionValues = initialTopLpds.map(lpd => lpd.value);
                const meetsMinLpdRule = nearMinLpds.length === 0 || // Rule met if no near-min LPDs exist
                                        initialSelectionValues.some(val => nearMinLpds.some(nearLpd => nearLpd.value === val));

                if (meetsMinLpdRule) {
                    selectionLog.push(`<span class="info">Min LPD Rule Met: Initial selection already includes an LPD within +/-${OBLIGATORY_RANGE} of ${minLpdValueFound} (or no such LPDs exist).</span>`);
                    finalSelectedLpdsForProportion = initialTopLpds;
                } else {
                    // Step 5.3: Adjust if Necessary
                    selectionLog.push(`<span class="warning">Min LPD Rule NOT Met: Initial selection lacks LPDs near minimum. Attempting substitution.</span>`);

                    // Find best near-min LPD (highest frequency) - it's the first in the sorted nearMinLpds list
                    const bestNearMinLpd = nearMinLpds[0];
                    selectionLog.push(`   - Best Candidate Near Min LPD (Highest Freq): ${bestNearMinLpd.value}(${bestNearMinLpd.frequency})`);

                    // Find LPD to replace in initialTopLpds (lowest frequency, then lowest value as tie-breaker)
                    // Since initialTopLpds is sorted freq desc / value desc, the *last* element usually has lowest freq.
                    // Let's find it explicitly to be safe.
                    let indexToReplace = -1;
                    let minFreq = Infinity;
                    let minValueAtMinFreq = Infinity;

                    for(let i = 0; i < initialTopLpds.length; i++) {
                        const lpd = initialTopLpds[i];
                        // We should not replace a near-min LPD if one accidentally got in despite the check failing (unlikely)
                         if (nearMinLpds.some(near => near.value === lpd.value)) continue;

                        if (lpd.frequency < minFreq) {
                            minFreq = lpd.frequency;
                            minValueAtMinFreq = lpd.value;
                            indexToReplace = i;
                        } else if (lpd.frequency === minFreq && lpd.value < minValueAtMinFreq) {
                             minValueAtMinFreq = lpd.value;
                             indexToReplace = i;
                        }
                    }

                     // Check if we actually found an LPD to replace (e.g., if all initial top LPDs were somehow near-min LPDs, though logic prevents this)
                    if (indexToReplace !== -1) {
                        const lpdToReplace = initialTopLpds[indexToReplace];
                        selectionLog.push(`   - LPD to Replace (Lowest Freq in Initial Top): ${lpdToReplace.value}(${lpdToReplace.frequency})`);

                         // Create the adjusted list
                        adjustedSelectedTopLpds = [...initialTopLpds]; // Create a copy
                        adjustedSelectedTopLpds[indexToReplace] = bestNearMinLpd;

                         // Re-sort the adjusted list by value (desc) for consistent output presentation, though not strictly needed for calc
                        adjustedSelectedTopLpds.sort((a, b) => b.value - a.value);

                        finalSelectedLpdsForProportion = adjustedSelectedTopLpds;
                        selectionLog.push(`<span class="info">   => Final LPDs for Calculation (After Substitution): [${finalSelectedLpdsForProportion.map(l => `${l.value}(${l.frequency})`).join(', ')}]</span>`);
                    } else {
                         selectionLog.push(`<span class="warning">   - Could not find a suitable LPD to replace in the initial top selection (this is unexpected). Using initial selection.</span>`);
                         finalSelectedLpdsForProportion = initialTopLpds; // Fallback to initial if replacement fails
                    }
                }
            }

            resultsDiv.innerHTML += '\n' + selectionLog.join('\n'); // Add selection log

            // 6. --- Perform Proportional Calculation ---
            resultsDiv.innerHTML += `\n\n<div class="proportional-section">--- Proportional Calculation (Round to ${PROPORTIONAL_ROUNDING_STEP}) ---`;
            let propLog = [];

            const averageValuePerSlot = sumAmounts / maxSlots;
            propLog.push(`Average Value Per Slot (Total Sum / Max Slots): ${averageValuePerSlot.toFixed(2)}`);

            let proportionalCombination = [];
            let sumOfProportionalCombination = 0;

            // Handle combinationSize = 1 separately for calculation
            if (combinationSize === 1) {
                const roundedAverage = roundToNearest(averageValuePerSlot, PROPORTIONAL_ROUNDING_STEP);
                propLog.push(`Combination size is 1. Using Average Value Per Slot rounded to nearest ${PROPORTIONAL_ROUNDING_STEP}.`);
                proportionalCombination = [roundedAverage];
                sumOfProportionalCombination = roundedAverage;
            } else { // combinationSize > 1
                 // Use the finalSelectedLpdsForProportion determined in step 5
                 const selectedLpdValues = finalSelectedLpdsForProportion.map(lpd => lpd.value);
                 // Note: We log the final selected LPDs including frequency from Step 5, but only use values here.
                 propLog.push(`Using LPD Values for Proportions: [${selectedLpdValues.join(', ')}] (Derived from selection process above)`);

                const totalLpdValueMass = selectedLpdValues.reduce((sum, val) => sum + val, 0);
                propLog.push(`Sum of Selected LPD Values (Proportional Mass): ${totalLpdValueMass}`);

                if (totalLpdValueMass <= 0) {
                    propLog.push(`<span class="error">Error: Sum of selected LPD values is ${totalLpdValueMass}. Cannot calculate proportions.</span>`);
                    resultsDiv.innerHTML += '\n' + propLog.join('\n') + `</div>`; // Display error and stop
                    return;
                }

                proportionalCombination = selectedLpdValues.map(lpdVal => {
                    const exactProportion = (totalLpdValueMass === 0) ? 0 : (averageValuePerSlot * lpdVal / totalLpdValueMass);
                    return roundToNearest(exactProportion, PROPORTIONAL_ROUNDING_STEP);
                });
                sumOfProportionalCombination = proportionalCombination.reduce((sum, val) => sum + val, 0);
            }

            // 7. Display Final Result
            propLog.push(`Calculated Proportional Combination (Rounded to ${PROPORTIONAL_ROUNDING_STEP}): [${proportionalCombination.join(', ')}]`);
            propLog.push(`Sum of Proportional Combination: ${sumOfProportionalCombination}`);
            if(combinationSize > 1) {
                propLog.push(`(Compare Sum to Target Average Value Per Slot: ${averageValuePerSlot.toFixed(2)})`);
            }

            resultsDiv.innerHTML += '\n' + propLog.join('\n') + `</div>`; // Close proportional-section div

            resultsDiv.innerHTML += `\n\n<span class="highlight fallback-prop">Proportional Result (${combinationSize} LPDs): [${proportionalCombination.join(', ')}]</span>`;
             if (combinationSize === 1) {
                 resultsDiv.innerHTML += `\n(Based on Average Value Per Slot, rounded to nearest ${PROPORTIONAL_ROUNDING_STEP})`;
             } else {
                 resultsDiv.innerHTML += `\n(Distributed average value proportionally based on selected LPDs [considering min LPD rule], rounded to nearest ${PROPORTIONAL_ROUNDING_STEP})`;
             }

        } // End findProportionalCombination
    </script>
</body>
</html>