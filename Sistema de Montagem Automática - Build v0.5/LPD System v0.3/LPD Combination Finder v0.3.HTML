<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>LPD Combination Finder v0.3.5 (Allow Combo Size 1)</title>
    <style>
        /* Basic styling (same as v0.3.4) */
        body { font-family: sans-serif; padding: 20px; }
        label { display: block; margin-top: 10px; margin-bottom: 5px; font-weight: bold; }
        textarea { width: 90%; min-height: 150px; margin-bottom: 10px; font-family: monospace; }
        input[type="number"] { padding: 8px; margin-bottom: 10px; width: 120px; }
        button { padding: 10px 15px; cursor: pointer; background-color: #007bff; color: white; border: none; border-radius: 4px; margin-top: 10px; }
        button:hover { background-color: #0056b3; }
        #results { margin-top: 20px; padding: 15px; border: 1px solid #ccc; background-color: #f9f9f9; white-space: pre-wrap; font-family: monospace; }
        .error { color: red; font-weight: bold; }
        .info { color: blue; }
        .success { color: green; font-weight: bold; }
        .fallback-gcd { color: darkorange; font-weight: bold; }
        .fallback-prop { color: purple; font-weight: bold; }
        .input-group { margin-bottom: 15px; }
        .highlight { background-color: yellow; font-weight: bold; }
        .target-section { border-top: 2px solid #aaa; padding-top: 10px; margin-top: 15px; }
        .candidate-section { border-left: 3px solid #ddd; padding-left: 10px; margin-top: 5px; margin-bottom: 5px; }
        .fallback-section { border-top: 2px solid darkorange; padding-top: 10px; margin-top: 15px; }
        .proportional-fallback-section { border-top: 2px solid purple; padding-top: 10px; margin-top: 15px; }
    </style>
</head>
<body>

    <h1>LPD Combination Finder (Target Range / Fallbacks, Round to 50, Allow Combo Size 1, >=2000)</h1>
    <p>Tries standard search. If no LPD near min LPD, uses GCD Fallback. If standard search fails, uses Proportional Fallback (rounded to nearest 50). Allows Combination Size of 1 (uses average value in fallback).</p>

    <!-- Input fields -->
    <div class="input-group">
        <label for="tableData">Table Data (Details + Amount, one per line):</label>
        <textarea id="tableData" placeholder="Example:
Item A 10000
Item B 7500
Item C 20000
..."></textarea>
    </div>
    <div class="input-group">
        <label for="maxSlots">Max Slots per LPD Instance (Cumulative):</label>
        <input type="number" id="maxSlots" min="1" placeholder="e.g., 8" required>
    </div>
    <div class="input-group">
        <label for="combinationSize">Number of Distinct LPDs in Combination (Standard/Proportional):</label>
        <input type="number" id="combinationSize" value="1" min="1"> <!-- Changed min to 1 -->
    </div>
    <button onclick="findBestCombination()">Find Best Combination</button>

    <!-- Output area -->
    <div id="results">LPD Combination results will appear here...</div>

    <script>
        // --- CONFIGURATION RULES ---
        const MIN_LPD_VALUE = 2000;
        const OBLIGATORY_RANGE = 500;
        const TARGET_RANGE_BELOW = 500;
        const TARGET_RANGE_ABOVE = 1000;
        const TARGET_STEP = 500;
        const PROPORTIONAL_ROUNDING_STEP = 50;
        // --- ---

        // --- Helper Functions ---
        function gcd(a, b) { /* ... (same as v0.3.4) ... */
            a = Math.abs(a); b = Math.abs(b); if (b === 0) return a; return gcd(b, a % b);
        }
        function arrayGcd(numbers) { /* ... (same as v0.3.4) ... */
             if (!numbers || numbers.length === 0) return 0; if (numbers.length === 1) return Math.abs(numbers[0]); let result = Math.abs(numbers[0]); for (let i = 1; i < numbers.length; i++) { result = gcd(result, numbers[i]); if (result === 1) return 1; } return result;
         }
        // Recursive finder - handles k=0 correctly (returns [] only if target is also 0)
        function findSumCombinationRecursive(lpdValueObjectsToSearch, target, k, startIndex, currentCombinationValues) {
            if (currentCombinationValues.length === k) {
                const currentSum = currentCombinationValues.reduce((sum, item) => sum + item, 0);
                // Check if sum matches target (esp. target=0 when k=0)
                if (Math.abs(currentSum - target) < 0.01) {
                    return [...currentCombinationValues]; // Found: returns [] if k=0, target=0
                }
                return null; // Sum doesn't match
            }
            // Pruning conditions (handle k=0 case where no more elements are needed)
            if (startIndex >= lpdValueObjectsToSearch.length ||
                currentCombinationValues.length > k ||
                (k > 0 && lpdValueObjectsToSearch.length - startIndex < k - currentCombinationValues.length)) { // Only check remaining needed if k > 0
                return null;
            }
            // No loop needed if k=0
            if (k === 0) return null; // Should have been caught by length check, but safe guard

            for (let i = startIndex; i < lpdValueObjectsToSearch.length; i++) {
                const currentLpdValue = lpdValueObjectsToSearch[i].value;
                if (!currentCombinationValues.includes(currentLpdValue)) {
                    currentCombinationValues.push(currentLpdValue);
                    const result = findSumCombinationRecursive(lpdValueObjectsToSearch, target, k, i + 1, currentCombinationValues);
                    if (result) { return result; }
                    currentCombinationValues.pop(); // Backtrack
                }
            }
            return null;
         }
        function getFrequencyScore(combination, lpdFrequencies) { /* ... (same as v0.3.4) ... */
             let score = 0; for (const lpdValue of combination) { score += (lpdFrequencies[lpdValue] || 0); } return score;
        }
        function roundToNearest(value, multiple) { /* ... (same as v0.3.4) ... */
            if (multiple <= 0) return Math.round(value); return Math.round(value / multiple) * multiple;
        }


        // --- Main Processing Function ---
        function findBestCombination() {
            // 1. Read and Validate Inputs
            const tableDataInput = document.getElementById('tableData').value.trim();
            const maxSlotsInput = document.getElementById('maxSlots').value.trim();
            const combinationSizeInput = document.getElementById('combinationSize').value;
            const resultsDiv = document.getElementById('results');

            resultsDiv.innerHTML = `Processing LPD Combination (>= ${MIN_LPD_VALUE}, Target Range / Fallbacks, Round to ${PROPORTIONAL_ROUNDING_STEP})...`;

            if (!tableDataInput) { resultsDiv.innerHTML = '<span class="error">Error: Table data cannot be empty.</span>'; return; }
            if (!maxSlotsInput) { resultsDiv.innerHTML = '<span class="error">Error: Max Slots value is required.</span>'; return; }

            // 2. Parse Table Data
            // ... (Parsing logic same as v0.3.4) ...
            const lines = tableDataInput.split('\n');
            const lpdFrequencies = {};
            const validRawAmounts = [];
            let parseErrors = [];
            let minAmountFound = Infinity;
            let sumAmounts = 0;
            const allValidLpds = [];

            lines.forEach((line, index) => {
                line = line.trim(); if (!line) return;
                let parts = line.split('\t'); if (parts.length < 2) parts = line.split(/\s+/);
                if (parts.length < 2) { parseErrors.push(`L${index + 1}: Cannot split line: "${line}"`); return; }
                const amountStr = parts[parts.length - 1];
                const amount = parseInt(amountStr);
                if (isNaN(amount)) { parseErrors.push(`L${index + 1}: Amount NaN: "${amountStr}"`); return; }
                if (amount <= 0) { parseErrors.push(`L${index + 1}: Amount <= 0: "${amount}"`); return; }

                validRawAmounts.push(amount);
                sumAmounts += amount;
                if (amount < minAmountFound) minAmountFound = amount;

                const lpd = Math.round(amount / 2);
                if (lpd >= MIN_LPD_VALUE) {
                    lpdFrequencies[lpd] = (lpdFrequencies[lpd] || 0) + 1;
                    allValidLpds.push(lpd);
                }
            });
            if (parseErrors.length > 0) { resultsDiv.innerHTML = `<span class="error">Input Data Parse Errors:</span>\n${parseErrors.join('\n')}`; return; }
            if (minAmountFound === Infinity || validRawAmounts.length === 0) { resultsDiv.innerHTML = `<span class="error">Error: No valid amounts found in the table data.</span>`; return; }
            if (sumAmounts === 0) { resultsDiv.innerHTML = `<span class="error">Error: Total sum of amounts is zero.</span>`; return; }


            // 3. Prepare Base Data and Validate Inputs (Allow combo size 1)
            const maxSlots = parseInt(maxSlotsInput);
             if (isNaN(maxSlots) || maxSlots <= 0) { resultsDiv.innerHTML = '<span class="error">Error: Invalid Max Slots value.</span>'; return; }
            const combinationSize = parseInt(combinationSizeInput);
            // --- MODIFIED VALIDATION ---
            if (isNaN(combinationSize) || combinationSize < 1) { // Allow 1
                resultsDiv.innerHTML = `<span class="error">Error: Invalid Number of Distinct LPDs (must be >= 1).</span>`;
                return;
            }
            // --- End Modification ---

            // ... (Prepare uniqueValidLpdListWithFreq, sort, initialLog same as v0.3.4) ...
            const uniqueValidLpdListWithFreq = Object.entries(lpdFrequencies)
                                      .map(([lpd, freq]) => ({ value: parseInt(lpd), frequency: freq }));
            uniqueValidLpdListWithFreq.sort((a, b) => {
                 if (b.frequency !== a.frequency) return b.frequency - a.frequency; return b.value - b.value;
             });
            let initialLog = [];
            initialLog.push(`Minimum Amount Found in Table: ${minAmountFound}`);
            initialLog.push(`Total Sum of Amounts: ${sumAmounts}`);
            initialLog.push(`Valid Amounts Found (${validRawAmounts.length}): [${validRawAmounts.join(', ')}]`);
            initialLog.push(`Max Slots: ${maxSlots}`);
            initialLog.push(`Required Combination Size (Standard/Proportional): ${combinationSize}`);
            initialLog.push(`Unique Valid LPDs (>=${MIN_LPD_VALUE}) Found: ${uniqueValidLpdListWithFreq.length} values.`);
            let frequencyLog = `Unique Valid LPDs Sorted by Freq/Value: ${uniqueValidLpdListWithFreq.map(l => `${l.value}(${l.frequency})`).join(', ')}`;
            initialLog.push(frequencyLog);

            // 4. Check for Obligatory Candidates (Based on Min LPD Value)
            // ... (Logic same as v0.3.4) ...
             let minLpdValueFound = Infinity;
             uniqueValidLpdListWithFreq.forEach(lpdObj => { if (lpdObj.value < minLpdValueFound) minLpdValueFound = lpdObj.value; });
             initialLog.push(`Minimum Valid LPD Value Found: ${minLpdValueFound === Infinity ? 'None' : minLpdValueFound}`);
             const obligatoryCandidates = minLpdValueFound === Infinity ? [] : uniqueValidLpdListWithFreq.filter(lpdObj => {
                  const diff = Math.abs(lpdObj.value - minLpdValueFound); return diff <= OBLIGATORY_RANGE;
             }).sort((a, b) => a.value - b.value);
             initialLog.push(`Found ${obligatoryCandidates.length} candidate LPD(s) within +/- ${OBLIGATORY_RANGE} of Min LPD Value (${minLpdValueFound === Infinity ? 'N/A' : minLpdValueFound}): [${obligatoryCandidates.map(c=>c.value).join(', ')}]`);


            // 5. Decide Strategy: Standard, GCD Fallback, or Proportional Fallback
            if (obligatoryCandidates.length === 0 && combinationSize > 1) { // GCD only if no candidates AND standard method needed >1 element
                // ---=== GCD FALLBACK STRATEGY ===---
                // ... (GCD Fallback logic remains exactly the same as v0.3.4) ...
                initialLog.push(`<span class="fallback-gcd">ALERT: No valid LPDs found near minimum LPD value. Attempting GCD Fallback Strategy.</span>`);
                let fallbackLog = [`<div class="fallback-section">--- GCD Fallback Calculation ---`];
                const baseTargetAmount = sumAmounts / maxSlots;
                fallbackLog.push(`Base Target Amount (Sum/Slots): ${baseTargetAmount.toFixed(2)}`);
                if (validRawAmounts.length < 1) { fallbackLog.push(`<span class="error">Error: Cannot calculate GCD fallback, no valid amounts.</span>`); resultsDiv.innerHTML = initialLog.join('\n') + '\n' + fallbackLog.join('\n') + `</div>`; return; }
                const gcdAmounts = arrayGcd(validRawAmounts);
                fallbackLog.push(`GCD of all valid amounts (${validRawAmounts.length} values): ${gcdAmounts}`);
                if (gcdAmounts <= 0) { fallbackLog.push(`<span class="error">Error: Calculated GCD of amounts is ${gcdAmounts}.</span>`); resultsDiv.innerHTML = initialLog.join('\n') + '\n' + fallbackLog.join('\n') + `</div>`; return; }
                const fallbackTarget = Math.round(baseTargetAmount / gcdAmounts) * gcdAmounts;
                fallbackLog.push(`Fallback Target (Nearest multiple of GCD to Base Target): ${fallbackTarget}`);
                if (fallbackTarget <= 0) { fallbackLog.push(`<span class="error">Error: Calculated Fallback Target <= 0.</span>`); resultsDiv.innerHTML = initialLog.join('\n') + '\n' + fallbackLog.join('\n') + `</div>`; return; }
                if (fallbackTarget % gcdAmounts !== 0) { fallbackLog.push(`<span class="error">Error: Fallback Target not divisible by GCD. Calc error.</span>`); resultsDiv.innerHTML = initialLog.join('\n') + '\n' + fallbackLog.join('\n') + `</div>`; return; }
                const fallbackK = fallbackTarget / gcdAmounts;
                fallbackLog.push(`Required number of GCD units (Target / GCD): ${fallbackK}`);
                const fallbackCombination = Array(fallbackK).fill(gcdAmounts);
                resultsDiv.innerHTML = initialLog.join('\n') + '\n' + fallbackLog.join('\n') + `\n\n<span class="highlight fallback-gcd">GCD Fallback Result: [${fallbackCombination.join(', ')}]</span>` + `\n(Based on GCD of input amounts, aiming for target amount ${fallbackTarget})` + `\nCombination Size: ${fallbackK}` + `</div>`;

             } else {
                // ---=== STANDARD STRATEGY (or direct to Proportional if Standard not applicable/fails) ===---

                // Only run standard search if candidates exist OR if size is 1 (proportional fallback runs otherwise)
                let standardSearchAttempted = false;
                let overallBestCombination = null;
                let overallBestFrequencyScore = -1;
                let overallBestTargetSum = null;
                let overallSearchLog = [`--- Initial Setup ---`];
                overallSearchLog.push(...initialLog); // Add logs generated so far

                if (obligatoryCandidates.length > 0) { // Standard method requires candidates
                    standardSearchAttempted = true;
                    initialLog.push(`<span class="info">Standard strategy selected (found LPDs near minimum LPD).</span>`);
                     // ... (Target range calculation logic same as v0.3.4) ...
                     const baseTargetLPD = sumAmounts / maxSlots;
                     const lowerBound = baseTargetLPD - TARGET_RANGE_BELOW;
                     const upperBound = baseTargetLPD + TARGET_RANGE_ABOVE;
                     const targetsToTest = [];
                     const firstMultiple = Math.ceil(lowerBound / TARGET_STEP) * TARGET_STEP;
                     const lastMultiple = Math.floor(upperBound / TARGET_STEP) * TARGET_STEP;
                     for (let target = firstMultiple; target <= lastMultiple; target += TARGET_STEP) { if (target > 0) targetsToTest.push(target); }
                     overallSearchLog.push(`Base Calculated Target (Sum/Slots): ${baseTargetLPD.toFixed(2)}`);
                     overallSearchLog.push(`Target Range Tested (-${TARGET_RANGE_BELOW} / +${TARGET_RANGE_ABOVE}): [${lowerBound.toFixed(2)}, ${upperBound.toFixed(2)}]`);
                     if (targetsToTest.length === 0) { overallSearchLog.push(`<span class="error">Error: No positive multiples of ${TARGET_STEP} found in target range for standard method.</span>`); resultsDiv.innerHTML = overallSearchLog.join('\n'); return; } // Display log with error
                     overallSearchLog.push(`Target Sums (multiples of ${TARGET_STEP} in range) to be Tested: [${targetsToTest.join(', ')}]`);

                    // --- Start Standard Search ---
                    const neededOtherLpds = combinationSize - 1; // Will be 0 if combinationSize is 1
                    overallSearchLog.push(`--- Combination Search (Standard Method) ---`);

                    // ... (Standard search loop using findSumCombinationRecursive - same as v0.3.4) ...
                    for (const currentTargetSum of targetsToTest) {
                        overallSearchLog.push(`<div class="target-section">--- Testing Target Sum: ${currentTargetSum} ---`);
                        let foundCombinationForThisTarget = false;
                        for (const currentObligatoryCandidate of obligatoryCandidates) {
                             const currentObligatoryLpdValue = currentObligatoryCandidate.value;
                             overallSearchLog.push(`<div class="candidate-section">=== Trying Obligatory Candidate LPD: ${currentObligatoryLpdValue} for target ${currentTargetSum} ===`);
                             // If neededOtherLpds is 0, search list doesn't matter, targetForRecursion must be 0
                             const searchLpdList = neededOtherLpds > 0 ? uniqueValidLpdListWithFreq.filter(lpdObj => lpdObj.value !== currentObligatoryLpdValue) : [];
                             if (neededOtherLpds > 0 && searchLpdList.length < neededOtherLpds) { overallSearchLog.push(`   Skipping: Not enough other unique LPDs (${searchLpdList.length}) available.`); overallSearchLog.push(`</div>`); continue; }

                             const targetForRecursion = currentTargetSum - currentObligatoryLpdValue;
                             overallSearchLog.push(`   Target sum for remaining ${neededOtherLpds} LPDs: ${currentTargetSum} - ${currentObligatoryLpdValue} = ${targetForRecursion}`);
                             let foundKMinus1Combination = null;

                             // Call recursive function (handles k=0 case correctly if targetForRecursion is 0)
                             foundKMinus1Combination = findSumCombinationRecursive(searchLpdList, targetForRecursion, neededOtherLpds, 0, []);

                             if (foundKMinus1Combination !== null) { // Will be [] if neededOtherLpds=0 and targetForRecursion=0
                                 const currentFullCombination = [...foundKMinus1Combination, currentObligatoryLpdValue].sort((a, b) => a - b);
                                 const currentFrequencyScore = getFrequencyScore(currentFullCombination, lpdFrequencies);
                                 overallSearchLog.push(`   <span class="success">Found Exact Sum Combination: [${currentFullCombination.join(', ')}] (Sum: ${currentTargetSum}, Freq Score: ${currentFrequencyScore})</span>`);
                                 foundCombinationForThisTarget = true;
                                 if (overallBestCombination === null || currentFrequencyScore > overallBestFrequencyScore) {
                                     overallSearchLog.push(`   <span class="info">   ** New OVERALL Best Combination Found (Higher Freq Score) **</span>`);
                                     overallBestCombination = currentFullCombination;
                                     overallBestFrequencyScore = currentFrequencyScore;
                                     overallBestTargetSum = currentTargetSum;
                                 }
                             } else {
                                 if (neededOtherLpds === 0 && targetForRecursion !== 0) {
                                     overallSearchLog.push(`   -> Target (${currentTargetSum}) does not match the single required LPD (${currentObligatoryLpdValue}).`);
                                 } else if (neededOtherLpds > 0) {
                                     overallSearchLog.push(`   -> No combination of ${neededOtherLpds} other distinct LPDs found summing to ${targetForRecursion}.`);
                                 } else {
                                     // Should not happen given logic, but catch-all
                                      overallSearchLog.push(`   -> No combination found.`);
                                 }
                             }
                            overallSearchLog.push(`</div>`); // Close candidate-section
                        } // End obligatory candidate loop
                        if (!foundCombinationForThisTarget) { overallSearchLog.push(`   <span class="info">No combinations found for target ${currentTargetSum} after trying all obligatory candidates.</span>`); }
                         overallSearchLog.push(`</div>`); // Close target-section
                    } // End outer target sum loop
                } // End if(obligatoryCandidates.length > 0)


                // --- Display Result or Trigger Proportional Fallback ---
                resultsDiv.innerHTML = overallSearchLog.join('\n'); // Display log

                if (overallBestCombination !== null) {
                    // --- Standard Method SUCCESS ---
                    resultsDiv.innerHTML += `\n\n<hr>\n`
                                     + `<span class="highlight">Overall Best LPD Combination Found (${combinationSize} LPDs): [${overallBestCombination.join(', ')}]</span>`
                                     + `\n(Standard Method: Highest frequency score among valid combinations)`
                                     + `\nAchieved Target Sum: ${overallBestTargetSum}`
                                     + `\nTotal Frequency Score: ${overallBestFrequencyScore}`;
                } else {
                    // --- Standard Method FAILED or SKIPPED -> PROPORTIONAL FALLBACK ---
                     // Add failure message only if search was actually attempted
                    if (standardSearchAttempted) {
                         resultsDiv.innerHTML += `\n\n<hr>\n`
                                              + `<span class="error">Standard Method Failed: No exact sum combination found.</span>`;
                    } else {
                         resultsDiv.innerHTML += `\n\n<hr>\n`
                                              + `<span class="info">Standard Method Skipped (No valid candidates near min LPD).</span>`;
                    }

                    resultsDiv.innerHTML += `\n<span class="fallback-prop">ALERT: Attempting Proportional Fallback Strategy (Rounding to nearest ${PROPORTIONAL_ROUNDING_STEP}).</span>`;

                    let propFallbackLog = [`<div class="proportional-fallback-section">--- Proportional Fallback Calculation (Round to ${PROPORTIONAL_ROUNDING_STEP}) ---`];

                    const averageValuePerSlot = sumAmounts / maxSlots;
                    propFallbackLog.push(`Average Value Per Slot (Total Sum / Max Slots): ${averageValuePerSlot.toFixed(2)}`);

                    // Handle combinationSize = 1 specifically
                    if (combinationSize === 1) {
                        const roundedAverage = roundToNearest(averageValuePerSlot, PROPORTIONAL_ROUNDING_STEP);
                        propFallbackLog.push(`Combination size is 1. Using Average Value Per Slot rounded to nearest ${PROPORTIONAL_ROUNDING_STEP}.`);
                        const proportionalCombination = [roundedAverage];
                        const sumOfProportionalCombination = proportionalCombination.reduce((sum, val) => sum + val, 0);

                        propFallbackLog.push(`Calculated Proportional Combination (Rounded to ${PROPORTIONAL_ROUNDING_STEP}): [${proportionalCombination.join(', ')}]`);
                        propFallbackLog.push(`Sum of Proportional Combination: ${sumOfProportionalCombination}`);

                         resultsDiv.innerHTML += '\n' + propFallbackLog.join('\n')
                                         + `\n\n<span class="highlight fallback-prop">Proportional Fallback Result: [${proportionalCombination.join(', ')}]</span>`
                                         + `\n(Based on Average Value Per Slot for combination size 1, rounded to nearest ${PROPORTIONAL_ROUNDING_STEP})`
                                         + `</div>`;

                    } else { // combinationSize > 1
                        if (uniqueValidLpdListWithFreq.length < combinationSize) { propFallbackLog.push(`<span class="error">Error: Not enough unique valid LPDs (${uniqueValidLpdListWithFreq.length}) for proportional combination size ${combinationSize}.</span>`); resultsDiv.innerHTML += '\n' + propFallbackLog.join('\n') + `</div>`; return; }

                        const selectedTopLpds = uniqueValidLpdListWithFreq.slice(0, combinationSize);
                        const selectedLpdValues = selectedTopLpds.map(lpd => lpd.value);
                        propFallbackLog.push(`Selected Top ${combinationSize} LPD Values for Proportions: [${selectedLpdValues.join(', ')}]`);

                        const totalLpdValueMass = selectedLpdValues.reduce((sum, val) => sum + val, 0);
                        propFallbackLog.push(`Sum of Selected LPD Values (Proportional Mass): ${totalLpdValueMass}`);

                        if (totalLpdValueMass <= 0) { propFallbackLog.push(`<span class="error">Error: Sum of selected LPD values is ${totalLpdValueMass}. Cannot calculate proportions.</span>`); resultsDiv.innerHTML += '\n' + propFallbackLog.join('\n') + `</div>`; return; }

                        const proportionalCombination = selectedLpdValues.map(lpdVal => {
                            const exactProportion = averageValuePerSlot * lpdVal / totalLpdValueMass;
                            return roundToNearest(exactProportion, PROPORTIONAL_ROUNDING_STEP);
                        });
                        const sumOfProportionalCombination = proportionalCombination.reduce((sum, val) => sum + val, 0);

                        propFallbackLog.push(`Calculated Proportional Combination (Rounded to ${PROPORTIONAL_ROUNDING_STEP}): [${proportionalCombination.join(', ')}]`);
                        propFallbackLog.push(`Sum of Proportional Combination: ${sumOfProportionalCombination} (Compare to Average Value Per Slot: ${averageValuePerSlot.toFixed(2)})`);

                        resultsDiv.innerHTML += '\n' + propFallbackLog.join('\n')
                                            + `\n\n<span class="highlight fallback-prop">Proportional Fallback Result: [${proportionalCombination.join(', ')}]</span>`
                                            + `\n(Distributed average value per slot proportionally based on top ${combinationSize} LPDs by freq/value, rounded to nearest ${PROPORTIONAL_ROUNDING_STEP})`
                                            + `</div>`;
                    }
                }
            } // End Standard vs GCD Fallback if/else

        } // End findBestCombination
    </script>
</body>
</html>