<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>LPD Item Allocator v0.1.12 (Avg Deviation & Interactive Comparison)</title> <!-- Version Bump -->
    <style>
         /* Basic styling */
         body { font-family: sans-serif; padding: 20px; }
        label { display: block; margin-top: 10px; margin-bottom: 5px; font-weight: bold; }
        textarea { width: 90%; min-height: 150px; margin-bottom: 10px; font-family: monospace; }
        input[type="number"], input[type="text"] { padding: 8px; margin-bottom: 10px; width: 300px; }
        button { padding: 10px 15px; cursor: pointer; background-color: #28a745; color: white; border: none; border-radius: 4px; margin-top: 10px; }
        button:hover { background-color: #218838; }
        #statusArea, #strategyComparison, #allocationResults, #cumulativeUsage, #adjustmentLog, #lpdBreakdown, #finalSummaryTableDiv, #variationLog { margin-top: 20px; padding: 15px; border: 1px solid #ccc; background-color: #f9f9f9; white-space: pre-wrap; font-family: monospace; }
        .error { color: red; font-weight: bold; }
        .info { color: blue; }
        .warning { color: orange; }
        .success { color: green; font-weight: bold; }
        .positive-diff { color: #dc3545; }
        .negative-diff { color: #198754; }
        .zero-diff { color: #6c757d; }
        .violation { background-color: #f8d7da; color: #721c24; border: 1px solid #f5c6cb; padding: 1px 3px; border-radius: 3px;}
        .input-group { margin-bottom: 15px; }
        .highlight { background-color: #cff4fc; font-weight: bold; border: 1px solid #9eeaf9;}
        .item-allocation, .adjustment-step, .lpd-section, .variation-step { border-top: 1px dashed #aaa; margin-top: 10px; padding-top: 10px;}
        .usage-summary, .lpd-section-title, .comparison-title { margin-top: 15px; font-weight: bold; }
        .lpd-item-list { margin-left: 20px; list-style-type: none; padding-left: 0;}
        .lpd-item-list li { margin-bottom: 3px; }
        .lpd-total { margin-top: 5px; font-style: italic; padding-left: 20px; }

        /* Style for Tables */
        #finalSummaryTable, #comparisonTable { width: 90%; border-collapse: collapse; margin-top: 15px; } /* Wider table */
        #finalSummaryTable th, #finalSummaryTable td, #comparisonTable th, #comparisonTable td { border: 1px solid #ddd; padding: 6px 8px; text-align: left; }
        #finalSummaryTable th, #comparisonTable th { background-color: #e9ecef; font-weight: bold; }
        #finalSummaryTable td:nth-child(n+2), #comparisonTable td:nth-child(n+2) { text-align: right; } /* Align numeric columns (2+) right */
        #finalSummaryTable tr:nth-child(even), #comparisonTable tr:nth-child(even) { background-color: #f8f9fa; }
        .best-effort { background-color: #fff3cd !important; border-left: 4px solid #ffeeba; padding-left: 5px; font-weight: bold; }
        .strategy-error { background-color: #f8d7da !important; border-left: 4px solid #f5c6cb; padding-left: 5px; }
        #comparisonTable .strategy-name { cursor: pointer; text-decoration: underline; color: #0d6efd; text-align: left !important; } /* Ensure name is left-aligned */
        #comparisonTable .strategy-name:hover { color: #0a58ca; }

    </style>
</head>
<body>

    <h1>LPD Item Allocator (24 Strategies, Avg/Max Deviation, Interactive Comparison)</h1>
    <p>Allocates items using 24 strategies, adjusts within ±25%, compares max & average variation & errors. Click strategy names to view details. Selects best strategy (first under ±30% max var without errors, else lowest max var without errors, else lowest max var with errors).</p>

    <!-- Input fields - unchanged -->
    <div class="input-group">
        <label for="tableData">Table Data (Details + Amount, one per line):</label>
        <textarea id="tableData" placeholder="Example:
Item A	10000
Item B	5000
..."></textarea>
    </div>
     <div class="input-group">
        <label for="lpdCombinationInput">LPD Combination (e.g., [3000, 8000]):</label>
        <input type="text" id="lpdCombinationInput" placeholder="[3000, 8000]">
    </div>
    <div class="input-group">
        <label for="maxSlots">Max Slots per LPD (Cumulative):</label>
        <input type="number" id="maxSlots" placeholder="e.g., 3 (blank=unlimited)" min="1" style="width: 120px;">
    </div>

    <button onclick="allocateAllItems()">Allocate, Compare Strategies & Adjust</button>

    <!-- Output area -->
    <div id="statusArea">Status messages will appear here...</div>
    <div id="strategyComparison">Strategy Comparison results will appear here...</div>
    <hr style="margin-top: 25px; border-top: 1px solid #bbb;">
    <h2 id="detailsTitle" style="margin-top: 5px; font-size: 1.1em;">Detailed Results</h2>
    <div id="allocationResults">Detailed Item Allocation results will appear here...</div>
    <div id="adjustmentLog">Slot Filling Adjustment Log will appear here...</div>
    <div id="variationLog">Variation Adjustment Log will appear here...</div>
    <div id="cumulativeUsage">Cumulative LPD usage will appear here...</div>
    <div id="lpdBreakdown">LPD Usage Breakdown by Item will appear here...</div>
    <div id="finalSummaryTableDiv">Final Allocation Summary Table will appear here...</div>


    <script>
        // --- GLOBAL STORAGE ---
        let globalStrategyResults = [];
        let globalOriginalItems = [];
        let globalLpdCombination = [];
        let globalMaxSlotsDisplay = "Unlimited";

        // --- CONFIGURATION RULES ---
        const MIN_LPD_VALUE_ALLOC = 0;
        const VARIATION_LIMIT_PASS_3 = 0.25;
        const REPROCESS_VARIATION_LIMIT = 0.30;

        // --- Find Closest Sum (Allocation DP) ---
        // Function remains the same as previous version (v0.1.11)
        function findClosestSumWithRepetitionAndSlots(lpdArray, target, remainingSlotsMap) {
            // ... (Exact same DP logic as v0.1.11) ...
             if (!lpdArray || lpdArray.length === 0) { return { sum: 0, difference: 0 - target, combination: [], error: "No LPDs provided for allocation" }; }
             if (target < 0) { return { sum: 0, difference: 0 - target, combination: [], error: "Target amount cannot be negative" }; }
             lpdArray = [...new Set(lpdArray)].filter(lpd => lpd > 0 && remainingSlotsMap.hasOwnProperty(lpd) && remainingSlotsMap[lpd] > 0).sort((a, b) => a - b);
             if (lpdArray.length === 0) { return { sum: 0, difference: 0 - target, combination: [], error: "LPD list empty or no LPDs have remaining slots" }; }
             const smallestLpd = lpdArray[0]; const maxSum = Math.max(target, 0) + smallestLpd; const dp = new Array(maxSum + 1).fill(null); dp[0] = { count: 0, usage: {}, lastLpd: null };
             for (let i = 1; i <= maxSum; i++) { let bestStateForI = null; for (const lpd of lpdArray) { const prevSum = i - lpd; if (prevSum >= 0 && dp[prevSum] !== null) { const prevState = dp[prevSum]; const currentLpdUsageInThisPath = (prevState.usage[lpd] || 0) + 1; const slotsAvailable = remainingSlotsMap[lpd]; if (currentLpdUsageInThisPath <= slotsAvailable) { const newTotalCount = prevState.count + 1; if (bestStateForI === null || newTotalCount < bestStateForI.count) { const newUsage = { ...prevState.usage, [lpd]: currentLpdUsageInThisPath }; bestStateForI = { count: newTotalCount, usage: newUsage, lastLpd: lpd }; } } } } dp[i] = bestStateForI; }
             let minAbsDiff = Infinity; let closestSum = -1; let bestReachableState = null; for (let i = target; i >= 0; i--) { if (dp[i] !== null) { const diff = Math.abs(target - i); if (diff < minAbsDiff || (diff === minAbsDiff && dp[i].count < bestReachableState.count)) { minAbsDiff = diff; closestSum = i; bestReachableState = dp[i]; } if (diff > minAbsDiff && closestSum !== -1) break; } } for (let i = target + 1; i <= maxSum; i++) { if (dp[i] !== null) { const diff = Math.abs(i - target); if (diff < minAbsDiff || (diff === minAbsDiff && dp[i].count < bestReachableState.count)) { minAbsDiff = diff; closestSum = i; bestReachableState = dp[i]; } if (diff >= minAbsDiff && closestSum !== -1) break; } } if (closestSum === -1) { if (target === 0 && dp[0] !== null) { closestSum = 0; bestReachableState = dp[0]; } else { return { sum: 0, difference: 0 - target, combination: [], error: "Could not reach target sum with available LPDs/slots" }; } }
             const combination = []; let currentSum = closestSum; let currentState = bestReachableState; let safetyCounter = 0; const maxLoops = (currentState?.count || 0) + lpdArray.length + 100; while (currentSum > 0 && currentState?.lastLpd && safetyCounter < maxLoops) { const usedLpd = currentState.lastLpd; combination.push(usedLpd); const prevSum = currentSum - usedLpd; if (prevSum >= 0 && dp[prevSum] !== null) { currentState = dp[prevSum]; currentSum = prevSum; } else { return { sum: closestSum, difference: closestSum - target, combination: combination.sort((a,b)=>a-b), error: `Backtracking error: State missing for sum ${prevSum}` }; } safetyCounter++; }
             if (safetyCounter >= maxLoops) { return { sum: closestSum, difference: closestSum - target, combination: combination.sort((a,b)=>a-b), error: "Backtracking safety limit reached" }; } if (currentSum !== 0 && closestSum !== 0) { return { sum: closestSum, difference: closestSum - target, combination: combination.sort((a,b)=>a-b), error: `Backtracking incomplete (final sum ${currentSum} reached)` }; } const reconstructedSum = combination.reduce((a, b) => a + b, 0); if (reconstructedSum !== closestSum) { return { sum: closestSum, difference: closestSum - target, combination: combination.sort((a,b)=>a-b), error: `Reconstruction mismatch (${reconstructedSum} != ${closestSum})` }; } const finalUsageCheck = {}; for(const lpd of combination) { finalUsageCheck[lpd] = (finalUsageCheck[lpd] || 0) + 1; if (finalUsageCheck[lpd] > remainingSlotsMap[lpd]) { return { sum: closestSum, difference: closestSum - target, combination: combination.sort((a,b)=>a-b), error: `Slot limit violated for LPD ${lpd} during final reconstruction check` }; } }
             const finalDifference = closestSum - target; return { sum: closestSum, difference: finalDifference, combination: combination.sort((a,b)=>a-b) };
        }

        // --- Helper: Calculate Max Absolute Variation Percentage ---
        // Function remains the same as previous version (v0.1.11)
        function calculateMaxVariation(items, allocations) {
            let maxAbsPercentage = 0; for (let i = 0; i < items.length; i++) { const item = items[i]; const alloc = allocations[i]; if (alloc.error || alloc.difference === undefined) continue; const targetAmount = item.amount; const difference = alloc.difference; let currentAbsPercentage = 0; if (targetAmount > 0) { currentAbsPercentage = Math.abs(difference / targetAmount); } else if (alloc.sum !== 0) { currentAbsPercentage = Infinity; } if (currentAbsPercentage > maxAbsPercentage) { maxAbsPercentage = currentAbsPercentage; } } return maxAbsPercentage;
        }

        // --- Helper: Calculate Average Absolute Variation Percentage ---
        // NEW function to calculate the average deviation, ignoring errors and zero-target items.
        function calculateAverageVariation(items, allocations) {
            let totalPercentageSum = 0;
            let validItemCount = 0;
            for (let i = 0; i < items.length; i++) {
                const item = items[i];
                const alloc = allocations[i];

                // Include only items without errors AND with a positive target amount
                if (!alloc.error && alloc.difference !== undefined && item.amount > 0) {
                    const absPercentage = Math.abs(alloc.difference / item.amount);
                    totalPercentageSum += absPercentage;
                    validItemCount++;
                }
                // Note: Items with target 0 are excluded from average calculation.
                // Items with errors are also excluded.
            }

            if (validItemCount > 0) {
                return totalPercentageSum / validItemCount;
            } else {
                return 0; // Return 0 if no valid items to average (e.g., all errors or all zero targets)
            }
        }


        // --- Core Allocation Logic (Reusable Function) ---
        // Function remains the same as previous version (v0.1.11)
        function runAllocationProcess(itemsToProcess, userLpdCombination, maxSlots) {
             // ... (Exact same function logic as v0.1.11) ...
             const maxSlotsIsFinite = maxSlots !== Infinity; const maxSlotsDisplay = maxSlotsIsFinite ? maxSlots : "Unlimited"; let logs = { adjustment: '', variation: '' }; const currentRemainingSlots = {}; userLpdCombination.forEach(lpd => { currentRemainingSlots[lpd] = maxSlots; }); const currentItemAllocations = new Array(itemsToProcess.length);
             /* --- PASS 1 --- */ itemsToProcess.forEach((item, i) => { const initialRemainingForThisItem = {...currentRemainingSlots}; const allocation = findClosestSumWithRepetitionAndSlots([...userLpdCombination], item.amount, initialRemainingForThisItem); currentItemAllocations[i] = allocation; if (!allocation.error && allocation.combination && allocation.combination.length > 0) { allocation.combination.forEach(lpd => { if (currentRemainingSlots[lpd] !== Infinity) { if (currentRemainingSlots[lpd] > 0) { currentRemainingSlots[lpd]--; } else { console.error(`Slot count error Pass 1 (Post-DP): LPD ${lpd} used for Item ${item.details} when run slots were 0.`); } } }); } });
             /* --- PASS 2 --- */ let adjustmentLogHTML = `--- Pass 2: Slot Filling (Target Slots: ${maxSlotsDisplay}) ---`; if (maxSlotsIsFinite) { adjustmentLogHTML += `\nInitial Rem Slots: ${JSON.stringify(currentRemainingSlots, null, 2)}`; let totalRemaining = Object.values(currentRemainingSlots).reduce((sum, count) => sum + (count === Infinity ? 0 : count), 0); adjustmentLogHTML += `\nTotal Rem Slots: ${totalRemaining}`; let adjustmentSafetyCounter = 0; const maxAdjustments = totalRemaining + itemsToProcess.length * 2; while (totalRemaining > 0 && adjustmentSafetyCounter < maxAdjustments) { adjustmentSafetyCounter++; let bestMove = { lpdToAdd: null, itemIndex: -1, minImpact: Infinity }; for (const lpd of userLpdCombination) { if (currentRemainingSlots[lpd] > 0) { for (let i = 0; i < currentItemAllocations.length; i++) { const currentAlloc = currentItemAllocations[i]; if (currentAlloc.error || currentAlloc.sum === undefined) continue; const originalAmount = itemsToProcess[i].amount; const currentSum = currentAlloc.sum; const currentAbsDifference = Math.abs(currentAlloc.difference); const newSum = currentSum + lpd; const newAbsDifference = Math.abs(newSum - originalAmount); const impact = newAbsDifference - currentAbsDifference; if (impact < bestMove.minImpact) { bestMove = { lpdToAdd: lpd, itemIndex: i, minImpact: impact }; } } } } if (bestMove.lpdToAdd !== null) { const lpd = bestMove.lpdToAdd; const itemIdx = bestMove.itemIndex; adjustmentLogHTML += `<div class="adjustment-step">Step ${adjustmentSafetyCounter}: Add LPD <span class="info">${lpd}</span> to Item ${itemsToProcess[itemIdx].index + 1} ('${itemsToProcess[itemIdx].details}') (Impact: ${bestMove.minImpact >= 0 ? '+' : ''}${bestMove.minImpact.toFixed(0)})`; currentItemAllocations[itemIdx].combination.push(lpd); currentItemAllocations[itemIdx].combination.sort((a,b)=>a-b); currentItemAllocations[itemIdx].sum += lpd; currentItemAllocations[itemIdx].difference = currentItemAllocations[itemIdx].sum - itemsToProcess[itemIdx].amount; currentRemainingSlots[lpd]--; totalRemaining--; adjustmentLogHTML += `\n   -> New Sum: ${currentItemAllocations[itemIdx].sum}, Diff: ${currentItemAllocations[itemIdx].difference.toFixed(0)}, Slots Rem ${lpd}: ${currentRemainingSlots[lpd]}</div>`; } else { adjustmentLogHTML += `\n<span class="warning">Stopped: No beneficial move. ${totalRemaining} slots unused.</span>`; break; } } if (adjustmentSafetyCounter >= maxAdjustments) { adjustmentLogHTML += `\n<span class="error">Stopped: Safety limit (${maxAdjustments}).</span>`; } } else { adjustmentLogHTML += `\n(Skipped: Unlimited Slots)`; } logs.adjustment = adjustmentLogHTML;
             /* --- PASS 3 --- */ let variationLogHTML = `--- Pass 3: Variation Correction (Target: ±${(VARIATION_LIMIT_PASS_3 * 100).toFixed(0)}%) ---`; let madeVariationAdjustment = true; let variationLoopCounter = 0; const maxVariationLoops = itemsToProcess.length * userLpdCombination.length * 2 + 10; while (madeVariationAdjustment && variationLoopCounter < maxVariationLoops) { variationLoopCounter++; madeVariationAdjustment = false; let worstViolation = { index: -1, percentageDiff: 0 }; currentItemAllocations.forEach((alloc, i) => { if (!alloc.error && alloc.difference !== undefined) { const item = itemsToProcess[i]; const targetAmount = item.amount; let percentageDiff = 0; if (targetAmount > 0) { percentageDiff = Math.abs(alloc.difference / targetAmount); } else if (alloc.sum !== 0) { percentageDiff = Infinity; } if (percentageDiff > VARIATION_LIMIT_PASS_3 && percentageDiff > worstViolation.percentageDiff) { worstViolation = { index: i, percentageDiff: percentageDiff }; } } }); if (worstViolation.index === -1) { variationLogHTML += `\nIter ${variationLoopCounter}: No items > ±${(VARIATION_LIMIT_PASS_3 * 100).toFixed(0)}% limit.`; break; } const itemIdx = worstViolation.index; const currentAlloc = currentItemAllocations[itemIdx]; const originalAmount = itemsToProcess[itemIdx].amount; variationLogHTML += `<div class="variation-step">Iter ${variationLoopCounter}: Fixing Item ${itemsToProcess[itemIdx].index + 1} ('${itemsToProcess[itemIdx].details}') - Diff: ${currentAlloc.difference.toFixed(0)} (${(worstViolation.percentageDiff * 100).toFixed(1)}%)`; let bestFix = { action: null, lpd: null, finalAbsDiff: Infinity }; const currentCombinationCopy = [...currentAlloc.combination]; for (const lpdToRemove of currentCombinationCopy) { const newSum = currentAlloc.sum - lpdToRemove; const newSignedDiff = newSum - originalAmount; const newAbsDiff = Math.abs(newSignedDiff); const newPercentageDiff = originalAmount > 0 ? (newAbsDiff / originalAmount) : (newSum === 0 ? 0 : Infinity); if (newPercentageDiff <= VARIATION_LIMIT_PASS_3) { if (newAbsDiff < bestFix.finalAbsDiff) { bestFix = { action: 'remove', lpd: lpdToRemove, finalAbsDiff: newAbsDiff }; } } } for (const lpdToAdd of userLpdCombination) { if (currentRemainingSlots[lpdToAdd] > 0 || !maxSlotsIsFinite) { const newSum = currentAlloc.sum + lpdToAdd; const newSignedDiff = newSum - originalAmount; const newAbsDiff = Math.abs(newSignedDiff); const newPercentageDiff = originalAmount > 0 ? (newAbsDiff / originalAmount) : (newSum === 0 ? 0 : Infinity); if (newPercentageDiff <= VARIATION_LIMIT_PASS_3) { if (newAbsDiff < bestFix.finalAbsDiff) { bestFix = { action: 'add', lpd: lpdToAdd, finalAbsDiff: newAbsDiff }; } } } } if (bestFix.action) { madeVariationAdjustment = true; const lpd = bestFix.lpd; variationLogHTML += ` -> Action: ${bestFix.action.toUpperCase()} ${lpd}`; if (bestFix.action === 'remove') { const indexToRemove = currentItemAllocations[itemIdx].combination.indexOf(lpd); if (indexToRemove > -1) { currentItemAllocations[itemIdx].combination.splice(indexToRemove, 1); currentItemAllocations[itemIdx].sum -= lpd; currentItemAllocations[itemIdx].difference -= lpd; if (maxSlotsIsFinite) { currentRemainingSlots[lpd]++; } } else { console.error(`VFix Error: Remove ${lpd} not found`); variationLogHTML += ` <span class="error">(Error!)</span>`; madeVariationAdjustment = false; } } else { currentItemAllocations[itemIdx].combination.push(lpd); currentItemAllocations[itemIdx].combination.sort((a,b) => a-b); currentItemAllocations[itemIdx].sum += lpd; currentItemAllocations[itemIdx].difference += lpd; if (maxSlotsIsFinite) { currentRemainingSlots[lpd]--; } } const finalPercDiffCheck = originalAmount > 0 ? Math.abs(currentItemAllocations[itemIdx].difference / originalAmount) : (currentItemAllocations[itemIdx].sum === 0 ? 0 : Infinity); variationLogHTML += ` -> New Diff: ${currentItemAllocations[itemIdx].difference.toFixed(0)} (${(finalPercDiffCheck * 100).toFixed(1)}%)`; if (maxSlotsIsFinite) { variationLogHTML += `, Slots Rem ${lpd}: ${currentRemainingSlots[lpd]}`; } } else { variationLogHTML += ` -> <span class="warning">No single fix found.</span>`; } variationLogHTML += `</div>`; } if (variationLoopCounter >= maxVariationLoops) { variationLogHTML += `\n<span class="error">Stopped: Loop limit (${maxVariationLoops}).</span>`; } logs.variation = variationLogHTML;
             /* --- Final Usage --- */ let finalCumulativeUsage = {}; userLpdCombination.forEach(lpd => { finalCumulativeUsage[lpd] = 0; }); currentItemAllocations.forEach(alloc => { alloc.finalUsageCounts = {}; if (!alloc.error && alloc.combination) { alloc.combination.forEach(lpd => { alloc.finalUsageCounts[lpd] = (alloc.finalUsageCounts[lpd] || 0) + 1; if (finalCumulativeUsage.hasOwnProperty(lpd)) { finalCumulativeUsage[lpd]++; } else { console.error(`LPD ${lpd} not in initial list.`); } }); } });
             return { itemAllocations: currentItemAllocations, cumulativeUsage: finalCumulativeUsage, remainingSlots: currentRemainingSlots, logs: logs };
         }

        // --- Function to Display Details for a Specific Strategy ---
        // Function remains the same as previous version (v0.1.11)
        function displayStrategyDetails(encodedStrategyName) {
             // ... (Exact same display logic as v0.1.11) ...
             const strategyName = decodeURIComponent(encodedStrategyName); console.log(`Displaying details for strategy: ${strategyName}`); const statusAreaDiv = document.getElementById('statusArea'); const detailsTitle = document.getElementById('detailsTitle'); const selectedResult = globalStrategyResults.find(res => res.strategyName === strategyName); if (!selectedResult) { statusAreaDiv.innerHTML = `<span class="error">Error: Could not find results for strategy "${strategyName}".</span>`; document.getElementById('allocationResults').innerHTML = ''; document.getElementById('adjustmentLog').innerHTML = ''; document.getElementById('variationLog').innerHTML = ''; document.getElementById('cumulativeUsage').innerHTML = ''; document.getElementById('lpdBreakdown').innerHTML = ''; document.getElementById('finalSummaryTableDiv').innerHTML = ''; detailsTitle.innerHTML = 'Detailed Results'; return; }
             statusAreaDiv.innerHTML = `Displaying detailed results for strategy: <span class="info">${strategyName}</span>`; detailsTitle.innerHTML = `Detailed Results (Strategy: ${strategyName})`; const finalItems = selectedResult.itemsUsed; const finalAllocations = selectedResult.resultData.itemAllocations; const finalCumulativeUsage = selectedResult.resultData.cumulativeUsage; const finalRemainingSlots = selectedResult.resultData.remainingSlots; const finalLogs = selectedResult.resultData.logs; const userLpdCombination = globalLpdCombination; const maxSlotsDisplay = globalMaxSlotsDisplay; const originalItemsUnsorted = globalOriginalItems;
             document.getElementById('adjustmentLog').innerHTML = finalLogs.adjustment; document.getElementById('variationLog').innerHTML = finalLogs.variation;
             let finalAllocationHTML = `--- Final Item Allocations (Strategy: ${selectedResult.strategyName}) ---`; finalItems.forEach((item, i) => { finalAllocationHTML += `<div class="item-allocation">`; finalAllocationHTML += `<b>${i + 1}. ${item.details}</b> (Original Line: ${item.originalIndex + 1}, Target: ${item.amount})\n`; const finalAlloc = finalAllocations[i]; if (finalAlloc.error) { finalAllocationHTML += `<span class="error">Allocation Error: ${finalAlloc.error}</span>\n`; } else if (finalAlloc.sum !== undefined) { const finalPercDiff = item.amount > 0 ? (finalAlloc.difference / item.amount) : (finalAlloc.sum === 0 ? 0 : Infinity); const absFinalPercDiff = Math.abs(finalPercDiff); let diffClass = finalAlloc.difference === 0 ? 'zero-diff' : (finalAlloc.difference > 0 ? 'positive-diff' : 'negative-diff'); let diffSign = finalAlloc.difference > 0 ? '+' : ''; finalAllocationHTML += `<span class="highlight">Sum: ${finalAlloc.sum}</span> (Diff: <span class="${diffClass}">${diffSign}${finalAlloc.difference.toFixed(0)}</span>`; if (item.amount > 0) { finalAllocationHTML += ` / ${(finalPercDiff * 100).toFixed(1)}%`; if (absFinalPercDiff > REPROCESS_VARIATION_LIMIT) { finalAllocationHTML += ` <span class="violation">>±${(REPROCESS_VARIATION_LIMIT * 100).toFixed(0)}%</span>`; } else if (absFinalPercDiff > VARIATION_LIMIT_PASS_3) { finalAllocationHTML += ` <span class="warning">>±${(VARIATION_LIMIT_PASS_3 * 100).toFixed(0)}%</span>`; } } else if (finalAlloc.sum !== 0) { finalAllocationHTML += ` <span class="violation">Non-zero sum</span>`; } finalAllocationHTML += `)\n`; if (finalAlloc.combination && finalAlloc.combination.length > 0) { finalAllocationHTML += `   Combo (${finalAlloc.combination.length}): [${finalAlloc.combination.join(', ')}]`; if (finalAlloc.finalUsageCounts && Object.keys(finalAlloc.finalUsageCounts).length > 0) { finalAllocationHTML += `\n   Usage: { ${Object.entries(finalAlloc.finalUsageCounts).map(([lpd, count]) => `"${lpd}": ${count}`).join(', ')} }`; } else { finalAllocationHTML += `\n   Usage: {}`; } } else { finalAllocationHTML += `   (No LPDs needed)`; } } else { finalAllocationHTML += "<span class='error'>Inv. Alloc. Struct.</span>"; } finalAllocationHTML += `</div>`; }); document.getElementById('allocationResults').innerHTML = finalAllocationHTML;
             let usageSummaryHTML = `<div class="usage-summary">--- Cumulative LPD Usage (Strategy: ${selectedResult.strategyName}, Max Slots: ${maxSlotsDisplay}) ---`; usageSummaryHTML += "<ul>"; userLpdCombination.forEach(lpd => { const used = finalCumulativeUsage[lpd] || 0; const remaining = finalRemainingSlots[lpd]; usageSummaryHTML += `<li>LPD ${lpd}: Used ${used} times`; if (maxSlotsDisplay !== "Unlimited") { const maxSlotsNum = parseInt(maxSlotsDisplay); const remainingDisplay = (remaining === undefined || remaining === Infinity) ? maxSlotsNum - used : remaining; usageSummaryHTML += `, Remaining: ${remainingDisplay}`; if (remainingDisplay < 0) { usageSummaryHTML += ` <span class="error">(Slot Error!)</span>`; } else if (typeof remaining === 'number' && used + remaining !== maxSlotsNum) { console.warn(`Slot mismatch ${lpd}: U${used}, R${remaining}, M${maxSlotsNum}`); usageSummaryHTML += ` <span class="warning">(Count Mismatch?)</span>`; } } usageSummaryHTML += `</li>`; }); usageSummaryHTML += "</ul></div>"; document.getElementById('cumulativeUsage').innerHTML = usageSummaryHTML;
             let lpdBreakdownHTML = `<div class="lpd-section-title">--- LPD Usage Breakdown (Strategy: ${selectedResult.strategyName}) ---`; const lpdUsageByItem = new Map(); userLpdCombination.forEach(lpd => { lpdUsageByItem.set(lpd, []); }); finalItems.forEach((item, i) => { const finalAlloc = finalAllocations[i]; if (!finalAlloc.error && finalAlloc.finalUsageCounts) { for (const [lpdValueStr, count] of Object.entries(finalAlloc.finalUsageCounts)) { const lpdValue = parseInt(lpdValueStr); if (count > 0 && lpdUsageByItem.has(lpdValue)) { lpdUsageByItem.get(lpdValue).push({ details: item.details, count: count }); } } } }); userLpdCombination.forEach(lpd => { const itemsUsingLpd = lpdUsageByItem.get(lpd); const totalCountForLpd = itemsUsingLpd.reduce((sum, item) => sum + item.count, 0); lpdBreakdownHTML += `<div class="lpd-section">`; lpdBreakdownHTML += `<span class="lpd-section-title">LPD: ${lpd}</span>`; if (itemsUsingLpd.length > 0) { lpdBreakdownHTML += `<ul class="lpd-item-list">`; itemsUsingLpd.sort((a,b)=>a.details.localeCompare(b.details)).forEach(itemUse => { lpdBreakdownHTML += `<li>${itemUse.details}: ${itemUse.count}x</li>`; }); lpdBreakdownHTML += `</ul>`; lpdBreakdownHTML += `<div class="lpd-total">Total Used: ${totalCountForLpd}</div>`; } else { lpdBreakdownHTML += `\n   (Not used by non-errored items)`; } lpdBreakdownHTML += `</div>`; }); document.getElementById('lpdBreakdown').innerHTML = lpdBreakdownHTML;
              let summaryTableHTML = `<div class="lpd-section-title">--- Allocation Summary Table (Strategy: ${selectedResult.strategyName}) ---</div>`; summaryTableHTML += `<table id="finalSummaryTable">`; summaryTableHTML += `<thead><tr><th>Sabor (Original Order)</th><th>Quantidade</th><th>Empenho</th><th>Dif</th><th>Var (%)</th></tr></thead>`; summaryTableHTML += `<tbody>`; const allocationMap = new Map(); finalItems.forEach((item, i) => { allocationMap.set(item.originalIndex, {itemData: item, allocationData: finalAllocations[i]}); }); originalItemsUnsorted.forEach(originalItem => { const resultEntry = allocationMap.get(originalItem.originalIndex); let sabor = originalItem.details; let quantidade = originalItem.amount; let empenho = 'N/A'; let difHtml = 'N/A'; let varHtml = 'N/A'; if (resultEntry) { const finalAlloc = resultEntry.allocationData; if (!finalAlloc.error && finalAlloc.sum !== undefined) { empenho = finalAlloc.sum.toFixed(0); const dif = finalAlloc.difference; let difClass = dif === 0 ? 'zero-diff' : (dif > 0 ? 'positive-diff' : 'negative-diff'); let difSign = dif > 0 ? '+' : ''; difHtml = `<span class="${difClass}">${difSign}${dif.toFixed(0)}</span>`; if (quantidade > 0) { const percentage = (dif / quantidade); const percentageFmt = (percentage * 100).toFixed(1) + '%'; varHtml = percentageFmt; if (Math.abs(percentage) > REPROCESS_VARIATION_LIMIT) { varHtml = `<span class="violation">${percentageFmt}</span>`; } else if (Math.abs(percentage) > VARIATION_LIMIT_PASS_3) { varHtml = `<span class="warning">${percentageFmt}</span>`; } } else if (empenho !== '0') { varHtml = `<span class="violation">N/A (Non-zero sum)</span>`; } else { varHtml = '0.0%'; } } else if (finalAlloc.error) { empenho = `<span class="error">Error</span>`; difHtml = `<span class="error">${finalAlloc.error}</span>`; varHtml = `<span class="error">Error</span>`; } } summaryTableHTML += `<tr><td>${sabor}</td><td>${quantidade}</td><td>${empenho}</td><td>${difHtml}</td><td>${varHtml}</td></tr>`; }); summaryTableHTML += `</tbody></table>`; document.getElementById('finalSummaryTableDiv').innerHTML = summaryTableHTML;
              updateComparisonTableHighlight(strategyName);
        }

        // --- Helper to update highlighting in the comparison table ---
        // Function remains the same as previous version (v0.1.11)
        function updateComparisonTableHighlight(selectedStrategyName) {
             // ... (Exact same highlighting logic as v0.1.11) ...
            const table = document.getElementById('comparisonTable'); if (!table) return; const rows = table.getElementsByTagName('tbody')[0].getElementsByTagName('tr'); for (let row of rows) { row.classList.remove('best-effort', 'strategy-error'); const firstCell = row.cells[0]; if (firstCell) { const currentStrategyName = firstCell.textContent.replace(/\s*\(Selected\)$/, '').trim(); const resultEntry = globalStrategyResults.find(res => res.strategyName === currentStrategyName); if (resultEntry) { if (resultEntry.hasAllocationError) { row.classList.add('strategy-error'); } if (currentStrategyName === selectedStrategyName) { row.classList.add('best-effort'); firstCell.textContent = `${currentStrategyName} (Selected)`; } else { firstCell.textContent = currentStrategyName; } } } }
        }


        // --- Main Controlling Function ---
        function allocateAllItems() {
            // 1. Read and Validate Inputs
            // ... (Same input reading and validation as v0.1.11) ...
            const tableDataInput = document.getElementById('tableData').value.trim(); const lpdCombinationInput = document.getElementById('lpdCombinationInput').value.trim(); const maxSlotsInput = document.getElementById('maxSlots').value; const statusAreaDiv = document.getElementById('statusArea'); const strategyComparisonDiv = document.getElementById('strategyComparison'); globalStrategyResults = []; globalOriginalItems = []; globalLpdCombination = []; statusAreaDiv.innerHTML = ''; strategyComparisonDiv.innerHTML = ''; document.getElementById('allocationResults').innerHTML = `Processing...`; document.getElementById('adjustmentLog').innerHTML = ''; document.getElementById('variationLog').innerHTML = ''; document.getElementById('cumulativeUsage').innerHTML = ''; document.getElementById('lpdBreakdown').innerHTML = ''; document.getElementById('finalSummaryTableDiv').innerHTML = ''; document.getElementById('detailsTitle').innerHTML = 'Detailed Results'; if (!tableDataInput) { statusAreaDiv.innerHTML = '<span class="error">Error: Table data cannot be empty.</span>'; document.getElementById('allocationResults').innerHTML = ''; return; } if (!lpdCombinationInput) { statusAreaDiv.innerHTML = '<span class="error">Error: LPD Combination input cannot be empty.</span>'; document.getElementById('allocationResults').innerHTML = ''; return; } let maxSlots = Infinity; let maxSlotsIsFinite = false; if (maxSlotsInput) { maxSlots = parseInt(maxSlotsInput); if (isNaN(maxSlots) || maxSlots < 1) { statusAreaDiv.innerHTML = '<span class="error">Invalid Max Slots per LPD.</span>'; document.getElementById('allocationResults').innerHTML = ''; return; } maxSlotsIsFinite = true; } const maxSlotsDisplay = maxSlotsIsFinite ? maxSlots : "Unlimited"; globalMaxSlotsDisplay = maxSlotsDisplay; let userLpdCombination; try { userLpdCombination = JSON.parse(lpdCombinationInput.replace(/\s/g, '')); if (!Array.isArray(userLpdCombination) || !userLpdCombination.every(item => typeof item === 'number' && item > 0) || userLpdCombination.length === 0) { throw new Error("Invalid LPD array."); } userLpdCombination = [...new Set(userLpdCombination)].sort((a, b) => a - b); globalLpdCombination = userLpdCombination; } catch (e) { statusAreaDiv.innerHTML = `<span class="error">Error parsing LPD Combination: ${e.message}</span>`; document.getElementById('allocationResults').innerHTML = ''; return; } let originalItemsUnsorted = []; let parseErrors = []; const lines = tableDataInput.split('\n'); lines.forEach((line, index) => { line = line.trim(); if (!line) return; let parts = line.split('\t'); let details = ''; if (parts.length < 2) { parts = line.split(/\s+/); } if (parts.length < 2) { parseErrors.push(`L${index + 1}: Cannot split: "${line}"`); return; } const amountStr = parts[parts.length - 1].replace(/,/g, ''); details = parts.slice(0, -1).join(parts.length > 2 && line.includes('\t') ? '\t' : ' '); const amount = parseInt(amountStr); if (isNaN(amount)) { parseErrors.push(`L${index + 1}: Amount NaN ('${parts[parts.length - 1]}') for "${details}"`); return; } if (amount < 0) { parseErrors.push(`L${index + 1}: Amount negative (${amount}) for "${details}"`); return; } originalItemsUnsorted.push({ details: details, amount: amount, originalIndex: index }); }); if (parseErrors.length > 0) { statusAreaDiv.innerHTML = `<span class="error">Table Data Parse Errors:</span>\n${parseErrors.join('\n')}`; document.getElementById('allocationResults').innerHTML = ''; return; } if (originalItemsUnsorted.length === 0) { statusAreaDiv.innerHTML = `<span class="error">Error: No valid items parsed.</span>`; document.getElementById('allocationResults').innerHTML = ''; return; } globalOriginalItems = originalItemsUnsorted;


            // 2. Define Sorting Strategies (24 total)
            const strategies = [
                // ... (Same 24 strategies as v0.1.11) ...
                { name: "Original Input Order", sortFn: (items) => [...items] }, { name: "Amount Ascending", sortFn: (items) => [...items].sort((a, b) => a.amount - b.amount) }, { name: "Amount Descending", sortFn: (items) => [...items].sort((a, b) => b.amount - a.amount) }, { name: "Details Ascending (A-Z)", sortFn: (items) => [...items].sort((a, b) => a.details.localeCompare(b.details)) }, { name: "Details Descending (Z-A)", sortFn: (items) => [...items].sort((a, b) => b.details.localeCompare(a.details)) },
                { name: "Amount Middle-Out (Down/Up)", sortFn: (items) => { const s = [...items].sort((a, b) => a.amount - b.amount), r = [], n = s.length; if (n === 0) return []; const m = Math.floor(n / 2); r.push(s[m]); let l = m - 1, g = m + 1; while (l >= 0 || g < n) { if (l >= 0) r.push(s[l--]); if (g < n) r.push(s[g++]); } return r; }},
                { name: "Amount Middle-Out (Up/Down)", sortFn: (items) => { const s = [...items].sort((a, b) => a.amount - b.amount), r = [], n = s.length; if (n === 0) return []; const m = Math.floor(n / 2); r.push(s[m]); let l = m - 1, g = m + 1; while (l >= 0 || g < n) { if (g < n) r.push(s[g++]); if (l >= 0) r.push(s[l--]); } return r; }},
                { name: "Details Middle-Out (Down/Up)", sortFn: (items) => { const s = [...items].sort((a,b)=>a.details.localeCompare(b.details)), r = [], n = s.length; if (n === 0) return []; const m = Math.floor(n / 2); r.push(s[m]); let l = m - 1, g = m + 1; while (l >= 0 || g < n) { if (l >= 0) r.push(s[l--]); if (g < n) r.push(s[g++]); } return r; }},
                { name: "Details Middle-Out (Up/Down)", sortFn: (items) => { const s = [...items].sort((a,b)=>a.details.localeCompare(b.details)), r = [], n = s.length; if (n === 0) return []; const m = Math.floor(n / 2); r.push(s[m]); let l = m - 1, g = m + 1; while (l >= 0 || g < n) { if (g < n) r.push(s[g++]); if (l >= 0) r.push(s[l--]); } return r; }},
                { name: "Amount Outside-In (Interleaved)", sortFn: (items) => { const s = [...items].sort((a,b)=>a.amount - b.amount), r = []; let l = 0, g = s.length - 1; while(l <= g) { r.push(s[l++]); if (l <= g) { r.push(s[g--]); } } return r; }},
                { name: "Details Outside-In (Interleaved)", sortFn: (items) => { const s = [...items].sort((a,b)=>a.details.localeCompare(b.details)), r = []; let l = 0, g = s.length - 1; while(l <= g) { r.push(s[l++]); if (l <= g) { r.push(s[g--]); } } return r; }},
                { name: "Amount Asc, Details Asc (Tiebreaker)", sortFn: (items) => [...items].sort((a, b) => a.amount - b.amount || a.details.localeCompare(b.details)) },
                { name: "Amount Asc, Index Asc (Tiebreaker)", sortFn: (items) => [...items].sort((a, b) => a.amount - b.amount || a.originalIndex - b.originalIndex) }, { name: "Amount Asc, Index Desc (Tiebreaker)", sortFn: (items) => [...items].sort((a, b) => a.amount - b.amount || b.originalIndex - a.originalIndex) }, { name: "Amount Desc, Index Asc (Tiebreaker)", sortFn: (items) => [...items].sort((a, b) => b.amount - a.amount || a.originalIndex - b.originalIndex) }, { name: "Amount Desc, Index Desc (Tiebreaker)", sortFn: (items) => [...items].sort((a, b) => b.amount - a.amount || b.originalIndex - a.originalIndex) },
                { name: "Amount by Last Digit", sortFn: (items) => [...items].sort((a, b) => (a.amount % 10) - (b.amount % 10) || a.amount - b.amount) },
                { name: "Amount by First Digit", sortFn: (items) => { const fd = (n) => n === 0 ? 0 : parseInt(String(n)[0]); return [...items].sort((a, b) => fd(a.amount) - fd(b.amount) || a.amount - b.amount); }},
                { name: "Amount Asc (Process Thirds S->L->M)", sortFn: (items) => { const s = [...items].sort((a,b)=>a.amount-b.amount), n=s.length, t=Math.ceil(n/3); return [...s.slice(0,t), ...s.slice(n-t), ...s.slice(t,n-t)]; }},
                { name: "Amount Desc (Process Thirds L->S->M)", sortFn: (items) => { const s = [...items].sort((a,b)=>b.amount-a.amount), n=s.length, t=Math.ceil(n/3); return [...s.slice(0,t), ...s.slice(n-t), ...s.slice(t,n-t)]; }},
                { name: "Amount Asc (Interleave by 3: 0,3.. 1,4.. 2,5..)", sortFn: (items) => { const s=[...items].sort((a,b)=>a.amount-b.amount), r=[], n=s.length; for(let k=0;k<3;k++) for(let i=k;i<n;i+=3) r.push(s[i]); return r; }},
                { name: "Amount Desc (Interleave by 3: 0,3.. 1,4.. 2,5..)", sortFn: (items) => { const s=[...items].sort((a,b)=>b.amount-a.amount), r=[], n=s.length; for(let k=0;k<3;k++) for(let i=k;i<n;i+=3) r.push(s[i]); return r; }},
                { name: "Amount Deviation from Avg (Closest First)", sortFn: (items) => { if(items.length===0) return []; const avg = items.reduce((sum,i)=>sum+i.amount,0)/items.length; return [...items].sort((a,b)=>Math.abs(a.amount-avg)-Math.abs(b.amount-avg)); }},
                { name: "Amount Deviation from Avg (Furthest First)", sortFn: (items) => { if(items.length===0) return []; const avg = items.reduce((sum,i)=>sum+i.amount,0)/items.length; return [...items].sort((a,b)=>Math.abs(b.amount-avg)-Math.abs(a.amount-avg)); }},
            ];

            let localStrategyResults = []; // Use local variable during processing
            let firstSuccessfulResult = null;

            // 3. Iterate Through ALL Strategies
            statusAreaDiv.innerHTML = `Running allocation for all ${strategies.length} strategies...`;
            for (const strategy of strategies) {
                console.log(`--- Running Strategy: ${strategy.name} ---`);

                const currentItemsOrdered = strategy.sortFn(originalItemsUnsorted).map((item, index) => ({ ...item, index: index }));
                const result = runAllocationProcess(currentItemsOrdered, [...userLpdCombination], maxSlots); // Pass copy of LPDs

                let hasAllocationError = false; let firstErrorMessage = "";
                if (result && result.itemAllocations) { for (const alloc of result.itemAllocations) { if (alloc.error) { hasAllocationError = true; if (!firstErrorMessage) firstErrorMessage = alloc.error; break; } } }
                else { hasAllocationError = true; firstErrorMessage = "Invalid result structure"; }
                if (hasAllocationError) console.warn(`--- Strategy ${strategy.name}: Error(s). First: "${firstErrorMessage}"`);

                const maxVariation = calculateMaxVariation(currentItemsOrdered, result.itemAllocations);
                // ** NEW ** Calculate Average Variation
                const avgVariation = calculateAverageVariation(currentItemsOrdered, result.itemAllocations);
                const meetsLimit = !hasAllocationError && maxVariation <= REPROCESS_VARIATION_LIMIT;

                console.log(`--- Strategy ${strategy.name}: MaxVar=${(maxVariation * 100).toFixed(2)}%, AvgVar=${(avgVariation * 100).toFixed(2)}%, HasError=${hasAllocationError}, MeetsLimit=${meetsLimit}`);

                // Store results including average variation
                const resultEntry = {
                    strategyName: strategy.name, itemsUsed: currentItemsOrdered, resultData: result,
                    maxVariation: maxVariation, avgVariation: avgVariation, // Store avg variation
                    meetsLimit: meetsLimit, hasAllocationError: hasAllocationError
                };
                localStrategyResults.push(resultEntry);

                if (meetsLimit && !firstSuccessfulResult) { firstSuccessfulResult = resultEntry; console.log(`--- Found first successful strategy: ${strategy.name} ---`); }
            } // End strategy loop

            // Store results globally AFTER all runs are complete
            globalStrategyResults = localStrategyResults;


            // 4. Select Final Result to Display (Default)
            let finalResultToShow = null;
            let statusMessage = "";
            if (firstSuccessfulResult) {
                finalResultToShow = firstSuccessfulResult;
                statusMessage = `<span class="success">Default view: First successful strategy: ${finalResultToShow.strategyName}</span> (Met limit & no errors). Click strategy name below to view others.`;
            } else {
                 if (globalStrategyResults.length > 0) {
                     const errorFreeStrategies = globalStrategyResults.filter(r => !r.hasAllocationError);
                     if (errorFreeStrategies.length > 0) {
                         let bestErrorFree = errorFreeStrategies.reduce((best, current) => { if (current.maxVariation === Infinity && best.maxVariation !== Infinity) return best; if (best.maxVariation === Infinity && current.maxVariation !== Infinity) return current; return current.maxVariation < best.maxVariation ? current : best; }, errorFreeStrategies[0]);
                         finalResultToShow = bestErrorFree;
                         const variationStr = finalResultToShow.maxVariation === Infinity ? 'Infinity' : `${(finalResultToShow.maxVariation * 100).toFixed(1)}%`;
                         statusMessage = `<span class="warning">Default view: No strategy met limit without errors. Showing error-free strategy with lowest max variation:</span> <span class="info">${finalResultToShow.strategyName}</span> (${variationStr}). Click below to view others.`;
                     } else {
                          let bestWithError = globalStrategyResults.reduce((best, current) => { if (current.maxVariation === Infinity && best.maxVariation !== Infinity) return best; if (best.maxVariation === Infinity && current.maxVariation !== Infinity) return current; return current.maxVariation < best.maxVariation ? current : best; }, globalStrategyResults[0]);
                          finalResultToShow = bestWithError;
                          const variationStr = finalResultToShow.maxVariation === Infinity ? 'Infinity' : `${(finalResultToShow.maxVariation * 100).toFixed(1)}%`;
                          statusMessage = `<span class="error">Default view: All strategies had errors. Showing strategy with lowest max variation:</span> <span class="info">${finalResultToShow.strategyName}</span> (${variationStr}). Click below to view others. Check inputs.`;
                     }
                 } else { statusMessage = `<span class="error">Error: No strategy results generated.</span>`; document.getElementById('allocationResults').innerHTML = ''; return; }
            }
            statusAreaDiv.innerHTML = statusMessage;


            // 5. Display Interactive Strategy Comparison Summary Table
            let comparisonHTML = `<div class="comparison-title">--- Strategy Comparison Summary (Click Name to View Details) ---</div>`;
            comparisonHTML += `<table id="comparisonTable">`;
            // Add Header for Average Variation
            comparisonHTML += `<thead><tr><th>Strategy</th><th>Max Var (%)</th><th>Avg Var (%)</th><th>Outcome</th></tr></thead>`;
            comparisonHTML += `<tbody>`;

            globalStrategyResults.forEach(res => {
                let maxVarStr = "";
                if (res.maxVariation === Infinity) { maxVarStr = '<span class="violation">Infinity</span>'; }
                else { maxVarStr = (res.maxVariation * 100).toFixed(1) + '%'; if (!res.meetsLimit && !res.hasAllocationError) { maxVarStr = `<span class="warning">${maxVarStr}</span>`; } }

                // Format Average Variation
                let avgVarStr = (res.avgVariation * 100).toFixed(1) + '%';

                let outcomeStr = '';
                if (res.hasAllocationError) { outcomeStr = `<span class="error">Error</span>`; }
                else if (res.meetsLimit) { outcomeStr = `<span class="success">Success</span>`; }
                else { outcomeStr = `<span class="warning">High Var</span>`; }

                const isSelectedStrategy = (finalResultToShow && res.strategyName === finalResultToShow.strategyName);
                let rowClass = '';
                 if (res.hasAllocationError) rowClass = 'strategy-error';
                 if (isSelectedStrategy) rowClass += ' best-effort'; // Append if selected

                comparisonHTML += `<tr class="${rowClass.trim()}">`;
                comparisonHTML += `<td class="strategy-name" onclick="displayStrategyDetails('${encodeURIComponent(res.strategyName)}')">${res.strategyName} ${isSelectedStrategy ? '(Selected)' : ''}</td>`;
                comparisonHTML += `<td>${maxVarStr}</td>`;
                comparisonHTML += `<td>${avgVarStr}</td>`; // Add Average Variation cell
                comparisonHTML += `<td>${outcomeStr}</td>`;
                comparisonHTML += `</tr>`;
            });

            comparisonHTML += `</tbody></table>`;
            strategyComparisonDiv.innerHTML = comparisonHTML;


            // 6. Display Detailed Results for the *Default* Selected Strategy Initially
            if (finalResultToShow) {
                 displayStrategyDetails(encodeURIComponent(finalResultToShow.strategyName));
            } else {
                 document.getElementById('allocationResults').innerHTML = 'No strategy result available to display.';
                 document.getElementById('adjustmentLog').innerHTML = ''; document.getElementById('variationLog').innerHTML = '';
                 document.getElementById('cumulativeUsage').innerHTML = ''; document.getElementById('lpdBreakdown').innerHTML = '';
                 document.getElementById('finalSummaryTableDiv').innerHTML = '';
            }

        } // End allocateAllItems function

    </script>

</body>
</html>