<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>LPD Combination (Exact Sum, Max Freq near Min) & Allocation</title>
    <style>
         /* Basic styling for the page */
         body { font-family: sans-serif; padding: 20px; }
        label { display: block; margin-top: 10px; margin-bottom: 5px; font-weight: bold; }
        textarea { width: 90%; min-height: 150px; margin-bottom: 10px; font-family: monospace; }
        input[type="number"] { padding: 8px; margin-bottom: 10px; width: 120px; }
        button { padding: 10px 15px; cursor: pointer; background-color: #007bff; color: white; border: none; border-radius: 4px; margin-top: 10px; }
        button:hover { background-color: #0056b3; }
        #results, #allocationResults { margin-top: 20px; padding: 15px; border: 1px solid #ccc; background-color: #f9f9f9; white-space: pre-wrap; font-family: monospace; }
        .error { color: red; font-weight: bold; }
        .info { color: blue; }
        .input-group { margin-bottom: 15px; }
        .highlight { background-color: yellow; font-weight: bold; }
        .candidate-section { border-left: 3px solid #ddd; padding-left: 10px; margin-top: 5px; margin-bottom: 5px; } /* Style for candidate log sections */
    </style>
</head>
<body>

    <h1>Find LPD Combination (Exact Sum, Highest Frequency near Min Amount, >=2000) & Allocate</h1>

    <!-- Input fields for user data -->
    <div class="input-group">
        <label for="tableData">Table Data (Details + Amount, one per line):</label>
        <textarea id="tableData" placeholder="Example: Item A	3000 (min amount)
Item C	7500 (freq 8)
..."></textarea>
    </div>
    <div class="input-group">
        <label for="targetSum">Target Sum for LPD Combination (Exact):</label>
        <input type="number" id="targetSum" placeholder="e.g., 36500">
    </div>
    <div class="input-group">
        <label for="combinationSize">Number of Distinct LPDs (>=2000) in Combination:</label>
        <input type="number" id="combinationSize" value="4" min="2">
    </div>
    <div class="input-group">
        <label for="maxSlots">Max Slots per LPD in Allocation:</label>
        <input type="number" id="maxSlots" placeholder="e.g., 3 (blank=unlimited)" min="1">
    </div>
    <div class="input-group">
        <label for="specialNumber">Special Number to Allocate:</label>
        <input type="number" id="specialNumber" placeholder="e.g., 70000">
    </div>
    <button onclick="processAll()">Find Combination & Allocate</button>

    <!-- Output areas -->
    <div id="results">LPD Combination results will appear here...</div>
    <div id="allocationResults">Special Number Allocation results will appear here...</div>


    <script>
        // Global variable to store the best LPD combination found for allocation
        let lastFoundLpdCombination = null;

        // --- CONFIGURATION RULES ---
        // RULE 1: Minimum LPD Value Constraint
        // Only LPD values (Amount / 2) greater than or equal to this are considered valid for combinations.
        const MIN_LPD_VALUE = 2000;
        // RULE 2: Obligatory Candidate Range Constraint
        // One LPD in the final combination must be a valid LPD (>= MIN_LPD_VALUE)
        // whose value is within +/- this range of the *minimum amount* found in the input table.
        const OBLIGATORY_RANGE = 500;
        // --- ---

        // --- Recursive Combination Finder ---
        // Purpose: Finds *one* combination of exactly 'k' distinct LPD values from a given list
        //          that sum up precisely to a specified 'target'.
        // How it works: Uses backtracking. Tries adding an LPD, recursively searches for the rest.
        //               If a path fails or completes incorrectly, it backtracks and tries another LPD.
        //               Returns the first valid combination found, or null.
        // Note: Expects 'lpdValueObjectsToSearch' to be an array of objects { value: number, frequency: number }
        //       but only uses the 'value' for sum calculation and distinctness check.
        //       Frequency is handled externally for selection.
        function findSumCombinationRecursive(lpdValueObjectsToSearch, target, k, startIndex, currentCombinationValues) {
            // Base case: Combination has the required size 'k'
            if (currentCombinationValues.length === k) {
                const currentSum = currentCombinationValues.reduce((sum, item) => sum + item, 0);
                // Check if the sum matches the target exactly (using small tolerance for safety)
                if (Math.abs(currentSum - target) < 0.01) {
                    return [...currentCombinationValues]; // Return a copy of the successful combination
                }
                return null; // Sum does not match
            }
            // Base case: Impossible to form a combination of size 'k' from remaining elements
            if (startIndex >= lpdValueObjectsToSearch.length || currentCombinationValues.length > k || lpdValueObjectsToSearch.length - startIndex < k - currentCombinationValues.length) {
                return null;
            }

            // Explore adding LPDs starting from 'startIndex'
            for (let i = startIndex; i < lpdValueObjectsToSearch.length; i++) {
                const currentLpdValue = lpdValueObjectsToSearch[i].value;
                // Ensure the combination contains distinct LPD values
                if (!currentCombinationValues.includes(currentLpdValue)) {
                    currentCombinationValues.push(currentLpdValue); // Add LPD to current attempt
                    // Recursively search for the remaining 'k-1' LPDs from the next index (i + 1)
                    const result = findSumCombinationRecursive(lpdValueObjectsToSearch, target, k, i + 1, currentCombinationValues);
                    if (result) {
                        return result; // Found a valid combination down this path, return immediately
                    }
                    currentCombinationValues.pop(); // Backtrack: remove the LPD and try the next one in the loop
                }
            }
            return null; // No combination found from this starting state
        }

        // --- Find Closest Sum (Allocation DP) ---
        // Purpose: Given a set of LPDs (from the chosen combination) and a 'specialNumber' target,
        //          find a combination of these LPDs (allowing repetition up to 'maxSlotsPerLpd')
        //          that sums as close as possible to the 'specialNumber'.
        // How it works: Uses dynamic programming (similar to the change-making problem).
        //               Builds a table `dp` where `dp[i]` stores the best way to achieve sum `i`.
        //               'Best' considers minimum LPD count and slot limits.
        //               Finds the reachable sum closest to the target (above or below).
        //               Backtracks to reconstruct the combination.
        // Note: This function is independent of the initial combination finding logic,
        //       it just uses the result provided in `lpdArray`.
        function findClosestSumWithRepetitionAndSlots(lpdArray, target, maxSlotsPerLpd) {
             // Input checks
             if (!lpdArray || lpdArray.length === 0) { return { sum: 0, difference: Math.abs(target), combination: [], error: "No LPDs provided" }; }
             if (target < 0) { return { sum: 0, difference: Math.abs(target), combination: [], error: "Negative target" }; }
             if (maxSlotsPerLpd === null || isNaN(maxSlotsPerLpd) || maxSlotsPerLpd < 1) { maxSlotsPerLpd = Infinity; } // Default to unlimited slots if invalid

             // Prepare LPDs: Unique and sorted
             lpdArray = [...new Set(lpdArray)].sort((a, b) => a - b);
             if (lpdArray.length === 0 || lpdArray[0] <= 0) { return { sum: 0, difference: Math.abs(target), combination: [], error: "Invalid LPDs for allocation" }; }

             // DP setup
             const smallestLpd = lpdArray[0];
             const maxSum = target + smallestLpd -1; // Search range slightly above target
             // dp[i] = { count: min LPDs for sum i, usage: {lpd:count}, lastLpd: number }
             const dp = new Array(maxSum + 1).fill(null);
             dp[0] = { count: 0, usage: {}, lastLpd: null }; // Base case: sum 0

             // Build DP table iteratively
             for (let i = 1; i <= maxSum; i++) {
                 let bestStateForI = null;
                 for (const lpd of lpdArray) {
                     const prevSum = i - lpd;
                     // Check if previous sum is reachable
                     if (prevSum >= 0 && dp[prevSum] !== null) {
                         const prevState = dp[prevSum];
                         const currentLpdUsage = (prevState.usage[lpd] || 0) + 1;
                         // Check slot constraint
                         if (currentLpdUsage <= maxSlotsPerLpd) {
                             const newTotalCount = prevState.count + 1;
                             // Check if this path is better (fewer items)
                             if (bestStateForI === null || newTotalCount < bestStateForI.count) {
                                 const newUsage = { ...prevState.usage, [lpd]: currentLpdUsage };
                                 bestStateForI = { count: newTotalCount, usage: newUsage, lastLpd: lpd };
                             }
                         }
                     }
                 }
                 dp[i] = bestStateForI; // Store best way to reach sum i
             }

             // Find the sum closest to the target among reachable sums
             let minDiff = Infinity; let closestSum = -1; let bestReachableState = null;
             // Search down from target
             for (let i = target; i >= 0; i--) { if (dp[i] !== null) { const diff = target - i; if (diff < minDiff || (diff === minDiff && dp[i].count < bestReachableState.count)) { minDiff = diff; closestSum = i; bestReachableState = dp[i]; } if (diff > minDiff && closestSum !== -1) break; } }
             // Search up from target
             for (let i = target + 1; i <= maxSum; i++) { if (dp[i] !== null) { const diff = i - target; if (diff < minDiff || (diff === minDiff && dp[i].count < bestReachableState.count)) { minDiff = diff; closestSum = i; bestReachableState = dp[i]; } if (diff >= minDiff && closestSum !== -1) break; } }

             // Handle case where target or nearby sums are unreachable
             if (closestSum === -1) { if (target === 0 && dp[0] !== null) { closestSum = 0; minDiff = 0; bestReachableState = dp[0]; } else { closestSum = 0; minDiff = Math.abs(target - 0); bestReachableState = dp[0] || { count: 0, usage: {}, lastLpd: null }; } }

             // Reconstruct the combination by backtracking from the closest sum found
             const combination = []; let currentSum = closestSum; let currentState = bestReachableState; let safetyCounter = 0; const maxLoops = (currentState?.count || 0) + lpdArray.length + 100;
             while (currentSum > 0 && currentState?.lastLpd && safetyCounter < maxLoops) {
                 const usedLpd = currentState.lastLpd; combination.push(usedLpd); const prevSum = currentSum - usedLpd;
                 if (prevSum >= 0 && dp[prevSum] !== null) { currentState = dp[prevSum]; currentSum = prevSum; }
                 else { return { sum: closestSum, difference: minDiff, combination: combination.sort((a,b)=>a-b), error: `Backtracking state missing for ${prevSum}` }; }
                 safetyCounter++;
             }

             // Final checks and return result
             // ... (error checks for backtracking, sum mismatch, slot violations - same as before) ...
             if (safetyCounter >= maxLoops) { return { sum: closestSum, difference: minDiff, combination: combination.sort((a,b)=>a-b), error: "Backtracking limit" }; }
             if (currentSum !== 0 && closestSum !== 0) { return { sum: closestSum, difference: minDiff, combination: combination.sort((a,b)=>a-b), error: `Backtracking incomplete (final sum ${currentSum})` }; }
             const reconstructedSum = combination.reduce((a, b) => a + b, 0);
             if (reconstructedSum !== closestSum) { return { sum: closestSum, difference: minDiff, combination: combination.sort((a,b)=>a-b), error: `Reconstruction mismatch (${reconstructedSum} != ${closestSum})` }; }
             const finalUsageCheck = {}; for(const lpd of combination) { finalUsageCheck[lpd] = (finalUsageCheck[lpd] || 0) + 1; if (finalUsageCheck[lpd] > maxSlotsPerLpd) { return { sum: closestSum, difference: minDiff, combination: combination.sort((a,b)=>a-b), error: `Slot limit violated for LPD ${lpd}` }; } }
             return { sum: closestSum, difference: minDiff, combination: combination.sort((a,b)=>a-b) };
        }


        // --- Main Processing Function ---
        // Orchestrates the entire process: parsing, candidate selection, search, result comparison, and allocation.
        function processAll() {
            // 1. Read and Validate Inputs
            const tableDataInput = document.getElementById('tableData').value.trim();
            const targetSumInput = document.getElementById('targetSum').value;
            const combinationSizeInput = document.getElementById('combinationSize').value;
            const maxSlotsInput = document.getElementById('maxSlots').value;
            const specialNumberInput = document.getElementById('specialNumber').value;
            const resultsDiv = document.getElementById('results');
            const allocationResultsDiv = document.getElementById('allocationResults');

            resultsDiv.innerHTML = `Processing LPD Combination (>= ${MIN_LPD_VALUE}, Exact Sum, Max Freq near Min Amount)...`;
            allocationResultsDiv.innerHTML = 'Waiting for LPD Combination...';
            lastFoundLpdCombination = null; // Reset previous result

            // Basic input validation
             if (!tableDataInput) { resultsDiv.innerHTML = '<span class="error">Error: Table data cannot be empty.</span>'; return; }
            let maxSlots = Infinity;
            if (maxSlotsInput) { maxSlots = parseInt(maxSlotsInput); if (isNaN(maxSlots) || maxSlots < 1) { allocationResultsDiv.innerHTML = '<span class="error">Error: Invalid Max Slots per LPD.</span>'; resultsDiv.innerHTML = '<span class="error">Input Error.</span>'; return; } }
            const exactTargetSum = parseInt(targetSumInput); // RULE 3: The final combination MUST sum exactly to this value.
            const combinationSize = parseInt(combinationSizeInput);
            if (isNaN(exactTargetSum)) { resultsDiv.innerHTML = '<span class="error">Error: Invalid Target Sum.</span>'; return; }
            if (isNaN(combinationSize) || combinationSize < 2) { resultsDiv.innerHTML = `<span class="error">Error: Invalid Number of LPDs (must be >= 2).</span>`; return; }
            const specialNumber = specialNumberInput ? parseInt(specialNumberInput) : null;
             if (specialNumberInput && (isNaN(specialNumber) || specialNumber < 0)) { allocationResultsDiv.innerHTML = '<span class="error">Error: Invalid or negative Special Number.</span>'; resultsDiv.innerHTML = '<span class="error">Input Error.</span>'; return; }


            // 2. Parse Table Data & Find Min Amount
            //    - Reads each line, calculates LPD (Amount / 2).
            //    - Tracks the absolute minimum 'Amount' found.
            //    - Stores frequency of LPDs that meet the MIN_LPD_VALUE constraint.
            const lines = tableDataInput.split('\n');
            const lpdFrequencies = {}; // Stores { lpdValue: frequency } for valid LPDs (>= MIN_LPD_VALUE)
            let parseErrors = [];
            let minAmountFound = Infinity;

            lines.forEach((line, index) => { /* ... parsing logic same as v0.1.15 ... */
                line = line.trim(); if (!line) return;
                let parts = line.split('\t'); if (parts.length < 2) parts = line.split(/\s+/);
                if (parts.length < 2) { parseErrors.push(`L${index + 1}: Cannot split: "${line}"`); return; }
                const amountStr = parts[parts.length - 1]; const amount = parseInt(amountStr);
                if (isNaN(amount)) { parseErrors.push(`L${index + 1}: Amount NaN "${amountStr}"`); return; }
                if (amount <= 0) { parseErrors.push(`L${index + 1}: Amount <=0 "${amount}"`); return; }
                if (amount % 2 !== 0) { parseErrors.push(`L${index + 1}: Amount odd "${amount}"`); return; }
                if (amount < minAmountFound) { minAmountFound = amount; }
                const lpd = amount / 2;
                if (lpd >= MIN_LPD_VALUE) { lpdFrequencies[lpd] = (lpdFrequencies[lpd] || 0) + 1; }
            });

            if (parseErrors.length > 0) { resultsDiv.innerHTML = `<span class="error">Parse Errors:</span>\n${parseErrors.join('\n')}`; allocationResultsDiv.innerHTML = ''; return; }
            if (minAmountFound === Infinity) { resultsDiv.innerHTML = `<span class="error">Error: No valid amounts found.</span>`; allocationResultsDiv.innerHTML = ''; return; }


            // 3. Identify Obligatory Candidate LPDs
            //    - Creates a list of valid LPD objects {value, frequency}.
            //    - Filters this list to find candidates whose 'value' is within OBLIGATORY_RANGE of 'minAmountFound'.
            //    - Sorts candidates by value for consistent processing order.
            //    - RULE 4: At least one LPD in the final combination must be from this candidate list.
            let obligatoryLog = [`Minimum Amount in table: ${minAmountFound}`];
            const uniqueValidLpdListWithFreq = Object.entries(lpdFrequencies)
                                      .map(([lpd, freq]) => ({ value: parseInt(lpd), frequency: freq }));

            const obligatoryCandidates = uniqueValidLpdListWithFreq.filter(lpdObj => {
                 const diff = Math.abs(lpdObj.value - minAmountFound);
                 return diff <= OBLIGATORY_RANGE;
            }).sort((a, b) => a.value - b.value); // Sort candidates by value ASC

            obligatoryLog.push(`Valid LPDs Found (>=${MIN_LPD_VALUE}): [${uniqueValidLpdListWithFreq.map(l=>l.value).sort((a,b)=>a-b).join(', ')}]`);
            obligatoryLog.push(`Found ${obligatoryCandidates.length} candidate LPD(s) within +/- ${OBLIGATORY_RANGE} of Min Amount (${minAmountFound}): [${obligatoryCandidates.map(c=>c.value).join(', ')}]`);

            if (obligatoryCandidates.length === 0) {
                 resultsDiv.innerHTML = `<span class="error">Error: No valid LPD (>= ${MIN_LPD_VALUE}) found within +/- ${OBLIGATORY_RANGE} of the Minimum Amount (${minAmountFound}). Cannot proceed.</span>\n${obligatoryLog.join('\n')}`;
                 allocationResultsDiv.innerHTML = ''; return;
            }

            // 4. Prepare Full LPD List for Searching 'Other' LPDs
            //    - Sorts the full list of valid LPDs by frequency (descending) as a preference
            //      for the recursive search to potentially find high-frequency combinations faster.
            uniqueValidLpdListWithFreq.sort((a, b) => {
                if (b.frequency !== a.frequency) return b.frequency - a.frequency;
                return b.value - a.value; // Value DESC as tie-breaker
            });
            let frequencyLog = [`Valid LPDs Sorted by Frequency (Value(Frequency)): ${uniqueValidLpdListWithFreq.map(l => `${l.value}(${l.frequency})`).join(', ')}`];


            // 5. Search for the Best Combination
            //    - Iterates through each 'obligatoryCandidate'.
            //    - For each candidate, calculates the exact sum needed ('targetForRecursion') for the remaining LPDs.
            //    - Calls the recursive search function ONCE to find if a combination exists for that exact sum,
            //      using the frequency-sorted list (excluding the current candidate).
            //    - If an exact-sum combination is found:
            //        - Calculate its total frequency score.
            //        - Compare it to the best score found so far. Update if the current one is better.
            //    - RULE 5: Select the single combination (among all candidates tried) that sums exactly
            //              to 'exactTargetSum' AND has the highest total frequency score.
            const neededOtherLpds = combinationSize - 1;
            let overallSearchLog = [`--- Obligatory Candidate Selection ---`];
            overallSearchLog.push(...obligatoryLog);
            overallSearchLog.push(`--- Available LPDs ---`);
            overallSearchLog.push(...frequencyLog);
            overallSearchLog.push(`--- Combination Search ---`);
            overallSearchLog.push(`Searching for combination of size ${combinationSize} summing EXACTLY to ${exactTargetSum}, using each candidate LPD near minimum amount...`);

            // Variables to store the best solution found so far
            let bestCombinationFound = null;
            let bestCombinationFrequencyScore = -1;

            // Helper function to calculate frequency score
            function getFrequencyScore(combination) { /* ... same as v0.1.14 ... */
                let score = 0; for (const lpdValue of combination) { score += (lpdFrequencies[lpdValue] || 0); } return score;
            }

            // --- Search Loop ---
            for (const currentObligatoryCandidate of obligatoryCandidates) {
                const currentObligatoryLpdValue = currentObligatoryCandidate.value;
                overallSearchLog.push(`<div class="candidate-section">=== Trying with Obligatory Candidate: ${currentObligatoryLpdValue} ===`);

                const searchLpdList = uniqueValidLpdListWithFreq.filter(lpdObj => lpdObj.value !== currentObligatoryLpdValue);

                if (neededOtherLpds > 0 && searchLpdList.length < neededOtherLpds) {
                    overallSearchLog.push(`   Skipping: Not enough other LPDs available.`);
                    overallSearchLog.push(`</div>`); continue;
                }

                const targetForRecursion = exactTargetSum - currentObligatoryLpdValue;
                overallSearchLog.push(`   Target sum for remaining ${neededOtherLpds} LPDs: ${exactTargetSum} - ${currentObligatoryLpdValue} = ${targetForRecursion}`);

                let foundKMinus1Combination = null;
                if (targetForRecursion < 0 && neededOtherLpds > 0) {
                    overallSearchLog.push(`   Skipping: Target for remaining LPDs is negative.`);
                } else if (neededOtherLpds >= 0) { // Allows neededOtherLpds = 0 (combo size 1)
                    // Call recursive search ONCE for the exact target
                    foundKMinus1Combination = findSumCombinationRecursive(searchLpdList, targetForRecursion, neededOtherLpds, 0, []);
                }

                if (foundKMinus1Combination !== null) {
                    // Found a combination that sums EXACTLY to the target
                    const currentFullCombination = [...foundKMinus1Combination, currentObligatoryLpdValue].sort((a,b)=>a-b);
                    const currentFrequencyScore = getFrequencyScore(currentFullCombination);

                    overallSearchLog.push(`   <span class="highlight">Found Exact Sum Combination: [${currentFullCombination.join(', ')}] (Sum: ${exactTargetSum}, Freq Score: ${currentFrequencyScore})</span>`);

                    // Compare frequency score with the best found so far
                    if (bestCombinationFound === null || currentFrequencyScore > bestCombinationFrequencyScore) {
                        overallSearchLog.push(`   <span class="info">   ** New Best Combination Found (Higher Freq Score) **</span>`);
                        bestCombinationFound = currentFullCombination;
                        bestCombinationFrequencyScore = currentFrequencyScore;
                    }
                } else {
                     overallSearchLog.push(`   -> No combination found including ${currentObligatoryLpdValue} that sums exactly to ${exactTargetSum}.`);
                }
                 overallSearchLog.push(`</div>`); // Close candidate section
            } // End outer obligatory candidate loop


            // 6. Display Results and Allocate Special Number (if applicable)
            //    - Selects the 'bestCombinationFound' (highest frequency score).
            //    - Displays the details and logs.
            //    - If a best combination exists, proceed to the allocation step using that combination.
            lastFoundLpdCombination = bestCombinationFound; // Assign the overall best to the global variable

            if (lastFoundLpdCombination) {
                // Best Combination found!
                 resultsDiv.innerHTML = overallSearchLog.join('\n')
                                 + `\n\n<span class="highlight">Best LPD Combination Found (${combinationSize} LPDs): [${lastFoundLpdCombination.join(', ')}]</span>`
                                 + `\n(Chosen for highest frequency score among combinations summing exactly to ${exactTargetSum})`
                                 + `\nAchieved Sum: ${exactTargetSum}`
                                 + `\nTotal Frequency Score: ${bestCombinationFrequencyScore}`;

                // Proceed to Allocation
                 if (specialNumber !== null) {
                     let maxSlotsDisplay = (maxSlots === Infinity) ? "Unlimited" : maxSlots;
                    allocationResultsDiv.innerHTML = `Allocating Special Number: ${specialNumber}\nUsing Best Found LPDs: [${lastFoundLpdCombination.join(', ')}]\nMax Slots per LPD: ${maxSlotsDisplay}...`;
                    // Call the allocation function (code unchanged)
                    const allocation = findClosestSumWithRepetitionAndSlots(lastFoundLpdCombination, specialNumber, maxSlots);
                    // Display allocation results (code unchanged)
                    let allocMsg = `--- Allocation Result ---\n`;
                    allocMsg += `Target Special Number: ${specialNumber}\n`;
                    allocMsg += `Using LPDs (>=${MIN_LPD_VALUE}): [${lastFoundLpdCombination.join(', ')}]\n`;
                    allocMsg += `Max Slots per LPD: ${maxSlotsDisplay}\n\n`;
                    if (allocation.error) {
                         allocMsg += `<span class="error">Allocation Error: ${allocation.error}</span>\n`;
                         allocMsg += `Closest Sum Found (before error): ${allocation.sum}\nDifference: ${allocation.difference}`;
                         if(allocation.combination && allocation.combination.length > 0) { allocMsg += `\nPartial/Incomplete Combination: [${allocation.combination.sort((a,b)=>a-b).join(', ')}]`; }
                    } else if (allocation.sum !== undefined) {
                         allocMsg += `<span class="highlight">Closest Achievable Sum: ${allocation.sum}</span>\n`;
                         allocMsg += `(Difference from Special Number: ${allocation.difference})\n`;
                         allocMsg += `Achieved with combination (${allocation.combination.length} items): [${allocation.combination.join(', ')}]`;
                         const usageCounts = {}; allocation.combination.forEach(l => usageCounts[l] = (usageCounts[l] || 0) + 1);
                         allocMsg += `\nUsage Counts: { ${Object.entries(usageCounts).map(([lpd, count]) => `"${lpd}": ${count}`).join(', ')} }`;
                    } else {
                         allocMsg += "<span class='error'>Could not determine allocation result.</span>";
                    }
                    allocationResultsDiv.innerHTML = allocMsg;
                } else {
                    allocationResultsDiv.innerHTML = "No Special Number provided, skipping allocation step.";
                }

            } else {
                // Failure: No combination found matching exact sum after trying all candidates
                 resultsDiv.innerHTML = overallSearchLog.join('\n')
                                    + `\n\n<span class="error">No combination of ${combinationSize} distinct LPDs (>=${MIN_LPD_VALUE}, including one near min amount ${minAmountFound}) found summing EXACTLY to ${exactTargetSum} after trying all valid candidates.</span>`;
                 allocationResultsDiv.innerHTML = "Cannot allocate Special Number as no suitable LPD combination was found.";
            }
        }
    </script>

</body>
</html>