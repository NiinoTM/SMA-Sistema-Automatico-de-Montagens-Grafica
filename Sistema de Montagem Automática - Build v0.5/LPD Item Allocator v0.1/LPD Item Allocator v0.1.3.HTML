<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>LPD Item Allocator (Cumulative Slots - Fill All)</title>
    <style>
         /* Basic styling */
         body { font-family: sans-serif; padding: 20px; }
        label { display: block; margin-top: 10px; margin-bottom: 5px; font-weight: bold; }
        textarea { width: 90%; min-height: 150px; margin-bottom: 10px; font-family: monospace; }
        input[type="number"], input[type="text"] { padding: 8px; margin-bottom: 10px; width: 300px; }
        button { padding: 10px 15px; cursor: pointer; background-color: #28a745; color: white; border: none; border-radius: 4px; margin-top: 10px; }
        button:hover { background-color: #218838; }
        #allocationResults, #cumulativeUsage, #adjustmentLog, #lpdBreakdown, #lpdDifferenceBreakdown { margin-top: 20px; padding: 15px; border: 1px solid #ccc; background-color: #f9f9f9; white-space: pre-wrap; font-family: monospace; } /* Added lpdDifferenceBreakdown */
        .error { color: red; font-weight: bold; }
        .info { color: blue; }
        .warning { color: orange; }
        .positive-diff { color: #dc3545; } /* Red for positive difference (sum > target) */
        .negative-diff { color: #198754; } /* Green for negative difference (sum < target) */
        .zero-diff { color: #6c757d; }    /* Grey for zero difference */
        .input-group { margin-bottom: 15px; }
        .highlight { background-color: #cff4fc; font-weight: bold; border: 1px solid #9eeaf9;}
        .item-allocation, .adjustment-step, .lpd-section { border-top: 1px dashed #aaa; margin-top: 10px; padding-top: 10px;}
        .usage-summary, .lpd-section-title { margin-top: 15px; font-weight: bold; }
        .lpd-item-list { margin-left: 20px; list-style-type: none; padding-left: 0;} /* Remove bullets for cleaner look */
        .lpd-item-list li { margin-bottom: 3px; }
        .lpd-total { margin-top: 5px; font-style: italic; padding-left: 20px; } /* Indent total */

    </style>
</head>
<body>

    <h1>LPD Item Allocator (Fill All Cumulative Slots with Min Variation Impact)</h1>
    <p>Allocates items using provided LPDs, attempting to use all available slots (if finite limit set) by adding LPDs with the least impact on individual item variation.</p>

    <!-- Input fields -->
    <div class="input-group">
        <label for="tableData">Table Data (Details + Amount, one per line):</label>
        <textarea id="tableData" placeholder="Example:
Chimichurri	70000
Louro Folhas	40000
..."></textarea>
    </div>
     <div class="input-group">
        <label for="lpdCombinationInput">LPD Combination (e.g., [3000, 7500, 10000, 16000]):</label>
        <input type="text" id="lpdCombinationInput" placeholder="[3000, 7500, 10000, 16000]">
    </div>
    <div class="input-group">
        <label for="maxSlots">Max Slots per LPD (Cumulative):</label>
        <input type="number" id="maxSlots" placeholder="e.g., 3 (blank=unlimited)" min="1" style="width: 120px;">
    </div>

    <button onclick="allocateAllItems()">Allocate Items & Fill Slots</button>

    <!-- Output area -->
    <div id="allocationResults">Item Allocation results (after adjustments) will appear here...</div>
    <div id="adjustmentLog">Slot Filling Adjustment Log will appear here...</div>
    <div id="cumulativeUsage">Cumulative LPD usage will appear here...</div>
    <div id="lpdBreakdown">LPD Usage Breakdown by Item will appear here...</div>
    <div id="lpdDifferenceBreakdown">LPD Allocation Difference by Item will appear here...</div> <!-- New Output Div -->


    <script>
        // --- CONFIGURATION RULE ---
        const MIN_LPD_VALUE_ALLOC = 0;

        // --- Find Closest Sum (Allocation DP) ---
        // Finds combination closest to target using LPDs, respecting CURRENT remaining slots.
        // Returns signed difference (sum - target)
        function findClosestSumWithRepetitionAndSlots(lpdArray, target, remainingSlotsMap) {
             if (!lpdArray || lpdArray.length === 0) { return { sum: 0, difference: 0 - target, combination: [], error: "No LPDs provided for allocation" }; }
             if (target < 0) { return { sum: 0, difference: 0 - target, combination: [], error: "Target amount cannot be negative" }; }
             lpdArray = [...new Set(lpdArray)].filter(lpd => lpd > 0 && remainingSlotsMap.hasOwnProperty(lpd)).sort((a, b) => a - b);
             if (lpdArray.length === 0) { return { sum: 0, difference: 0 - target, combination: [], error: "LPD list empty or no LPDs have remaining slots" }; }
             const smallestLpd = lpdArray[0]; const maxSum = Math.max(target, 0) + smallestLpd; const dp = new Array(maxSum + 1).fill(null); dp[0] = { count: 0, usage: {}, lastLpd: null };
             for (let i = 1; i <= maxSum; i++) { /* ... DP logic ... */
                 let bestStateForI = null;
                 for (const lpd of lpdArray) {
                     const prevSum = i - lpd;
                     if (prevSum >= 0 && dp[prevSum] !== null) {
                         const prevState = dp[prevSum]; const currentLpdUsageInThisPath = (prevState.usage[lpd] || 0) + 1;
                         const slotsAvailable = remainingSlotsMap[lpd];
                         if (currentLpdUsageInThisPath <= slotsAvailable) {
                             const newTotalCount = prevState.count + 1;
                             if (bestStateForI === null || newTotalCount < bestStateForI.count) { const newUsage = { ...prevState.usage, [lpd]: currentLpdUsageInThisPath }; bestStateForI = { count: newTotalCount, usage: newUsage, lastLpd: lpd }; }
                         } } } dp[i] = bestStateForI;
             }
             let minAbsDiff = Infinity; let closestSum = -1; let bestReachableState = null;
             // Search down and up for minimum *absolute* difference, prioritizing fewer items on ties
             for (let i = target; i >= 0; i--) { if (dp[i] !== null) { const diff = Math.abs(target - i); if (diff < minAbsDiff || (diff === minAbsDiff && dp[i].count < bestReachableState.count)) { minAbsDiff = diff; closestSum = i; bestReachableState = dp[i]; } if (diff > minAbsDiff && closestSum !== -1) break; } }
             for (let i = target + 1; i <= maxSum; i++) { if (dp[i] !== null) { const diff = Math.abs(i - target); if (diff < minAbsDiff || (diff === minAbsDiff && dp[i].count < bestReachableState.count)) { minAbsDiff = diff; closestSum = i; bestReachableState = dp[i]; } if (diff >= minAbsDiff && closestSum !== -1) break; } } // Use >= to stop early if diff increases or stays same
             // Handle unreachable cases
             if (closestSum === -1) { if (target === 0 && dp[0] !== null) { closestSum = 0; bestReachableState = dp[0]; } else { closestSum = 0; bestReachableState = dp[0] || { count: 0, usage: {}, lastLpd: null }; } }
             const combination = []; let currentSum = closestSum; let currentState = bestReachableState; let safetyCounter = 0; const maxLoops = (currentState?.count || 0) + lpdArray.length + 100;
             while (currentSum > 0 && currentState?.lastLpd && safetyCounter < maxLoops) { /* ... backtracking ... */
                 const usedLpd = currentState.lastLpd; combination.push(usedLpd); const prevSum = currentSum - usedLpd;
                 if (prevSum >= 0 && dp[prevSum] !== null) { currentState = dp[prevSum]; currentSum = prevSum; }
                 else { return { sum: closestSum, difference: closestSum - target, combination: combination.sort((a,b)=>a-b), error: `Backtracking state missing for ${prevSum}` }; }
                 safetyCounter++;
             }
             /* ... Final checks ... */
              if (safetyCounter >= maxLoops) { return { sum: closestSum, difference: closestSum - target, combination: combination.sort((a,b)=>a-b), error: "Backtracking limit" }; }
             if (currentSum !== 0 && closestSum !== 0) { return { sum: closestSum, difference: closestSum - target, combination: combination.sort((a,b)=>a-b), error: `Backtracking incomplete (final sum ${currentSum})` }; }
             const reconstructedSum = combination.reduce((a, b) => a + b, 0);
             if (reconstructedSum !== closestSum) { return { sum: closestSum, difference: closestSum - target, combination: combination.sort((a,b)=>a-b), error: `Reconstruction mismatch (${reconstructedSum} != ${closestSum})` }; }
             const finalUsageCheck = {}; for(const lpd of combination) { finalUsageCheck[lpd] = (finalUsageCheck[lpd] || 0) + 1; if (finalUsageCheck[lpd] > remainingSlotsMap[lpd]) { return { sum: closestSum, difference: closestSum - target, combination: combination.sort((a,b)=>a-b), error: `Slot limit violated for LPD ${lpd} during reconstruction` }; } }

             // Return signed difference (sum - target)
             const finalDifference = closestSum - target;
             return { sum: closestSum, difference: finalDifference, combination: combination.sort((a,b)=>a-b) };
        }


        // --- Main Processing Function for Allocator ---
        function allocateAllItems() {
            // 1. Read and Validate Inputs
            const tableDataInput = document.getElementById('tableData').value.trim();
            const lpdCombinationInput = document.getElementById('lpdCombinationInput').value.trim();
            const maxSlotsInput = document.getElementById('maxSlots').value;
            const allocationResultsDiv = document.getElementById('allocationResults');
            const cumulativeUsageDiv = document.getElementById('cumulativeUsage');
            const adjustmentLogDiv = document.getElementById('adjustmentLog');
            const lpdBreakdownDiv = document.getElementById('lpdBreakdown');
            const lpdDifferenceBreakdownDiv = document.getElementById('lpdDifferenceBreakdown'); // Get new div

            allocationResultsDiv.innerHTML = `Processing item allocations...`;
            cumulativeUsageDiv.innerHTML = '';
            adjustmentLogDiv.innerHTML = '';
            lpdBreakdownDiv.innerHTML = '';
            lpdDifferenceBreakdownDiv.innerHTML = ''; // Clear previous diff breakdown

            if (!tableDataInput) { allocationResultsDiv.innerHTML = '<span class="error">Error: Table data cannot be empty.</span>'; return; }
            if (!lpdCombinationInput) { allocationResultsDiv.innerHTML = '<span class="error">Error: LPD Combination input cannot be empty.</span>'; return; }

            let maxSlots = Infinity; let maxSlotsIsFinite = false;
            if (maxSlotsInput) { maxSlots = parseInt(maxSlotsInput); if (isNaN(maxSlots) || maxSlots < 1) { allocationResultsDiv.innerHTML = '<span class="error">Invalid Max Slots per LPD.</span>'; return; } maxSlotsIsFinite = true; }
            const maxSlotsDisplay = maxSlotsIsFinite ? maxSlots : "Unlimited";

            // 2. Parse User-Provided LPD Combination
            let userLpdCombination;
            try { /* ... parsing logic ... */
                 userLpdCombination = JSON.parse(lpdCombinationInput.replace(/\s/g, ''));
                 if (!Array.isArray(userLpdCombination)) { throw new Error("Input is not an array."); }
                 if (!userLpdCombination.every(item => typeof item === 'number' && item > 0)) { throw new Error("Array must contain only positive numbers."); }
                 if (userLpdCombination.length === 0) { throw new Error("LPD Combination cannot be empty."); }
                 userLpdCombination = [...new Set(userLpdCombination)];
             } catch (e) { allocationResultsDiv.innerHTML = `<span class="error">Error parsing LPD Combination input: ${e.message}</span>`; return; }

            // 3. Parse Table Data
            const lines = tableDataInput.split('\n'); const originalItems = []; let parseErrors = [];
            lines.forEach((line, index) => { /* ... parsing logic ... */
                 line = line.trim(); if (!line) return;
                 let parts = line.split('\t'); let details = ''; if (parts.length < 2) { parts = line.split(/\s+/); }
                 if (parts.length < 2) { parseErrors.push(`L${index + 1}: Cannot split: "${line}"`); return; }
                 const amountStr = parts[parts.length - 1]; details = parts.slice(0, -1).join(parts.length > 2 ? ' ' : ''); const amount = parseInt(amountStr);
                 if (isNaN(amount)) { parseErrors.push(`L${index + 1}: Amount NaN "${amountStr}" for "${details}"`); return; }
                 if (amount < 0) { parseErrors.push(`L${index + 1}: Amount negative "${amount}" for "${details}"`); return; }
                 originalItems.push({ details: details, amount: amount, index: index });
            });
            if (parseErrors.length > 0) { allocationResultsDiv.innerHTML = `<span class="error">Table Data Parse Errors:</span>\n${parseErrors.join('\n')}`; return; }
            if (originalItems.length === 0) { allocationResultsDiv.innerHTML = `<span class="error">Error: No items parsed.</span>`; return; }

            // 4. Initialize Remaining Slots & Allocation Storage
            const remainingSlots = {};
            userLpdCombination.forEach(lpd => { remainingSlots[lpd] = maxSlots; });
            const itemAllocations = new Array(originalItems.length); // Stores { sum, difference (signed), combination, error, finalUsageCounts? }

            // --- PASS 1: Initial Allocation ---
            let pass1CumulativeUsage = {}; userLpdCombination.forEach(lpd => { pass1CumulativeUsage[lpd] = 0; });
            originalItems.forEach((item, i) => {
                 const initialRemaining = {...remainingSlots}; // Pass a copy for this item's initial allocation
                 const allocation = findClosestSumWithRepetitionAndSlots([...userLpdCombination], item.amount, initialRemaining);
                 itemAllocations[i] = allocation;
                 if (!allocation.error && allocation.combination.length > 0) {
                     allocation.combination.forEach(lpd => { /* update remainingSlots & pass1CumulativeUsage */
                         if (remainingSlots[lpd] !== Infinity) { if (remainingSlots[lpd] > 0) { remainingSlots[lpd]--; } else { console.error(`Slot issue during Pass 1 for LPD ${lpd}`); } }
                         pass1CumulativeUsage[lpd]++;
                     });
                 }
            });

            // --- PASS 2: Slot Filling Adjustment ---
            let adjustmentLogHTML = `--- Pass 2: Slot Filling Adjustments (Target Slots: ${maxSlotsDisplay}) ---`;
            if (maxSlotsIsFinite) {
                adjustmentLogHTML += `\nInitial Remaining Slots after Pass 1:\n${JSON.stringify(remainingSlots, null, 2)}`;
                let totalRemaining = Object.values(remainingSlots).reduce((sum, count) => sum + count, 0);
                adjustmentLogHTML += `\nTotal Remaining Slots: ${totalRemaining}`;
                let adjustmentSafetyCounter = 0; const maxAdjustments = totalRemaining + originalItems.length * 2; // Increased safety limit slightly
                while (totalRemaining > 0 && adjustmentSafetyCounter < maxAdjustments) {
                    adjustmentSafetyCounter++; let bestMove = { lpdToAdd: null, itemIndex: -1, minImpact: Infinity };
                    for (const lpd of userLpdCombination) { /* find best move */
                        if (remainingSlots[lpd] > 0) {
                            for (let i = 0; i < itemAllocations.length; i++) {
                                const currentAlloc = itemAllocations[i]; if (currentAlloc.error) continue;
                                const originalAmount = originalItems[i].amount; const currentSum = currentAlloc.sum;
                                const currentAbsDifference = Math.abs(currentAlloc.difference); // Use abs diff for impact calc
                                const newSum = currentSum + lpd; const newAbsDifference = Math.abs(newSum - originalAmount); const impact = newAbsDifference - currentAbsDifference;
                                if (impact < bestMove.minImpact) { bestMove = { lpdToAdd: lpd, itemIndex: i, minImpact: impact }; }
                            } } }
                    if (bestMove.lpdToAdd !== null) { /* apply best move */
                         const lpd = bestMove.lpdToAdd; const itemIdx = bestMove.itemIndex;
                         adjustmentLogHTML += `<div class="adjustment-step">Step ${adjustmentSafetyCounter}: Adding LPD <span class="info">${lpd}</span> to Item ${itemIdx + 1} ('${originalItems[itemIdx].details}')`;
                         adjustmentLogHTML += ` (Impact on Abs Diff: ${bestMove.minImpact >= 0 ? '+' : ''}${bestMove.minImpact.toFixed(0)})`;
                         itemAllocations[itemIdx].combination.push(lpd); itemAllocations[itemIdx].combination.sort((a,b)=>a-b);
                         itemAllocations[itemIdx].sum += lpd;
                         itemAllocations[itemIdx].difference = itemAllocations[itemIdx].sum - originalItems[itemIdx].amount; // Recalculate signed difference
                         remainingSlots[lpd]--; totalRemaining--; pass1CumulativeUsage[lpd]++;
                         adjustmentLogHTML += `\n   -> New Sum: ${itemAllocations[itemIdx].sum}, New Signed Diff: ${itemAllocations[itemIdx].difference.toFixed(0)}, Slots Remaining for ${lpd}: ${remainingSlots[lpd]}</div>`;
                    } else { adjustmentLogHTML += `\n<span class="warning">Stopped adjustments: No beneficial move found. ${totalRemaining} slots may remain unused.</span>`; break; }
                }
                if (adjustmentSafetyCounter >= maxAdjustments) { adjustmentLogHTML += `\n<span class="error">Stopped adjustments due to reaching safety limit (${maxAdjustments}).</span>`; }
            } else { adjustmentLogHTML += `\n(Skipped: Max Slots was set to Unlimited)`; }
            adjustmentLogDiv.innerHTML = adjustmentLogHTML;

            // --- Calculate Final Usage Counts Per Item ---
            itemAllocations.forEach(alloc => {
                alloc.finalUsageCounts = {};
                if (!alloc.error && alloc.combination) {
                    alloc.combination.forEach(lpd => { alloc.finalUsageCounts[lpd] = (alloc.finalUsageCounts[lpd] || 0) + 1; });
                }
            });

            // --- Display Final Allocation Results ---
            let finalAllocationHTML = `--- Final Item Allocations (After Adjustments) ---`;
             originalItems.forEach((item, i) => {
                 finalAllocationHTML += `<div class="item-allocation">`; finalAllocationHTML += `<b>${i+1}. ${item.details}</b> (Target Amount: ${item.amount})\n`; const finalAlloc = itemAllocations[i];
                 if (finalAlloc.error) { finalAllocationHTML += `<span class="error">Allocation Error: ${finalAlloc.error}</span>\n`; }
                 else if (finalAlloc.sum !== undefined) {
                      let diffClass = finalAlloc.difference === 0 ? 'zero-diff' : (finalAlloc.difference > 0 ? 'positive-diff' : 'negative-diff');
                      let diffSign = finalAlloc.difference > 0 ? '+' : '';
                      finalAllocationHTML += `<span class="highlight">Final Achieved Sum: ${finalAlloc.sum}</span> (Final Diff: <span class="${diffClass}">${diffSign}${finalAlloc.difference.toFixed(0)}</span>)\n`;
                      if (finalAlloc.combination.length > 0) {
                          finalAllocationHTML += `   Final Combination (${finalAlloc.combination.length} items): [${finalAlloc.combination.join(', ')}]`;
                          finalAllocationHTML += `\n   Usage Counts: { ${Object.entries(finalAlloc.finalUsageCounts).map(([lpd, count]) => `"${lpd}": ${count}`).join(', ')} }`;
                      } else { finalAllocationHTML += `   (No LPDs needed)`; }
                 } else { finalAllocationHTML += "<span class='error'>Could not determine allocation result.</span>"; } finalAllocationHTML += `</div>`;
             });
             allocationResultsDiv.innerHTML = finalAllocationHTML;

            // --- Display Cumulative Usage Summary ---
            let usageSummaryHTML = `<div class="usage-summary">--- Final Cumulative LPD Usage Summary (Max Slots: ${maxSlotsDisplay}) ---`;
            usageSummaryHTML += "<ul>";
            userLpdCombination.sort((a,b) => a-b).forEach(lpd => { const used = pass1CumulativeUsage[lpd]; const remaining = remainingSlots[lpd]; usageSummaryHTML += `<li>LPD ${lpd}: Used ${used} times`; if (maxSlotsIsFinite) { usageSummaryHTML += `, Remaining Slots: ${remaining}`; if (remaining < 0) { usageSummaryHTML += ` <span class="error">(Error!)</span>`; } else if (remaining > 0) { usageSummaryHTML += ` <span class="warning">(${remaining} Unused)</span>`; } } usageSummaryHTML += `</li>`; });
            usageSummaryHTML += "</ul></div>";
            cumulativeUsageDiv.innerHTML = usageSummaryHTML;

             // --- Build and Display LPD Usage Breakdown by Item ---
             let lpdBreakdownHTML = `<div class="lpd-section-title">--- LPD Usage Breakdown by Item ---</div>`;
             const lpdUsageByItem = new Map();
             userLpdCombination.forEach(lpd => { lpdUsageByItem.set(lpd, []); });
             originalItems.forEach((item, i) => { const finalAlloc = itemAllocations[i]; if (!finalAlloc.error && finalAlloc.finalUsageCounts) { for (const [lpdValueStr, count] of Object.entries(finalAlloc.finalUsageCounts)) { const lpdValue = parseInt(lpdValueStr); if (count > 0 && lpdUsageByItem.has(lpdValue)) { lpdUsageByItem.get(lpdValue).push({ details: item.details, count: count }); } } } });
             const sortedLpdsUsage = [...lpdUsageByItem.keys()].sort((a,b) => a-b);
             sortedLpdsUsage.forEach(lpd => { /* ... generate usage breakdown HTML ... */
                  const itemsUsingLpd = lpdUsageByItem.get(lpd); const totalCountForLpd = itemsUsingLpd.reduce((sum, item) => sum + item.count, 0);
                  lpdBreakdownHTML += `<div class="lpd-section">`; lpdBreakdownHTML += `<span class="lpd-section-title">LPD: ${lpd}</span>`;
                  if (itemsUsingLpd.length > 0) {
                       lpdBreakdownHTML += `<ul class="lpd-item-list">`; itemsUsingLpd.sort((a,b)=>a.details.localeCompare(b.details)).forEach(itemUse => { lpdBreakdownHTML += `<li>${itemUse.details}: ${itemUse.count} time(s)</li>`; }); lpdBreakdownHTML += `</ul>`;
                       lpdBreakdownHTML += `<div class="lpd-total">Total Times Used: ${totalCountForLpd}</div>`;
                  } else { lpdBreakdownHTML += `\n   (Not used in final allocations)`; } lpdBreakdownHTML += `</div>`;
             });
             lpdBreakdownDiv.innerHTML = lpdBreakdownHTML;

             // --- Build and Display LPD Allocation Difference Breakdown ---
             let lpdDiffBreakdownHTML = `<div class="lpd-section-title">--- LPD Allocation Difference by Item ---</div>`;
             const lpdDifferenceByItem = new Map();
             userLpdCombination.forEach(lpd => { lpdDifferenceByItem.set(lpd, []); });
             originalItems.forEach((item, i) => { const finalAlloc = itemAllocations[i]; if (!finalAlloc.error && finalAlloc.combination && finalAlloc.combination.length > 0) { const signedDifference = finalAlloc.difference; const uniqueLpdsUsed = [...new Set(finalAlloc.combination)]; uniqueLpdsUsed.forEach(lpdValue => { if (lpdDifferenceByItem.has(lpdValue)) { lpdDifferenceByItem.get(lpdValue).push({ details: item.details, difference: signedDifference }); } }); } });
             const sortedLpdsDiff = [...lpdDifferenceByItem.keys()].sort((a,b) => a-b);
             sortedLpdsDiff.forEach(lpd => {
                  const itemsWithDiff = lpdDifferenceByItem.get(lpd);
                  lpdDiffBreakdownHTML += `<div class="lpd-section">`; lpdDiffBreakdownHTML += `<span class="lpd-section-title">SLOT ${lpd}</span>`; // Changed title
                  if (itemsWithDiff.length > 0) {
                       lpdDiffBreakdownHTML += `<ul class="lpd-item-list">`; itemsWithDiff.sort((a, b) => a.details.localeCompare(b.details)); // Sort items alphabetically
                       let totalDiffForLpd = 0; // Calculate total difference for this LPD
                       itemsWithDiff.forEach(itemDiff => {
                            const diffClass = itemDiff.difference === 0 ? 'zero-diff' : (itemDiff.difference > 0 ? 'positive-diff' : 'negative-diff');
                            const diffSign = itemDiff.difference > 0 ? '+' : '';
                            totalDiffForLpd += itemDiff.difference; // Sum the signed difference
                            // Use non-breaking spaces or tabs for alignment if needed, but CSS might be better
                            lpdDiffBreakdownHTML += `<li>${itemDiff.details.padEnd(30, ' ')} <span class="${diffClass}">${diffSign}${itemDiff.difference.toFixed(0)}</span></li>`;
                       });
                       lpdDiffBreakdownHTML += `</ul>`;
                       // Display Total Difference for this LPD
                       const totalDiffClass = totalDiffForLpd === 0 ? 'zero-diff' : (totalDiffForLpd > 0 ? 'positive-diff' : 'negative-diff');
                       const totalDiffSign = totalDiffForLpd > 0 ? '+' : '';
                       lpdDiffBreakdownHTML += `<div class="lpd-total">Total Difference: <span class="${totalDiffClass}">${totalDiffSign}${totalDiffForLpd.toFixed(0)}</span></div>`;
                  } else {
                      lpdDiffBreakdownHTML += `\n   (Not used in any final allocation)`;
                  } lpdDiffBreakdownHTML += `</div>`;
             });
             lpdDifferenceBreakdownDiv.innerHTML = lpdDiffBreakdownHTML;


        } // End allocateAllItems

    </script>

</body>
</html>