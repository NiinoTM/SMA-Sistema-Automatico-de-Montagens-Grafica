<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>LPD Item Allocator v0.1.8 (Compare & Select Lowest Variation)</title>
    <style>
         /* Basic styling */
         body { font-family: sans-serif; padding: 20px; }
        label { display: block; margin-top: 10px; margin-bottom: 5px; font-weight: bold; }
        textarea { width: 90%; min-height: 150px; margin-bottom: 10px; font-family: monospace; }
        input[type="number"], input[type="text"] { padding: 8px; margin-bottom: 10px; width: 300px; }
        button { padding: 10px 15px; cursor: pointer; background-color: #28a745; color: white; border: none; border-radius: 4px; margin-top: 10px; }
        button:hover { background-color: #218838; }
        #statusArea, #strategyComparison, #allocationResults, #cumulativeUsage, #adjustmentLog, #lpdBreakdown, #finalSummaryTableDiv, #variationLog { margin-top: 20px; padding: 15px; border: 1px solid #ccc; background-color: #f9f9f9; white-space: pre-wrap; font-family: monospace; }
        .error { color: red; font-weight: bold; }
        .info { color: blue; }
        .warning { color: orange; }
        .success { color: green; font-weight: bold; }
        .positive-diff { color: #dc3545; } /* Red for positive difference (sum > target) */
        .negative-diff { color: #198754; } /* Green for negative difference (sum < target) */
        .zero-diff { color: #6c757d; }    /* Grey for zero difference */
        .violation { background-color: #f8d7da; color: #721c24; border: 1px solid #f5c6cb; padding: 1px 3px; border-radius: 3px;} /* Highlight variation violations */
        .input-group { margin-bottom: 15px; }
        .highlight { background-color: #cff4fc; font-weight: bold; border: 1px solid #9eeaf9;}
        .item-allocation, .adjustment-step, .lpd-section, .variation-step { border-top: 1px dashed #aaa; margin-top: 10px; padding-top: 10px;}
        .usage-summary, .lpd-section-title, .comparison-title { margin-top: 15px; font-weight: bold; }
        .lpd-item-list { margin-left: 20px; list-style-type: none; padding-left: 0;}
        .lpd-item-list li { margin-bottom: 3px; }
        .lpd-total { margin-top: 5px; font-style: italic; padding-left: 20px; }

        /* Style for Tables */
        #finalSummaryTable, #comparisonTable { width: 80%; border-collapse: collapse; margin-top: 15px; }
        #finalSummaryTable th, #finalSummaryTable td, #comparisonTable th, #comparisonTable td { border: 1px solid #ddd; padding: 6px 8px; text-align: left; }
        #finalSummaryTable th, #comparisonTable th { background-color: #e9ecef; font-weight: bold; }
        #finalSummaryTable td:nth-child(n+2), #comparisonTable td:nth-child(n+2) { text-align: right; } /* Align numeric columns right */
        #finalSummaryTable tr:nth-child(even), #comparisonTable tr:nth-child(even) { background-color: #f8f9fa; }
        .best-effort { background-color: #fff3cd; border-left: 4px solid #ffeeba; padding-left: 5px; } /* Highlight selected/best effort row in comparison */

    </style>
</head>
<body>

    <h1>LPD Item Allocator (Fill Slots, Limit ±25% Var, Compare & Select Lowest Variation)</h1>
    <p>Allocates items using multiple ordering strategies, adjusts within ±25%, compares the max variation achieved by each strategy. Displays the results of the first strategy found under ±30% variation, or if none succeed, displays the strategy with the overall *lowest* maximum variation.</p>

    <!-- Input fields -->
    <div class="input-group">
        <label for="tableData">Table Data (Details + Amount, one per line):</label>
        <textarea id="tableData" placeholder="Example:
Item A	10000
Item B	5000
..."></textarea>
    </div>
     <div class="input-group">
        <label for="lpdCombinationInput">LPD Combination (e.g., [3000, 8000]):</label>
        <input type="text" id="lpdCombinationInput" placeholder="[3000, 8000]">
    </div>
    <div class="input-group">
        <label for="maxSlots">Max Slots per LPD (Cumulative):</label>
        <input type="number" id="maxSlots" placeholder="e.g., 3 (blank=unlimited)" min="1" style="width: 120px;">
    </div>

    <button onclick="allocateAllItems()">Allocate, Compare Strategies & Adjust</button>

    <!-- Output area -->
    <div id="statusArea">Status messages will appear here...</div>
    <div id="strategyComparison">Strategy Comparison results will appear here...</div>
    <div id="allocationResults">Detailed Item Allocation results will appear here...</div>
    <div id="adjustmentLog">Slot Filling Adjustment Log will appear here...</div>
    <div id="variationLog">Variation Adjustment Log will appear here...</div>
    <div id="cumulativeUsage">Cumulative LPD usage will appear here...</div>
    <div id="lpdBreakdown">LPD Usage Breakdown by Item will appear here...</div>
    <div id="finalSummaryTableDiv">Final Allocation Summary Table will appear here...</div>


    <script>
        // --- CONFIGURATION RULES ---
        const MIN_LPD_VALUE_ALLOC = 0; // Currently unused placeholder
        const VARIATION_LIMIT_PASS_3 = 0.25; // Target limit for adjustment attempts in Pass 3
        const REPROCESS_VARIATION_LIMIT = 0.30; // Success threshold for selecting a strategy

        // --- Find Closest Sum (Allocation DP) ---
        // Uses dynamic programming to find the combination of LPDs (with repetition allowed up to slot limits)
        // that sums closest to the target amount. Minimizes the number of LPDs used in case of ties in sum difference.
        function findClosestSumWithRepetitionAndSlots(lpdArray, target, remainingSlotsMap) {
            // Basic validation
             if (!lpdArray || lpdArray.length === 0) { return { sum: 0, difference: 0 - target, combination: [], error: "No LPDs provided for allocation" }; }
             if (target < 0) { return { sum: 0, difference: 0 - target, combination: [], error: "Target amount cannot be negative" }; }

             // Prepare LPD array: unique, positive, available slots, sorted
             lpdArray = [...new Set(lpdArray)].filter(lpd => lpd > 0 && remainingSlotsMap.hasOwnProperty(lpd) && remainingSlotsMap[lpd] > 0).sort((a, b) => a - b);
             if (lpdArray.length === 0) { return { sum: 0, difference: 0 - target, combination: [], error: "LPD list empty or no LPDs have remaining slots" }; }

             const smallestLpd = lpdArray[0];
             // Determine max sum to check (target + smallest LPD to allow exceeding target slightly)
             const maxSum = Math.max(target, 0) + smallestLpd;
             // DP table: dp[i] stores the best state { count, usage, lastLpd } to reach sum i
             const dp = new Array(maxSum + 1).fill(null);
             // Base case: sum 0 requires 0 items
             dp[0] = { count: 0, usage: {}, lastLpd: null };

             // Fill DP table
             for (let i = 1; i <= maxSum; i++) {
                  let bestStateForI = null;
                  // Try adding each LPD to a previous reachable sum
                  for (const lpd of lpdArray) {
                      const prevSum = i - lpd;
                      // Check if previous sum was reachable
                      if (prevSum >= 0 && dp[prevSum] !== null) {
                          const prevState = dp[prevSum];
                          // Calculate how many times this LPD would be used in the current path
                          const currentLpdUsageInThisPath = (prevState.usage[lpd] || 0) + 1;
                          const slotsAvailable = remainingSlotsMap[lpd];

                          // Check if adding this LPD respects the slot limit
                          if (currentLpdUsageInThisPath <= slotsAvailable) {
                              const newTotalCount = prevState.count + 1;
                              // If this path is better (fewer items) than any found so far for sum i, update bestStateForI
                              if (bestStateForI === null || newTotalCount < bestStateForI.count) {
                                   const newUsage = { ...prevState.usage, [lpd]: currentLpdUsageInThisPath };
                                   bestStateForI = { count: newTotalCount, usage: newUsage, lastLpd: lpd };
                               }
                           }
                       }
                   }
                   dp[i] = bestStateForI; // Store the best state found for sum i
             }

             // Find the closest reachable sum to the target
             let minAbsDiff = Infinity;
             let closestSum = -1;
             let bestReachableState = null;

             // Check sums from target down to 0
             for (let i = target; i >= 0; i--) {
                 if (dp[i] !== null) {
                     const diff = Math.abs(target - i);
                     // Prioritize smaller absolute difference, then fewer items for ties
                     if (diff < minAbsDiff || (diff === minAbsDiff && dp[i].count < bestReachableState.count)) {
                         minAbsDiff = diff;
                         closestSum = i;
                         bestReachableState = dp[i];
                     }
                     // Optimization: If diff starts increasing, we've passed the minimum for sums <= target
                     if (diff > minAbsDiff && closestSum !== -1) break;
                 }
             }
             // Check sums from target + 1 up to maxSum
             for (let i = target + 1; i <= maxSum; i++) {
                 if (dp[i] !== null) {
                     const diff = Math.abs(i - target);
                     if (diff < minAbsDiff || (diff === minAbsDiff && dp[i].count < bestReachableState.count)) {
                         minAbsDiff = diff;
                         closestSum = i;
                         bestReachableState = dp[i];
                     }
                      // Optimization: If diff starts increasing or equals current min, stop searching higher sums
                     if (diff >= minAbsDiff && closestSum !== -1) break;
                 }
             }

             // Handle cases where no sum is reachable (or only sum 0)
             if (closestSum === -1) {
                 if (target === 0 && dp[0] !== null) { // Target is 0, reachable
                     closestSum = 0; bestReachableState = dp[0];
                 } else { // Target > 0 but no sum found, or target is 0 and unreachable
                     closestSum = 0; bestReachableState = dp[0] || { count: 0, usage: {}, lastLpd: null }; // Default to sum 0
                 }
             }

             // Backtrack to reconstruct the combination
             const combination = [];
             let currentSum = closestSum;
             let currentState = bestReachableState;
             let safetyCounter = 0;
             const maxLoops = (currentState?.count || 0) + lpdArray.length + 100; // Generous safety limit

             while (currentSum > 0 && currentState?.lastLpd && safetyCounter < maxLoops) {
                  const usedLpd = currentState.lastLpd;
                  combination.push(usedLpd);
                  const prevSum = currentSum - usedLpd;
                  // Move to the state for the previous sum
                  if (prevSum >= 0 && dp[prevSum] !== null) {
                      currentState = dp[prevSum];
                      currentSum = prevSum;
                  } else {
                      // Error: Should not happen if DP table is correct
                      return { sum: closestSum, difference: closestSum - target, combination: combination.sort((a,b)=>a-b), error: `Backtracking error: State missing for sum ${prevSum}` };
                  }
                  safetyCounter++;
             }

             // Final checks and error handling
             if (safetyCounter >= maxLoops) { return { sum: closestSum, difference: closestSum - target, combination: combination.sort((a,b)=>a-b), error: "Backtracking safety limit reached" }; }
             if (currentSum !== 0 && closestSum !== 0) { return { sum: closestSum, difference: closestSum - target, combination: combination.sort((a,b)=>a-b), error: `Backtracking incomplete (final sum ${currentSum} reached)` }; }

             // Verify reconstructed sum matches the closest sum found
             const reconstructedSum = combination.reduce((a, b) => a + b, 0);
             if (reconstructedSum !== closestSum) { return { sum: closestSum, difference: closestSum - target, combination: combination.sort((a,b)=>a-b), error: `Reconstruction mismatch (${reconstructedSum} != ${closestSum})` }; }

             // Verify slot usage in the final combination
             const finalUsageCheck = {};
             for(const lpd of combination) {
                 finalUsageCheck[lpd] = (finalUsageCheck[lpd] || 0) + 1;
                 if (finalUsageCheck[lpd] > remainingSlotsMap[lpd]) {
                      return { sum: closestSum, difference: closestSum - target, combination: combination.sort((a,b)=>a-b), error: `Slot limit violated for LPD ${lpd} during reconstruction check` };
                 }
             }

             const finalDifference = closestSum - target; // Signed difference
             return { sum: closestSum, difference: finalDifference, combination: combination.sort((a,b)=>a-b) }; // Return success
        }

        // --- Helper: Calculate Max Absolute Variation Percentage for a Run ---
        // Iterates through items and allocations, finds the highest |difference / target| percentage.
        // Handles target amount of 0 correctly (Infinity if sum is non-zero).
        function calculateMaxVariation(items, allocations) {
            let maxAbsPercentage = 0;
            for (let i = 0; i < items.length; i++) {
                const item = items[i];
                const alloc = allocations[i];

                // Skip items with allocation errors or missing difference data
                if (alloc.error || alloc.difference === undefined) continue;

                const targetAmount = item.amount;
                const difference = alloc.difference;
                let currentAbsPercentage = 0;

                if (targetAmount > 0) {
                    // Standard percentage calculation
                    currentAbsPercentage = Math.abs(difference / targetAmount);
                } else if (alloc.sum !== 0) {
                    // Special case: Target is 0, but achieved sum is not. Infinite variation.
                    currentAbsPercentage = Infinity;
                } // else: Target is 0 and sum is 0, variation is 0.

                // Update maximum if current percentage is higher
                if (currentAbsPercentage > maxAbsPercentage) {
                    maxAbsPercentage = currentAbsPercentage;
                }
            }
            return maxAbsPercentage;
        }


        // --- Core Allocation Logic (Reusable Function) ---
        // Takes a list of items (already sorted by a strategy), LPDs, and max slots.
        // Runs the 3-pass allocation process: Initial DP, Slot Filling, Variation Correction.
        // Returns the final allocations, usage stats, remaining slots, and logs for this specific run.
        function runAllocationProcess(itemsToProcess, userLpdCombination, maxSlots) {
             const maxSlotsIsFinite = maxSlots !== Infinity;
             const maxSlotsDisplay = maxSlotsIsFinite ? maxSlots : "Unlimited";
             let logs = { adjustment: '', variation: '' }; // Object to hold log strings

             // 1. Initialize State specific to this run
             const currentRemainingSlots = {}; // Tracks slots available *during this run*
             userLpdCombination.forEach(lpd => { currentRemainingSlots[lpd] = maxSlots; });
             const currentItemAllocations = new Array(itemsToProcess.length); // Stores allocation results

             // --- PASS 1: Initial Allocation using DP ---
             itemsToProcess.forEach((item, i) => {
                 // Use a copy of remaining slots for the DP function call for this item
                 // Note: DP function filters LPDs with 0 slots remaining internally
                 const initialRemainingForThisItem = {...currentRemainingSlots};
                 const allocation = findClosestSumWithRepetitionAndSlots(
                     [...userLpdCombination], // Pass available LPDs
                     item.amount,             // Target for this item
                     initialRemainingForThisItem // Current slot availability
                 );
                 currentItemAllocations[i] = allocation; // Store result

                 // If allocation successful, decrement slots used in the *run's* state
                 if (!allocation.error && allocation.combination.length > 0) {
                     allocation.combination.forEach(lpd => {
                         if (currentRemainingSlots[lpd] !== Infinity) {
                             if (currentRemainingSlots[lpd] > 0) {
                                 currentRemainingSlots[lpd]--;
                             } else {
                                 // Log error if DP somehow used more slots than available (shouldn't happen with checks)
                                 console.error(`Slot count error Pass 1 (Run Func): LPD ${lpd} used for Item ${item.details} when slots were 0.`);
                                 allocation.error = (allocation.error ? allocation.error + '; ' : '') + `Slot count error during initial allocation post-check for LPD ${lpd}`;
                             }
                         }
                     });
                 }
             });

             // --- PASS 2: Slot Filling Adjustment ---
             // Attempts to use remaining slots (if finite) by adding LPDs to items where it causes the least increase (or largest decrease) in absolute difference.
             let adjustmentLogHTML = `--- Pass 2: Slot Filling Adjustments (Target Slots: ${maxSlotsDisplay}) ---`;
             if (maxSlotsIsFinite) {
                 adjustmentLogHTML += `\nInitial Remaining Slots after Pass 1:\n${JSON.stringify(currentRemainingSlots, null, 2)}`;
                 let totalRemaining = Object.values(currentRemainingSlots).reduce((sum, count) => sum + (count === Infinity ? 0 : count), 0); // Sum finite slots
                 adjustmentLogHTML += `\nTotal Remaining Slots: ${totalRemaining}`;
                 let adjustmentSafetyCounter = 0;
                 const maxAdjustments = totalRemaining + itemsToProcess.length * 2; // Safety break

                 while (totalRemaining > 0 && adjustmentSafetyCounter < maxAdjustments) {
                     adjustmentSafetyCounter++;
                     let bestMove = { lpdToAdd: null, itemIndex: -1, minImpact: Infinity }; // Track best potential move

                     // Iterate through LPDs with remaining slots
                     for (const lpd of userLpdCombination) {
                         if (currentRemainingSlots[lpd] > 0) {
                             // Check impact of adding this LPD to each item
                             for (let i = 0; i < currentItemAllocations.length; i++) {
                                 const currentAlloc = currentItemAllocations[i];
                                 // Skip items with errors or no initial allocation
                                 if (currentAlloc.error || currentAlloc.sum === undefined) continue;

                                 const originalAmount = itemsToProcess[i].amount;
                                 const currentSum = currentAlloc.sum;
                                 const currentAbsDifference = Math.abs(currentAlloc.difference);
                                 const newSum = currentSum + lpd;
                                 const newAbsDifference = Math.abs(newSum - originalAmount);
                                 // Calculate impact: lower is better (smaller increase or larger decrease in abs difference)
                                 const impact = newAbsDifference - currentAbsDifference;

                                 if (impact < bestMove.minImpact) {
                                     bestMove = { lpdToAdd: lpd, itemIndex: i, minImpact: impact };
                                 }
                             }
                         }
                     } // End LPD loop

                     // If a beneficial move was found, apply it
                     if (bestMove.lpdToAdd !== null) {
                         const lpd = bestMove.lpdToAdd;
                         const itemIdx = bestMove.itemIndex;
                         adjustmentLogHTML += `<div class="adjustment-step">Step ${adjustmentSafetyCounter}: Adding LPD <span class="info">${lpd}</span> to Item ${itemsToProcess[itemIdx].index + 1} ('${itemsToProcess[itemIdx].details}')`;
                         adjustmentLogHTML += ` (Impact on Abs Diff: ${bestMove.minImpact >= 0 ? '+' : ''}${bestMove.minImpact.toFixed(0)})`;

                         // Update allocation data for the chosen item
                         currentItemAllocations[itemIdx].combination.push(lpd);
                         currentItemAllocations[itemIdx].combination.sort((a,b)=>a-b); // Keep sorted
                         currentItemAllocations[itemIdx].sum += lpd;
                         currentItemAllocations[itemIdx].difference = currentItemAllocations[itemIdx].sum - itemsToProcess[itemIdx].amount;
                         // Update slot count for this run
                         currentRemainingSlots[lpd]--;
                         totalRemaining--;

                         adjustmentLogHTML += `\n   -> New Sum: ${currentItemAllocations[itemIdx].sum}, New Signed Diff: ${currentItemAllocations[itemIdx].difference.toFixed(0)}, Slots Remaining for ${lpd}: ${currentRemainingSlots[lpd]}</div>`;
                     } else {
                         // No move found that improves or minimally worsens the absolute difference
                         adjustmentLogHTML += `\n<span class="warning">Stopped slot adjustments: No beneficial move found. ${totalRemaining} slots may remain unused.</span>`;
                         break; // Exit loop
                     }
                 } // End while loop
                 if (adjustmentSafetyCounter >= maxAdjustments) {
                     adjustmentLogHTML += `\n<span class="error">Stopped slot adjustments due to reaching safety limit (${maxAdjustments}).</span>`;
                 }
             } else {
                 // Max slots was unlimited
                 adjustmentLogHTML += `\n(Skipped: Max Slots was set to Unlimited)`;
             }
             logs.adjustment = adjustmentLogHTML; // Store Pass 2 log


             // --- PASS 3: Variation Correction Adjustment ---
             // Attempts to fix items exceeding the VARIATION_LIMIT_PASS_3 (e.g., 25%) by adding or removing a single LPD,
             // prioritizing the fix that results in the lowest absolute difference *within* the limit.
             let variationLogHTML = `--- Pass 3: Variation Correction (Target Limit: ±${(VARIATION_LIMIT_PASS_3 * 100).toFixed(0)}%) ---`;
             let madeVariationAdjustment = true; // Loop control flag
             let variationLoopCounter = 0;
             const maxVariationLoops = itemsToProcess.length * userLpdCombination.length * 2 + 10; // Safety break

             while (madeVariationAdjustment && variationLoopCounter < maxVariationLoops) {
                 variationLoopCounter++;
                 madeVariationAdjustment = false; // Assume no adjustment needed this iteration

                 // Find the item with the worst violation (highest percentage diff > limit)
                 let worstViolation = { index: -1, percentageDiff: 0 };
                 currentItemAllocations.forEach((alloc, i) => {
                     if (!alloc.error && alloc.difference !== undefined) {
                         const item = itemsToProcess[i];
                         const targetAmount = item.amount;
                         let percentageDiff = 0;
                         if (targetAmount > 0) {
                             percentageDiff = Math.abs(alloc.difference / targetAmount);
                         } else if (alloc.sum !== 0) {
                             percentageDiff = Infinity;
                         }

                         // Check against the Pass 3 target limit (25%)
                         if (percentageDiff > VARIATION_LIMIT_PASS_3 && percentageDiff > worstViolation.percentageDiff) {
                             worstViolation = { index: i, percentageDiff: percentageDiff };
                         }
                     }
                 });

                 // If no violations found exceeding the target limit, exit Pass 3 loop
                 if (worstViolation.index === -1) {
                      variationLogHTML += `\nIteration ${variationLoopCounter}: No items violate the ±${(VARIATION_LIMIT_PASS_3 * 100).toFixed(0)}% target limit for correction.`;
                      break;
                 }

                 // Attempt to fix the worst violation found
                 const itemIdx = worstViolation.index;
                 const currentAlloc = currentItemAllocations[itemIdx];
                 const originalAmount = itemsToProcess[itemIdx].amount;
                 variationLogHTML += `<div class="variation-step">Iter ${variationLoopCounter}: Fixing Item ${itemsToProcess[itemIdx].index + 1} ('${itemsToProcess[itemIdx].details}') - Current Diff: ${currentAlloc.difference.toFixed(0)} (${(worstViolation.percentageDiff * 100).toFixed(1)}%)`;

                 let bestFix = { action: null, lpd: null, finalAbsDiff: Infinity }; // Store best valid fix found

                 // --- Try Removing Each Existing LPD ---
                  const currentCombinationCopy = [...currentAlloc.combination]; // Iterate over copy
                  for (const lpdToRemove of currentCombinationCopy) {
                      const newSum = currentAlloc.sum - lpdToRemove;
                      const newSignedDiff = newSum - originalAmount;
                      const newAbsDiff = Math.abs(newSignedDiff);
                      const newPercentageDiff = originalAmount > 0 ? (newAbsDiff / originalAmount) : (newSum === 0 ? 0 : Infinity);

                      // Check if this removal fixes the violation (within 25% limit)
                      if (newPercentageDiff <= VARIATION_LIMIT_PASS_3) {
                           // If this fix is better than current best (lower final abs diff), store it
                           if (newAbsDiff < bestFix.finalAbsDiff) {
                                bestFix = { action: 'remove', lpd: lpdToRemove, finalAbsDiff: newAbsDiff };
                           }
                      }
                  }

                  // --- Try Adding Each Available LPD ---
                   for (const lpdToAdd of userLpdCombination) {
                       // Check if slots are available for this LPD *in this run*
                       if (currentRemainingSlots[lpdToAdd] > 0 || !maxSlotsIsFinite) { // Allow add if unlimited slots or slots remain
                           const newSum = currentAlloc.sum + lpdToAdd;
                           const newSignedDiff = newSum - originalAmount;
                           const newAbsDiff = Math.abs(newSignedDiff);
                           const newPercentageDiff = originalAmount > 0 ? (newAbsDiff / originalAmount) : (newSum === 0 ? 0 : Infinity);

                           // Check if this addition fixes the violation (within 25% limit)
                           if (newPercentageDiff <= VARIATION_LIMIT_PASS_3) {
                               // If this fix is better than current best, store it
                               if (newAbsDiff < bestFix.finalAbsDiff) {
                                    bestFix = { action: 'add', lpd: lpdToAdd, finalAbsDiff: newAbsDiff };
                               }
                           }
                       }
                   }

                   // --- Apply the Best Fix Found (if any) ---
                    if (bestFix.action) {
                         madeVariationAdjustment = true; // Signal that an adjustment was made, loop again
                         const lpd = bestFix.lpd;
                         variationLogHTML += ` -> Action: ${bestFix.action.toUpperCase()} LPD ${lpd}`;

                         if (bestFix.action === 'remove') {
                              const indexToRemove = currentItemAllocations[itemIdx].combination.indexOf(lpd);
                              if (indexToRemove > -1) {
                                   // Update allocation data
                                   currentItemAllocations[itemIdx].combination.splice(indexToRemove, 1);
                                   currentItemAllocations[itemIdx].sum -= lpd;
                                   currentItemAllocations[itemIdx].difference -= lpd;
                                   // Give back the slot if finite slots are used
                                   if (maxSlotsIsFinite) { currentRemainingSlots[lpd]++; }
                              } else {
                                   // Error: LPD to remove not found (shouldn't happen if logic is correct)
                                   console.error(`Variation Fix Error: Tried to remove ${lpd} but not found in combination for item ${itemIdx}`);
                                   variationLogHTML += ` <span class="error">(Error removing!)</span>`;
                                   madeVariationAdjustment = false; // Prevent infinite loop on error
                              }
                         } else { // action === 'add'
                              // Update allocation data
                              currentItemAllocations[itemIdx].combination.push(lpd);
                              currentItemAllocations[itemIdx].combination.sort((a,b) => a-b);
                              currentItemAllocations[itemIdx].sum += lpd;
                              currentItemAllocations[itemIdx].difference += lpd;
                              // Take the slot if finite slots are used
                              if (maxSlotsIsFinite) { currentRemainingSlots[lpd]--; }
                         }
                          // Log the result of the fix
                          const finalPercDiffCheck = originalAmount > 0 ? Math.abs(currentItemAllocations[itemIdx].difference / originalAmount) : (currentItemAllocations[itemIdx].sum === 0 ? 0 : Infinity);
                          variationLogHTML += ` -> New Diff: ${currentItemAllocations[itemIdx].difference.toFixed(0)} (${(finalPercDiffCheck * 100).toFixed(1)}%)`;
                          if (maxSlotsIsFinite) { variationLogHTML += `, Slots Rem. for ${lpd}: ${currentRemainingSlots[lpd]}`; }

                     } else {
                          // No single add/remove action could fix this item within the 25% limit
                          variationLogHTML += ` -> <span class="warning">No single add/remove action found to bring item within ±${(VARIATION_LIMIT_PASS_3 * 100).toFixed(0)}% target limit.</span>`;
                          // Stop the loop for *this item* in this iteration. The loop might continue if other items were fixed.
                          // If this was the only item needing fixing, the outer loop will terminate in the next check.
                          // A more complex logic could try multiple steps or different items, but this keeps it simpler.
                          // Setting madeVariationAdjustment = false here would stop the *entire* Pass 3 prematurely if the worst item couldn't be fixed.
                          // We let it continue to check other items.
                     }
                     variationLogHTML += `</div>`; // End variation-step div
             } // End while madeVariationAdjustment

             if (variationLoopCounter >= maxVariationLoops) {
                  variationLogHTML += `\n<span class="error">Stopped variation adjustments due to reaching loop limit (${maxVariationLoops}).</span>`;
             }
             logs.variation = variationLogHTML; // Store Pass 3 log


            // --- Calculate Final Usage Counts Per Item (Post-Adjustments) ---
            let finalCumulativeUsage = {}; // Recalculate final usage based on the *end state*
            userLpdCombination.forEach(lpd => { finalCumulativeUsage[lpd] = 0; });
            currentItemAllocations.forEach(alloc => {
                alloc.finalUsageCounts = {}; // Add usage counts object to each allocation result
                if (!alloc.error && alloc.combination) {
                    alloc.combination.forEach(lpd => {
                        // Count LPD usage per item
                        alloc.finalUsageCounts[lpd] = (alloc.finalUsageCounts[lpd] || 0) + 1;
                        // Tally overall cumulative usage
                        if (finalCumulativeUsage.hasOwnProperty(lpd)) {
                            finalCumulativeUsage[lpd]++;
                        } else {
                            // Should not happen if LPD is in userLpdCombination
                             console.error(`LPD ${lpd} found in final allocation but not in initial list.`);
                        }
                    });
                }
            });

            // Return results object for this specific run
            return {
                itemAllocations: currentItemAllocations, // Array of allocation results for items
                cumulativeUsage: finalCumulativeUsage,    // Object { lpd: count } for total usage
                remainingSlots: currentRemainingSlots,   // Object { lpd: count } for final remaining slots
                logs: logs                                // Object { adjustment: "...", variation: "..." }
            };
        }


        // --- Main Controlling Function ---
        // Orchestrates the entire process: input parsing, running strategies, comparison, selection, display.
        function allocateAllItems() {
            // 1. Read and Validate Inputs (Common Setup)
            const tableDataInput = document.getElementById('tableData').value.trim();
            const lpdCombinationInput = document.getElementById('lpdCombinationInput').value.trim();
            const maxSlotsInput = document.getElementById('maxSlots').value;
            // Get references to all output divs
            const statusAreaDiv = document.getElementById('statusArea');
            const strategyComparisonDiv = document.getElementById('strategyComparison');
            const allocationResultsDiv = document.getElementById('allocationResults');
            const cumulativeUsageDiv = document.getElementById('cumulativeUsage');
            const adjustmentLogDiv = document.getElementById('adjustmentLog');
            const lpdBreakdownDiv = document.getElementById('lpdBreakdown');
            const finalSummaryTableDiv = document.getElementById('finalSummaryTableDiv');
            const variationLogDiv = document.getElementById('variationLog');

            // Clear previous results from all output areas
            statusAreaDiv.innerHTML = '';
            strategyComparisonDiv.innerHTML = '';
            allocationResultsDiv.innerHTML = `Processing...`; // Initial status
            cumulativeUsageDiv.innerHTML = '';
            adjustmentLogDiv.innerHTML = '';
            variationLogDiv.innerHTML = '';
            lpdBreakdownDiv.innerHTML = '';
            finalSummaryTableDiv.innerHTML = '';

            // Basic Input Validation
            if (!tableDataInput) { statusAreaDiv.innerHTML = '<span class="error">Error: Table data cannot be empty.</span>'; allocationResultsDiv.innerHTML = ''; return; }
            if (!lpdCombinationInput) { statusAreaDiv.innerHTML = '<span class="error">Error: LPD Combination input cannot be empty.</span>'; allocationResultsDiv.innerHTML = ''; return; }

            // Parse Max Slots
            let maxSlots = Infinity;
            let maxSlotsIsFinite = false;
            if (maxSlotsInput) {
                maxSlots = parseInt(maxSlotsInput);
                if (isNaN(maxSlots) || maxSlots < 1) {
                    statusAreaDiv.innerHTML = '<span class="error">Invalid Max Slots per LPD. Must be a positive integer or blank.</span>'; allocationResultsDiv.innerHTML = ''; return;
                }
                maxSlotsIsFinite = true;
            }
            const maxSlotsDisplay = maxSlotsIsFinite ? maxSlots : "Unlimited";

            // Parse LPD Combination
            let userLpdCombination;
             try {
                 userLpdCombination = JSON.parse(lpdCombinationInput.replace(/\s/g, '')); // Allow spaces, remove them
                 if (!Array.isArray(userLpdCombination)) { throw new Error("Input is not a JSON array."); }
                 if (!userLpdCombination.every(item => typeof item === 'number' && item > 0)) { throw new Error("Array must contain only positive numbers."); }
                 if (userLpdCombination.length === 0) { throw new Error("LPD Combination array cannot be empty."); }
                 userLpdCombination = [...new Set(userLpdCombination)].sort((a, b) => a - b); // Ensure unique & sorted
             } catch (e) { statusAreaDiv.innerHTML = `<span class="error">Error parsing LPD Combination input: ${e.message} Ensure format is like [3000, 8000].</span>`; allocationResultsDiv.innerHTML = ''; return; }

            // Parse Table Data
            const lines = tableDataInput.split('\n');
            const originalItemsUnsorted = []; // Store original items with their original index
            let parseErrors = [];
            lines.forEach((line, index) => {
                line = line.trim(); if (!line) return; // Skip empty lines
                // Try splitting by tab first, then by whitespace as fallback
                let parts = line.split('\t');
                let details = '';
                if (parts.length < 2) { parts = line.split(/\s+/); } // Fallback split on one or more spaces

                if (parts.length < 2) {
                    parseErrors.push(`L${index + 1}: Cannot split line into details and amount: "${line}"`);
                    return;
                }

                // Assume last part is amount, rest is details. Remove commas from amount.
                const amountStr = parts[parts.length - 1].replace(/,/g, '');
                // Rejoin details, preferring tab if originally tab-split, else space
                details = parts.slice(0, -1).join(parts.length > 2 && line.includes('\t') ? '\t' : ' ');
                const amount = parseInt(amountStr);

                if (isNaN(amount)) { parseErrors.push(`L${index + 1}: Amount is not a number ('${parts[parts.length - 1]}') for details "${details}"`); return; }
                if (amount < 0) { parseErrors.push(`L${index + 1}: Amount cannot be negative (${amount}) for details "${details}"`); return; }

                // Store parsed item with its original index
                originalItemsUnsorted.push({ details: details, amount: amount, originalIndex: index });
            });

            if (parseErrors.length > 0) { statusAreaDiv.innerHTML = `<span class="error">Table Data Parse Errors:</span>\n${parseErrors.join('\n')}`; allocationResultsDiv.innerHTML = ''; return; }
            if (originalItemsUnsorted.length === 0) { statusAreaDiv.innerHTML = `<span class="error">Error: No valid items parsed from Table Data.</span>`; allocationResultsDiv.innerHTML = ''; return; }


            // 2. Define Sorting Strategies
            // Each strategy has a name and a function that takes the item array and returns a *new* sorted array.
            const strategies = [
                { name: "Original Input Order", sortFn: (items) => [...items] }, // Keep original order
                { name: "Amount Ascending", sortFn: (items) => [...items].sort((a, b) => a.amount - b.amount) },
                { name: "Amount Descending", sortFn: (items) => [...items].sort((a, b) => b.amount - a.amount) },
                { name: "Details Ascending (A-Z)", sortFn: (items) => [...items].sort((a, b) => a.details.localeCompare(b.details)) },
                { name: "Details Descending (Z-A)", sortFn: (items) => [...items].sort((a, b) => b.details.localeCompare(a.details)) },
            ];

            let strategyResults = []; // Array to hold the complete results of each strategy run
            let firstSuccessfulResult = null; // Variable to store the first strategy result that meets the limit

            // 3. Iterate Through ALL Defined Strategies
            statusAreaDiv.innerHTML = `Running allocation for all ${strategies.length} strategies...`;
            for (const strategy of strategies) {
                console.log(`--- Running Strategy: ${strategy.name} ---`);
                statusAreaDiv.innerHTML = `Running allocation strategy: <span class="info">${strategy.name}</span>...`; // Update status per strategy run

                // Create the sorted item list for this specific strategy run
                // Map includes originalIndex for later reference/sorting back
                const currentItemsOrdered = strategy.sortFn(originalItemsUnsorted).map((item, index) => ({
                    ...item, // Spread original data (details, amount, originalIndex)
                    index: index // This 'index' refers to the position *within this sorted run*
                }));

                // Execute the core allocation process for this ordered item list
                const result = runAllocationProcess(currentItemsOrdered, userLpdCombination, maxSlots);

                // Calculate the maximum variation for this strategy's result
                const maxVariation = calculateMaxVariation(currentItemsOrdered, result.itemAllocations);
                // Check if this strategy meets the success threshold (e.g., 30%)
                const meetsLimit = maxVariation <= REPROCESS_VARIATION_LIMIT;

                console.log(`--- Strategy ${strategy.name} completed. Max Variation: ${(maxVariation * 100).toFixed(2)}%. Meets Limit (<= ${REPROCESS_VARIATION_LIMIT*100}%): ${meetsLimit}`);

                // Store the detailed result object for this strategy
                const resultEntry = {
                    strategyName: strategy.name,
                    itemsUsed: currentItemsOrdered, // Items in the order processed
                    resultData: result, // Contains allocations, usage, slots, logs from runAllocationProcess
                    maxVariation: maxVariation, // Store calculated max variation
                    meetsLimit: meetsLimit // Store boolean flag if limit was met
                };
                strategyResults.push(resultEntry);

                // If this strategy meets the limit AND we haven't found a successful one yet, store it.
                if (meetsLimit && !firstSuccessfulResult) {
                    firstSuccessfulResult = resultEntry; // Keep the *first* successful one
                    console.log(`--- Found first successful strategy meeting limit: ${strategy.name} ---`);
                    // Note: We continue running remaining strategies for the comparison table.
                }
            } // End strategy loop


            // 4. Select Final Result to Display
            let finalResultToShow = null; // This will hold the result object we display in detail

            if (firstSuccessfulResult) {
                // If at least one strategy met the limit, use the first one found
                finalResultToShow = firstSuccessfulResult;
                statusAreaDiv.innerHTML = `<span class="success">Displaying detailed results for the first successful strategy: ${finalResultToShow.strategyName}</span> (Met ±${(REPROCESS_VARIATION_LIMIT * 100).toFixed(0)}% variation limit)`;
            } else {
                // No strategy met the limit. Find the one with the lowest maximum variation as the 'best effort'.
                if (strategyResults.length > 0) {
                    // Use reduce to find the strategy result with the minimum maxVariation
                    let bestEffortStrategy = strategyResults.reduce((best, current) => {
                        // Handle Infinity correctly: any finite number is better than Infinity
                        if (current.maxVariation === Infinity && best.maxVariation !== Infinity) return best; // Keep current best if it's finite
                        if (best.maxVariation === Infinity && current.maxVariation !== Infinity) return current; // Choose current if it's finite and best was Infinity
                        // If both are finite or both are Infinity, choose the lower variation
                        return current.maxVariation < best.maxVariation ? current : best;
                    }, strategyResults[0]); // Start comparison with the first result

                    finalResultToShow = bestEffortStrategy;
                    const bestEffortVariationStr = finalResultToShow.maxVariation === Infinity
                        ? 'Infinity (Zero Target Mismatch)'
                        : `${(finalResultToShow.maxVariation * 100).toFixed(1)}%`;
                    statusAreaDiv.innerHTML = `<span class="warning">Warning: None of the strategies met the ±${(REPROCESS_VARIATION_LIMIT * 100).toFixed(0)}% variation limit.</span> Displaying detailed results for the strategy with the <span class="info">lowest maximum variation</span> ('${finalResultToShow.strategyName}' at ${bestEffortVariationStr}) as the best available effort.`;
                } else {
                     // Fallback if something went wrong and no results were stored
                     statusAreaDiv.innerHTML = `<span class="error">Error: No strategy results were generated. Cannot display details.</span>`;
                     allocationResultsDiv.innerHTML = ''; // Clear processing message
                     return; // Stop execution
                }
            }


            // 5. Display Strategy Comparison Summary Table
            let comparisonHTML = `<div class="comparison-title">--- Strategy Comparison Summary (Success Threshold: ±${(REPROCESS_VARIATION_LIMIT * 100).toFixed(0)}%) ---</div>`;
            comparisonHTML += `<table id="comparisonTable">`;
            comparisonHTML += `<thead><tr><th>Strategy</th><th>Max Variation (%)</th><th>Met Threshold?</th></tr></thead>`;
            comparisonHTML += `<tbody>`;

            strategyResults.forEach(res => {
                let maxVarStr = "";
                // Format max variation percentage, handling Infinity
                if (res.maxVariation === Infinity) {
                    maxVarStr = '<span class="violation">Infinity</span>';
                } else {
                    maxVarStr = (res.maxVariation * 100).toFixed(1) + '%';
                     // Add warning class if it didn't meet the limit (even if finite)
                     if (!res.meetsLimit) {
                        maxVarStr = `<span class="warning">${maxVarStr}</span>`;
                     }
                }

                // Determine if this row corresponds to the strategy selected for detailed display
                const isSelectedStrategy = (finalResultToShow && res.strategyName === finalResultToShow.strategyName);
                const rowClass = isSelectedStrategy ? 'best-effort' : ''; // Apply highlighting class

                comparisonHTML += `<tr class="${rowClass}">`; // Add class to the table row
                // Add '(Selected)' text to the name if this row is the chosen one
                comparisonHTML += `<td>${res.strategyName} ${isSelectedStrategy ? '(Selected)' : ''}</td>`;
                comparisonHTML += `<td>${maxVarStr}</td>`;
                comparisonHTML += `<td>${res.meetsLimit ? '<span class="success">Yes</span>' : '<span class="error">No</span>'}</td>`;
                comparisonHTML += `</tr>`;
            });

            comparisonHTML += `</tbody></table>`;
            strategyComparisonDiv.innerHTML = comparisonHTML; // Add table to the page


            // 6. Display Detailed Results for the Selected Strategy
            // Ensure a result was actually selected before proceeding
            if (!finalResultToShow) {
                 console.error("Error: finalResultToShow is null before attempting to display detailed results.");
                 statusAreaDiv.innerHTML += `<br><span class="error">Internal Error: Could not determine which strategy result to display.</span>`;
                 return;
            }

            // Extract data from the selected result object for easier use
            const finalItems = finalResultToShow.itemsUsed; // Items in the order processed by this strategy
            const finalAllocations = finalResultToShow.resultData.itemAllocations;
            const finalCumulativeUsage = finalResultToShow.resultData.cumulativeUsage;
            const finalRemainingSlots = finalResultToShow.resultData.remainingSlots;
            const finalLogs = finalResultToShow.resultData.logs;

             // Display Logs (Pass 2 and Pass 3) for the selected strategy
             adjustmentLogDiv.innerHTML = finalLogs.adjustment;
             variationLogDiv.innerHTML = finalLogs.variation;

            // Display Final Item Allocation Details (for the selected strategy)
             let finalAllocationHTML = `--- Final Item Allocations (Using Strategy: ${finalResultToShow.strategyName}) ---`;
             finalItems.forEach((item, i) => { // Iterate through items *as processed* in the selected strategy
                 finalAllocationHTML += `<div class="item-allocation">`;
                 // Show item details, original line number, and target amount
                 finalAllocationHTML += `<b>${i + 1}. ${item.details}</b> (Original Line: ${item.originalIndex + 1}, Target Amount: ${item.amount})\n`;
                 const finalAlloc = finalAllocations[i]; // Get the corresponding allocation result

                 if (finalAlloc.error) {
                     finalAllocationHTML += `<span class="error">Allocation Error: ${finalAlloc.error}</span>\n`;
                 } else if (finalAlloc.sum !== undefined) {
                     // Calculate final percentage difference (absolute)
                     const finalPercDiff = item.amount > 0 ? (finalAlloc.difference / item.amount) : (finalAlloc.sum === 0 ? 0 : Infinity);
                     const absFinalPercDiff = Math.abs(finalPercDiff);
                     // Styling for difference value
                     let diffClass = finalAlloc.difference === 0 ? 'zero-diff' : (finalAlloc.difference > 0 ? 'positive-diff' : 'negative-diff');
                     let diffSign = finalAlloc.difference > 0 ? '+' : '';

                     // Display Achieved Sum, Difference, and Percentage
                     finalAllocationHTML += `<span class="highlight">Final Achieved Sum: ${finalAlloc.sum}</span> (Final Diff: <span class="${diffClass}">${diffSign}${finalAlloc.difference.toFixed(0)}</span>`;
                     if (item.amount > 0) { // Show percentage only if target > 0
                        finalAllocationHTML += ` / ${(finalPercDiff * 100).toFixed(1)}%`;
                        // Add violation/warning spans based on final state vs limits
                        if (absFinalPercDiff > REPROCESS_VARIATION_LIMIT) { // Exceeds 30%
                             finalAllocationHTML += ` <span class="violation">Exceeds ±${(REPROCESS_VARIATION_LIMIT * 100).toFixed(0)}%</span>`;
                         } else if (absFinalPercDiff > VARIATION_LIMIT_PASS_3) { // Exceeds 25% but not 30%
                             finalAllocationHTML += ` <span class="warning">(>±${(VARIATION_LIMIT_PASS_3 * 100).toFixed(0)}%)</span>`;
                         }
                     } else if (finalAlloc.sum !== 0) { // Target 0, but sum isn't 0
                         finalAllocationHTML += ` <span class="violation">Non-zero sum for zero target</span>`;
                     }
                     finalAllocationHTML += `)\n`; // Close bracket for Final Diff line

                     // Display LPD combination and usage counts for this item
                     if (finalAlloc.combination.length > 0) {
                         finalAllocationHTML += `   Final Combination (${finalAlloc.combination.length} items): [${finalAlloc.combination.join(', ')}]`;
                         if (finalAlloc.finalUsageCounts && Object.keys(finalAlloc.finalUsageCounts).length > 0) {
                             finalAllocationHTML += `\n   Usage Counts: { ${Object.entries(finalAlloc.finalUsageCounts).map(([lpd, count]) => `"${lpd}": ${count}`).join(', ')} }`;
                         } else {
                             finalAllocationHTML += `\n   Usage Counts: {}`; // Should have counts if combination exists
                         }
                     } else {
                         finalAllocationHTML += `   (No LPDs needed)`;
                     }
                 } else {
                     // Fallback if allocation result structure is unexpected
                     finalAllocationHTML += "<span class='error'>Could not determine allocation result structure.</span>";
                 }
                 finalAllocationHTML += `</div>`; // End item-allocation div
             });
             allocationResultsDiv.innerHTML = finalAllocationHTML;

            // Display Cumulative Usage Summary (for the selected strategy)
             let usageSummaryHTML = `<div class="usage-summary">--- Final Cumulative LPD Usage Summary (Strategy: ${finalResultToShow.strategyName}, Max Slots: ${maxSlotsDisplay}) ---`;
             usageSummaryHTML += "<ul>";
             userLpdCombination.forEach(lpd => { // Iterate through the master LPD list
                 const used = finalCumulativeUsage[lpd] || 0; // Get usage count from the final result
                 const remaining = finalRemainingSlots[lpd]; // Get remaining slots from the final result
                 usageSummaryHTML += `<li>LPD ${lpd}: Used ${used} times`;
                 if (maxSlotsIsFinite) {
                     usageSummaryHTML += `, Remaining Slots: ${remaining}`;
                     // Add warnings/errors for slot counts
                     if (remaining < 0) { usageSummaryHTML += ` <span class="error">(Slot Error! Remaining < 0)</span>`; }
                     // Sanity check: used + remaining should equal initial maxSlots
                     else if (used + remaining !== maxSlots) {
                          console.warn(`Slot count mismatch for LPD ${lpd}: Used ${used}, Remaining ${remaining}, Max ${maxSlots}`);
                          usageSummaryHTML += ` <span class="warning">(Slot Count Mismatch?)</span>`;
                      }
                 }
                 usageSummaryHTML += `</li>`;
             });
             usageSummaryHTML += "</ul></div>";
             cumulativeUsageDiv.innerHTML = usageSummaryHTML;


             // Build and Display LPD Usage Breakdown by Item (for the selected strategy)
             let lpdBreakdownHTML = `<div class="lpd-section-title">--- LPD Usage Breakdown by Item (Strategy: ${finalResultToShow.strategyName}) ---`;
             const lpdUsageByItem = new Map(); // Map: LPD value -> array of {details, count, originalIndex}
             userLpdCombination.forEach(lpd => { lpdUsageByItem.set(lpd, []); }); // Initialize map keys

             // Populate the map using the final allocations
             finalItems.forEach((item, i) => {
                 const finalAlloc = finalAllocations[i];
                 if (!finalAlloc.error && finalAlloc.finalUsageCounts) {
                     for (const [lpdValueStr, count] of Object.entries(finalAlloc.finalUsageCounts)) {
                         const lpdValue = parseInt(lpdValueStr);
                         if (count > 0 && lpdUsageByItem.has(lpdValue)) {
                             lpdUsageByItem.get(lpdValue).push({ details: item.details, count: count, originalIndex: item.originalIndex });
                         }
                     }
                 }
             });

             // Generate HTML for the breakdown, sectioned by LPD
             userLpdCombination.forEach(lpd => { // Display sorted by LPD value
                  const itemsUsingLpd = lpdUsageByItem.get(lpd);
                  const totalCountForLpd = itemsUsingLpd.reduce((sum, item) => sum + item.count, 0); // Sum counts for this LPD
                  lpdBreakdownHTML += `<div class="lpd-section">`;
                  lpdBreakdownHTML += `<span class="lpd-section-title">LPD: ${lpd}</span>`;
                  if (itemsUsingLpd.length > 0) {
                      lpdBreakdownHTML += `<ul class="lpd-item-list">`;
                      // Sort items alphabetically within each LPD section for readability
                      itemsUsingLpd.sort((a,b)=>a.details.localeCompare(b.details)).forEach(itemUse => {
                          lpdBreakdownHTML += `<li>${itemUse.details}: ${itemUse.count} time(s)</li>`;
                      });
                      lpdBreakdownHTML += `</ul>`;
                      lpdBreakdownHTML += `<div class="lpd-total">Total Times Used: ${totalCountForLpd}</div>`;
                  } else {
                      lpdBreakdownHTML += `\n   (Not used in final allocations)`;
                  }
                  lpdBreakdownHTML += `</div>`; // End lpd-section div
             });
             lpdBreakdownDiv.innerHTML = lpdBreakdownHTML;


             // Build and Display Final Summary Table (using selected strategy's results, but original item order)
              let summaryTableHTML = `<div class="lpd-section-title">--- Final Allocation Summary (Results from Strategy: ${finalResultToShow.strategyName}) ---</div>`;
              summaryTableHTML += `<table id="finalSummaryTable">`;
              summaryTableHTML += `<thead><tr><th>Sabor (Original Input Order)</th><th>Quantidade</th><th>Empenho</th><th>Dif</th><th>Var (%)</th></tr></thead>`;
              summaryTableHTML += `<tbody>`;

              // Create a map from originalIndex to the final allocation result for easy lookup
              const allocationMap = new Map();
              finalItems.forEach((item, i) => { // Use items/allocations from the selected strategy result
                  allocationMap.set(item.originalIndex, {itemData: item, allocationData: finalAllocations[i]});
              });

              // Iterate through the *original unsorted* items to build the table rows in the input order
              originalItemsUnsorted.forEach(originalItem => {
                  const resultEntry = allocationMap.get(originalItem.originalIndex); // Find the result for this original item
                  let sabor = originalItem.details;
                  let quantidade = originalItem.amount;
                  let empenho = 'N/A'; // Default values
                  let difHtml = 'N/A';
                  let varHtml = 'N/A';

                  if (resultEntry) {
                      const finalAlloc = resultEntry.allocationData; // Allocation data from the selected strategy
                      if (!finalAlloc.error && finalAlloc.sum !== undefined) {
                          empenho = finalAlloc.sum.toFixed(0); // Allocated sum
                          const dif = finalAlloc.difference; // Signed difference
                          // Format difference display
                          let difClass = dif === 0 ? 'zero-diff' : (dif > 0 ? 'positive-diff' : 'negative-diff');
                          let difSign = dif > 0 ? '+' : '';
                          difHtml = `<span class="${difClass}">${difSign}${dif.toFixed(0)}</span>`;

                          // Calculate and format variation percentage
                          if (quantidade > 0) {
                              const percentage = (dif / quantidade);
                              const percentageFmt = (percentage * 100).toFixed(1) + '%';
                              varHtml = percentageFmt; // Default format
                              // Add highlighting based on final variation vs limits
                              if (Math.abs(percentage) > REPROCESS_VARIATION_LIMIT) { // Exceeds 30%
                                  varHtml = `<span class="violation">${percentageFmt}</span>`;
                              } else if (Math.abs(percentage) > VARIATION_LIMIT_PASS_3) { // Exceeds 25% but not 30%
                                  varHtml = `<span class="warning">${percentageFmt}</span>`;
                              }
                          } else if (empenho !== '0') { // Target 0, but sum not 0
                              varHtml = `<span class="violation">N/A (Non-zero sum)</span>`;
                          } else { // Target 0, sum 0
                              varHtml = '0.0%';
                          }
                      } else if (finalAlloc.error) { // Handle allocation errors in summary table
                          empenho = `<span class="error">Error</span>`;
                          difHtml = `<span class="error">Error</span>`;
                          varHtml = `<span class="error">Error</span>`;
                      }
                  } // else: item somehow wasn't processed (shouldn't happen if parsing worked)

                  // Add row to summary table
                  summaryTableHTML += `<tr>`;
                  summaryTableHTML += `<td>${sabor}</td>`;
                  summaryTableHTML += `<td>${quantidade}</td>`;
                  summaryTableHTML += `<td>${empenho}</td>`;
                  summaryTableHTML += `<td>${difHtml}</td>`;
                  summaryTableHTML += `<td>${varHtml}</td>`;
                  summaryTableHTML += `</tr>`;
              }); // End loop through original items

              summaryTableHTML += `</tbody></table>`;
              finalSummaryTableDiv.innerHTML = summaryTableHTML; // Add summary table to the page

        } // End allocateAllItems function

    </script>

</body>
</html>