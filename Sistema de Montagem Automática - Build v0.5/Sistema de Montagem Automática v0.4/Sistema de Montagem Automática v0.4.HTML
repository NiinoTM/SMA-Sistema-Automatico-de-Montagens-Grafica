<!DOCTYPE html>
<html lang="pt-BR">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <!-- MUDANÇA: Título mais específico -->
    <title>Sistema de Montagem de Planos v0.5 (Método Selecionável)</title>

    <style>
        /* Resetando alguns estilos padrão e definindo variáveis */
        :root {
            /* Cores - Dark Mode */
            --bg-primary: #121212;
            --bg-secondary: #1e1e1e;
            --bg-tertiary: #252525;
            --bg-card: #2d2d2d;
            --text-primary: #e0e0e0;
            --text-secondary: #b0b0b0;
            --text-muted: #888888;
            --border: #444444;
            --primary: #3b82f6;
            --primary-dark: #2563eb;
            --primary-light: #1e40af; /* Used for Total Row Background */
            --secondary: #64748b;
            --secondary-dark: #475569;
            --success: #10b981;
            --success-dark: #059669;
            --warning: #f59e0b;
            --warning-dark: #d97706;
            --danger: #ef4444;
            --danger-dark: #dc2626;
            --code-bg: #2d2d2d;
            --sidebar-width: 200px;
    
            /* Elementos de UI */
            --border-radius: 4px;
            --shadow-sm: 0 1px 3px rgba(0,0,0,0.2);
            --shadow: 0 4px 6px rgba(0,0,0,0.3);
            --transition: all 0.2s ease;
            --font-sans: 'Inter', -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, Helvetica, Arial, sans-serif;
            --font-mono: 'Roboto Mono', 'Fira Code', 'Courier New', monospace;
        }
    
        /* Estilos Base */
        * {
            box-sizing: border-box;
            margin: 0;
            padding: 0;
        }
    
        html {
            scroll-behavior: smooth;
        }
    
        body {
            font-family: var(--font-sans);
            font-size: 0.9rem;
            line-height: 1.5;
            color: var(--text-primary);
            background-color: var(--bg-primary);
            padding-left: calc(var(--sidebar-width) + 20px);
            padding-top: 10px;
            padding-right: 15px;
            padding-bottom: 20px;
            -webkit-print-color-adjust: exact; /* Ensure colors print */
             print-color-adjust: exact;
             color-adjust: exact;
        }
    
        h1, h2, h3, h4, h5, h6 {
            font-weight: 600;
            line-height: 1.2;
            margin-bottom: 0.75rem;
            color: var(--text-primary);
        }
    
        h1 {
            font-size: 1.5rem;
            margin-top: 0.5rem;
            padding-bottom: 0.5rem;
            border-bottom: 1px solid var(--border);
        }
    
        h2 {
            font-size: 1.25rem;
            margin-top: 1.5rem;
            padding-bottom: 0.25rem;
        }
    
        p {
            margin-bottom: 0.75rem;
        }
    
        /* Formulários e Entradas */
        label {
            display: block;
            margin-top: 0.75rem;
            margin-bottom: 0.25rem;
            font-weight: 500;
            color: var(--text-primary);
            font-size: 0.9rem;
        }
    
        textarea, input[type="text"], input[type="number"] {
            width: 100%;
            padding: 0.5rem;
            border: 1px solid var(--border);
            border-radius: var(--border-radius);
            background-color: var(--bg-tertiary);
            color: var(--text-primary);
            font-family: var(--font-sans);
            font-size: 0.85rem;
            transition: var(--transition);
        }
    
        textarea {
            min-height: 130px;
            font-family: var(--font-mono);
            line-height: 1.4;
            resize: vertical;
        }
    
        textarea:focus, input[type="text"]:focus, input[type="number"]:focus {
            outline: none;
            border-color: var(--primary);
            box-shadow: 0 0 0 2px rgba(59, 130, 246, 0.2);
        }
    
        input[type="number"] {
            max-width: 150px;
        }
    
        .input-group {
            margin-bottom: 1rem;
        }
    
        /* Botões */
        button {
            display: inline-flex;
            align-items: center;
            justify-content: center;
            padding: 0.5rem 1rem;
            font-size: 0.85rem;
            font-weight: 500;
            line-height: 1.5;
            color: white;
            background-color: var(--primary);
            border: none;
            border-radius: var(--border-radius);
            cursor: pointer;
            transition: var(--transition);
            box-shadow: var(--shadow-sm);
            margin-right: 0.5rem;
            margin-bottom: 0.5rem;
        }
    
        button:hover {
            background-color: var(--primary-dark);
            box-shadow: var(--shadow);
        }
    
        button:active {
            transform: translateY(1px);
            box-shadow: var(--shadow-sm);
        }
    
        button:disabled {
            background-color: var(--secondary);
            cursor: not-allowed;
            opacity: 0.7;
        }
    
    
        button.secondary {
            background-color: var(--secondary);
        }
    
        button.secondary:hover {
            background-color: var(--secondary-dark);
        }
    
        /* Sidebar */
        #sidebar {
            position: fixed;
            left: 0;
            top: 0;
            width: var(--sidebar-width);
            height: 100%;
            background-color: var(--bg-secondary);
            border-right: 1px solid var(--border);
            padding: 1rem 0.75rem;
            overflow-y: auto;
            z-index: 100;
        }
    
        #sidebar h3 {
            margin-top: 0;
            margin-bottom: 1rem;
            padding: 0 0.5rem 0.5rem 0.5rem;
            border-bottom: 1px solid var(--border);
            font-size: 1rem;
            color: var(--text-primary);
        }
    
        #sidebar ul {
            list-style: none;
            padding: 0;
            margin: 0;
        }
    
        #sidebar li {
            margin-bottom: 0.15rem;
        }
    
        #sidebar li a {
            display: block;
            padding: 0.4rem 0.5rem;
            text-decoration: none;
            color: var(--text-secondary);
            border-radius: var(--border-radius);
            transition: var(--transition);
            font-size: 0.85rem;
        }
    
        #sidebar li a:hover {
            background-color: var(--bg-tertiary);
            color: var(--primary);
        }
    
        /* Caixas de Resultado (excluindo lpdBreakdown) */
        #finderResultsLog, #foundCombinationDisplay, #statusArea, #strategyComparison,
        #allocationResults, #cumulativeUsage, #adjustmentLog,
        #finalSummaryTableDiv, #variationLog, #lpdBreakdown {
            margin-top: 1rem;
            padding: 0.75rem;
            border-radius: var(--border-radius);
            background-color: var(--bg-card);
            box-shadow: var(--shadow-sm);
            font-family: var(--font-mono);
            font-size: 0.85rem;
            line-height: 1.4;
            overflow-x: auto;
            border-left: 2px solid var(--border);
        }
    
    
        /* Estilo específico para cada tipo de caixa (exceto lpdBreakdown) */
        #finderResultsLog {
            white-space: pre-wrap;
            border-left-color: var(--primary);
        }
    
        #foundCombinationDisplay {
            padding: 0.75rem;
            border: none;
            background-color: var(--bg-tertiary);
            font-weight: 600;
            border-left: 2px solid var(--primary);
        }
    
        #statusArea {
            border-left-color: var(--secondary);
        }
    
        #strategyComparison {
            border-left-color: var(--secondary);
        }
    
        #allocationResults, #adjustmentLog, #cumulativeUsage {
            border-left-color: var(--success);
        }
    
        #variationLog {
            border-left-color: var(--warning);
        }
    
        #finalSummaryTableDiv {
            border-left-color: var(--primary);
        }
    
        /* Separadores */
        hr {
            border: none;
            height: 1px;
            background-color: var(--border);
            margin: 1.5rem 0 1rem 0;
        }
    
        /* Alertas e Destaques */
        .error {
            color: var(--danger);
            font-weight: 500;
        }
    
        .info {
            color: var(--primary);
        }
    
        .warning {
            color: var(--warning);
            font-weight: 500;
        }
    
        .success {
            color: var(--success);
            font-weight: 500;
        }
    
        .highlight {
            background-color: rgba(245, 158, 11, 0.15);
            font-weight: 500;
            border-radius: 2px;
            padding: 0.1rem 0.3rem;
            border: none;
        }
    
        /* Classes de Combinação */
        .fallback-gcd {
            color: var(--warning);
            font-weight: 600;
        }
    
        .fallback-prop {
            color: var(--secondary);
            font-weight: 600;
        }
    
        .target-section {
            border-top: 1px solid var(--border);
            padding-top: 0.75rem;
            margin-top: 1rem;
        }
    
        .candidate-section {
            border-left: 2px solid var(--border);
            padding-left: 0.75rem;
            margin: 0.5rem 0;
            padding-top: 0.25rem;
            padding-bottom: 0.25rem;
        }
    
        .fallback-section {
            border-top: 1px solid var(--warning-dark);
            padding-top: 0.75rem;
            margin-top: 1rem;
        }
    
        .proportional-fallback-section, .proportional-direct-section {
            border-top: 1px solid var(--secondary-dark);
            padding-top: 0.75rem;
            margin-top: 1rem;
        }
    
        /* Classes de Alocação */
        .positive-diff {
            color: var(--success);
            font-weight: 500;
        }
    
        .negative-diff {
            color: var(--danger);
            font-weight: 500;
        }
    
        .zero-diff {
            color: var(--text-muted);
        }
    
        .violation {
            background-color: rgba(239, 68, 68, 0.15);
            color: var(--danger);
            border-radius: 2px;
            padding: 0.1rem 0.3rem;
            font-weight: 500;
        }
    
        .item-allocation, .adjustment-step, .variation-step { /* lpd-section removed */
            border-top: 1px dashed var(--border);
            margin-top: 0.75rem;
            padding-top: 0.75rem;
        }
         /* Specific style for lpd-section inside lpdBreakdown if needed, otherwise remove default styling */
        #lpdBreakdown .lpd-section {
            border-top: none; /* Remove border from individual items within the card view */
             margin-top: 0;
             padding-top: 0;
        }
    
        .usage-summary, .lpd-section-title, .comparison-title {
            margin-top: 1rem;
            font-weight: 600;
            color: var(--text-primary);
        }
    
        /* List style - keep if needed elsewhere, but not for plan-container */
        .lpd-item-list {
            margin-left: 1.25rem;
            list-style-type: none;
            padding-left: 0;
        }
        .lpd-item-list li {
            margin-bottom: 0.15rem;
            padding: 0.15rem 0;
        }
        .lpd-total {
            margin-top: 0.5rem;
            font-style: italic;
            padding-left: 1.25rem;
            color: var(--text-muted);
        }
    
    
        /* Tabelas */
        #finalSummaryTable, #comparisonTable {
            width: 100%;
            border-collapse: separate;
            border-spacing: 0;
            margin-top: 1rem;
            border-radius: var(--border-radius);
            overflow: hidden;
            box-shadow: var(--shadow-sm);
        }
    
        #finalSummaryTable th, #finalSummaryTable td,
        #comparisonTable th, #comparisonTable td {
            border: 1px solid var(--border);
            padding: 0.5rem 0.75rem;
            text-align: left;
            font-size: 0.85rem;
        }
    
        #finalSummaryTable th, #comparisonTable th {
            background-color: var(--bg-tertiary);
            font-weight: 600;
            color: var(--text-primary);
            border-bottom: 2px solid var(--border);
        }
    
        #finalSummaryTable td:nth-child(n+2),
        #comparisonTable td:nth-child(n+2) {
            text-align: right;
        }
    
        #finalSummaryTable tr:nth-child(even),
        #comparisonTable tr:nth-child(even) {
            background-color: rgba(255, 255, 255, 0.025);
        }
    
        #finalSummaryTable tr:hover,
        #comparisonTable tr:hover {
            background-color: rgba(59, 130, 246, 0.05);
        }
    
        /* Estilo para tfoot */
        #finalSummaryTable tfoot th, #finalSummaryTable tfoot td {
            font-weight: bold;
            border-top: 2px solid var(--border);
            background-color: var(--bg-tertiary);
        }
    
    
        .best-effort {
            background-color: rgba(245, 158, 11, 0.1) !important;
            border-left: 3px solid var(--warning);
            font-weight: 500;
        }
    
        .strategy-error-row {
            background-color: rgba(239, 68, 68, 0.1) !important;
            border-left: 3px solid var(--danger);
        }
    
        #comparisonTable .strategy-name {
            cursor: pointer;
            text-decoration: underline;
            color: var(--primary);
            text-align: left !important;
            transition: var(--transition);
        }
    
        #comparisonTable .strategy-name:hover {
            color: var(--primary-dark);
        }
    
        .comparison-table-container.hide-errors .strategy-error-row {
            display: none;
        }
    
        #toggleErrorsBtn {
            background-color: var(--secondary);
            margin-left: 0.5rem;
            font-size: 0.8rem;
            padding: 0.35rem 0.75rem;
        }
    
        #toggleErrorsBtn:hover {
            background-color: var(--secondary-dark);
        }
    
        /* Classes Específicas para Feedback Visual */
        .output-section {
            scroll-margin-top: 15px;
            transition: var(--transition);
        }
    
    
        /* --- Estilos para Montagem de Planos (Formato Cartão/Tabela) --- */
        #lpdBreakdown .plan-container { /* Increased specificity */
            width: 98%;
            max-width: 650px;
            margin: 1rem auto;
            background-color: var(--bg-secondary); /* Card background */
            padding: 10px 15px;
            box-shadow: var(--shadow);
            border-radius: var(--border-radius);
            border: 1px solid var(--border);
            page-break-inside: avoid;
        }
    
        #lpdBreakdown .plan-container h1 { /* Increased specificity */
            color: var(--primary);
            text-align: center;
            margin: 5px 0 10px 0;
            font-size: 1rem;
            border-bottom: 1px solid var(--primary-dark);
            padding-bottom: 5px;
            font-weight: 600;
        }
    
        #lpdBreakdown .plan-container table { /* Increased specificity */
            width: 100%;
            border-collapse: collapse;
            margin-bottom: 10px;
            font-size: 0.8rem;
        }
    
        #lpdBreakdown .plan-container th,
        #lpdBreakdown .plan-container td { /* Increased specificity */
            padding: 4px 6px;
            border: 1px solid var(--border);
            text-align: left;
            color: var(--text-secondary);
            vertical-align: middle;
        }
    
        #lpdBreakdown .plan-container th { /* Increased specificity */
            background-color: var(--primary-dark);
            color: white;
            font-weight: bold;
            text-align: center;
        }
        /* Center align Img and Qtd columns */
        #lpdBreakdown .plan-container th:nth-child(2), /* Header Img */
        #lpdBreakdown .plan-container th:nth-child(3), /* Header Qtd */
        #lpdBreakdown .plan-container td:nth-child(2), /* Body Img */
        #lpdBreakdown .plan-container td:nth-child(3) { /* Body Qtd */
            text-align: center;
        }
    
        #lpdBreakdown .plan-container tr:nth-child(even) td { /* Increased specificity */
             background-color: var(--bg-tertiary);
        }
    
        /* Total row style with !important for background */
        #lpdBreakdown .plan-container tr.total-row td { /* Increased specificity */
            font-weight: bold;
            background-color: var(--primary-light) !important; /* Add !important to ensure override */
            color: white;
        }
        #lpdBreakdown .plan-container .total-row td:first-child { /* Increased specificity */
             text-align: left;
        }
         /* Center align total Img and Qtd */
         #lpdBreakdown .plan-container .total-row td:nth-child(2), /* Total Img */
         #lpdBreakdown .plan-container .total-row td:nth-child(3) { /* Total Qtd */
             text-align: center;
         }
    
    
        /* Scrollbar customizada */
        ::-webkit-scrollbar {
            width: 8px;
            height: 8px;
        }
    
        ::-webkit-scrollbar-track {
            background: var(--bg-tertiary);
        }
    
        ::-webkit-scrollbar-thumb {
            background: var(--border);
            border-radius: 4px;
        }
    
        ::-webkit-scrollbar-thumb:hover {
            background: var(--text-muted);
        }
    
        /* Responsividade */
        @media screen and (max-width: 1100px) {
            body {
                padding-left: 15px;
                padding-right: 15px;
            }
    
            #sidebar {
                display: none; /* Esconde a sidebar em telas menores */
            }
        }
    
        @media screen and (max-width: 768px) {
            body {
                padding: 10px;
                font-size: 0.85rem;
            }
    
            button {
                width: 100%; /* Botões ocupam largura total */
                margin-right: 0;
            }
    
            #finderResultsLog, #foundCombinationDisplay, #statusArea, #strategyComparison,
            #allocationResults, #cumulativeUsage, #adjustmentLog,
            #finalSummaryTableDiv, #variationLog { /* lpdBreakdown removed from group */
                padding: 0.65rem;
            }
            #lpdBreakdown { padding: 0.5rem 0; } /* Restore minimal padding for mobile */
            #lpdBreakdown .plan-container { width: 100%; max-width: none; } /* Plan cards full width */
    
    
            h1 {
                font-size: 1.3rem;
            }
    
            h2 {
                font-size: 1.1rem;
            }
        }
        
        @media print {
    /* Define light mode color variables for printing */
    :root {
        --print-bg-primary: #ffffff;
        --print-bg-secondary: #f8f9fa;
        --print-bg-tertiary: #f1f3f5;
        --print-bg-card: #ffffff;
        --print-text-primary: #212529;
        --print-text-secondary: #495057;
        --print-text-muted: #6c757d;
        --print-border: #dee2e6;
        --print-primary: #0d6efd;
        --print-primary-dark: #0b5ed7;
        --print-primary-light: #e7f1ff;
        --print-success: #198754;  /* Verde para Dif+ */
        --print-danger: #dc3545;   /* Vermelho para Dif- */
        --print-warning: #ffc107;
    }

    body {
        -webkit-print-color-adjust: exact !important;
        print-color-adjust: exact !important;
        color-adjust: exact !important;
        background-color: var(--print-bg-primary) !important;
        color: var(--print-text-primary) !important;
        padding: 10mm !important;
        font-size: 10pt;
        line-height: 1.4;
        font-family: Arial, sans-serif !important;
    }

    /* Hide non-essential elements when printing */
    #sidebar,
    button,
    hr,
    #inputSection,
    #inputSection + p,
    .input-group,
    #finderTitle, #finderResultsLog, #foundCombinationDisplay,
    #allocatorTitle, #statusArea, #strategyComparison,
    #detailsTitle,
    #allocationResults, #adjustmentLog, #variationLog, #cumulativeUsage,
    #finalSummaryTableDiv ~ button, #lpdBreakdown ~ button {
        display: none !important;
    }

    /* Reset styles for main printable content containers */
    #lpdBreakdown, #finalSummaryTableDiv {
        margin: 0 !important;
        padding: 0 !important;
        border: none !important;
        box-shadow: none !important;
        background-color: transparent !important;
        color: var(--print-text-primary) !important;
        width: 100% !important;
        page-break-inside: avoid;
    }

    /* Add space before the Tabela Comparativa to force a new page */
    #finalSummaryTableDiv {
        page-break-before: always !important;
        margin-top: 10mm !important;
    }

    /* Style the overall title for #lpdBreakdown in print */
    #lpdBreakdown > .lpd-section-title {
        text-align: center;
        font-size: 14pt;
        margin-bottom: 10px;
        color: var(--print-text-primary) !important;
        font-weight: bold;
        border-bottom: 1px solid var(--print-border);
        padding-bottom: 5px;
        display: block !important;
    }

    /* Light mode styling for plan containers */
    #lpdBreakdown .plan-container {
        width: 98% !important;
        margin: 1rem auto !important;
        padding: 10px 15px !important;
        border: 1px solid var(--print-border) !important;
        box-shadow: 0 1px 3px rgba(0,0,0,0.1) !important;
        background-color: var(--print-bg-primary) !important;
        page-break-inside: avoid !important;
        border-radius: 4px !important;
    }

    #lpdBreakdown .plan-container h1 {
        color: var(--print-primary) !important;
        text-align: center !important;
        margin: 5px 0 10px 0 !important;
        font-size: 12pt !important;
        border-bottom: 1px solid var(--print-primary) !important;
        padding-bottom: 5px !important;
        font-weight: 600 !important;
    }

    #lpdBreakdown .plan-container table {
        width: 100% !important;
        border-collapse: collapse !important;
        margin-bottom: 10px !important;
        font-size: 9pt !important;
    }

    #lpdBreakdown .plan-container th,
    #lpdBreakdown .plan-container td {
        padding: 5px 8px !important;
        border: 1px solid var(--print-border) !important;
        text-align: left !important;
        color: var(--print-text-secondary) !important;
        vertical-align: middle !important;
    }

    #lpdBreakdown .plan-container th {
        background-color: var(--print-primary) !important;
        color: white !important;
        font-weight: bold !important;
        text-align: center !important;
    }

    /* Center align specific columns */
    #lpdBreakdown .plan-container th:nth-child(2),
    #lpdBreakdown .plan-container th:nth-child(3),
    #lpdBreakdown .plan-container td:nth-child(2),
    #lpdBreakdown .plan-container td:nth-child(3) {
        text-align: center !important;
    }

    #lpdBreakdown .plan-container tr:nth-child(even) td {
        background-color: var(--print-bg-secondary) !important;
    }

    /* Total row styling */
    #lpdBreakdown .plan-container tr.total-row td {
        font-weight: bold !important;
        background-color: var(--print-primary-light) !important;
        color: var(--print-text-primary) !important;
        border-top: 1px solid var(--print-primary) !important;
    }

    #lpdBreakdown .plan-container .total-row td:first-child {
        text-align: left !important;
    }

    #lpdBreakdown .plan-container .total-row td:nth-child(2),
    #lpdBreakdown .plan-container .total-row td:nth-child(3) {
        text-align: center !important;
    }

    /* Final Summary Table Styling - Matching the plans table style */
    #finalSummaryTableDiv .lpd-section-title {
        font-size: 14pt !important;
        text-align: center !important;
        margin-bottom: 10px !important;
        color: var(--print-text-primary) !important;
        font-weight: bold !important;
        border-bottom: 1px solid var(--print-primary) !important;
        padding-bottom: 5px !important;
        display: block !important;
    }

    #finalSummaryTable {
        width: 100% !important;
        border-collapse: collapse !important;
        border-spacing: 0 !important;
        margin-top: 1rem !important;
        font-size: 9pt !important;
        box-shadow: 0 1px 3px rgba(0,0,0,0.1) !important;
        border-radius: 4px !important;
        overflow: hidden !important;
    }

    #finalSummaryTable thead { display: table-header-group; }
    #finalSummaryTable tfoot { display: table-footer-group; }

    #finalSummaryTable th, 
    #finalSummaryTable td {
        border: 1px solid var(--print-border) !important;
        padding: 5px 8px !important;
        text-align: left !important;
        color: var(--print-text-secondary) !important;
    }

    /* Header style matching the plan tables */
    #finalSummaryTable th {
        background-color: var(--print-primary) !important;
        font-weight: 600 !important;
        color: white !important;
        border-bottom: 1px solid var(--print-border) !important;
        text-align: center !important;
    }

    #finalSummaryTable td:nth-child(n+2) {
        text-align: right !important;
    }

    #finalSummaryTable tr:nth-child(even) {
        background-color: var(--print-bg-secondary) !important;
    }

    /* Footer style matching the plan tables total row */
    #finalSummaryTable tfoot th, 
    #finalSummaryTable tfoot td {
        font-weight: bold !important;
        border-top: 1px solid var(--print-primary) !important;
        background-color: var(--print-primary-light) !important;
        color: var(--print-text-primary) !important;
    }

    /* Inverted color indicators */
    .positive-diff {
        color: var(--print-success) !important; /* VERDE para Dif+ (invertido) */
        font-weight: 500 !important;
    }

    .negative-diff {
        color: var(--print-danger) !important; /* VERMELHO para Dif- (invertido) */
        font-weight: 500 !important;
    }

    .zero-diff {
        color: var(--print-text-muted) !important;
    }

    .violation {
        background-color: rgba(220, 53, 69, 0.1) !important;
        color: var(--print-danger) !important;
        border-radius: 2px !important;
        padding: 0.1rem 0.3rem !important;
        font-weight: 500 !important;
    }

    .best-effort {
        background-color: rgba(255, 193, 7, 0.1) !important;
        border-left: 3px solid var(--print-warning) !important;
        font-weight: 500 !important;
    }

    .strategy-error-row {
        background-color: rgba(220, 53, 69, 0.1) !important;
        border-left: 3px solid var(--print-danger) !important;
    }
}
    
    </style>

</head>
<body>

    <!-- Navegação Lateral -->
    <div id="sidebar">
         <h3>Navegação</h3>
         <ul>
             <li><a href="#inputSection">Entradas</a></li>
             <li><a href="#finderTitle">Resultados da Combinação</a></li>
             <li><a href="#finderResultsLog">   • Registro da Combinação</a></li>
             <li><a href="#foundCombinationDisplay">   • Combinação Resultante</a></li>
             <li style="margin-top:10px; border-top: 1px solid var(--border); padding-top: 5px;"><a href="#allocatorTitle">Resultados do Alocador</a></li>
             <li><a href="#statusArea">   • Status</a></li>
             <li><a href="#strategyComparison">   • Comparação de Estratégias</a></li>
             <li><a href="#detailsTitle">   • Resultados Detalhados</a></li>
             <li><a href="#allocationResults">   • • Alocações por Especificação</a></li>
             <li><a href="#adjustmentLog">   • • Registro de Preenchimento</a></li>
             <li><a href="#variationLog">   • • Registro de Variação</a></li>
             <li><a href="#cumulativeUsage">   • • Uso Acumulado</a></li>
             <li><a href="#lpdBreakdown">   • • Montagem dos Planos</a></li>
             <li><a href="#finalSummaryTableDiv">   • • Tabela Comparativa Final</a></li>
         </ul>
    </div>

    <!-- Área de Conteúdo Principal -->
    <h1 id="inputSection">Sistema de Montagem de Planos (Método Selecionável)</h1>
    <p>Insira os dados de Especificações e Quantidades para processamento. Escolha entre: 1) Otimização por Frequência de Maiores Divisores, que analisa os maiores divisores possíveis de cada produto e seleciona Planos baseados em sua recorrência; ou 2) Cálculo de Combinação Proporcional Direta para distribuição equilibrada. O sistema alocará automaticamente as Especificações conforme o método escolhido, apresentando resultados otimizados.</p>    <!-- Campos de Entrada -->
    <div class="input-group">
        <label for="tableData">Dados da Tabela (Especificação + Quantidade, um por linha):</label>
        <textarea id="tableData" placeholder="Exemplo:
Especificação A	10000
Especificação B	7500
Especificação C	20000
..."></textarea>
    </div>
    <div class="input-group">
        <label for="maxSlots">Imagens no Plano :</label>
        <input type="number" id="maxSlots" min="1" placeholder="ex: 8" required>
    </div>
    <div class="input-group">
        <label for="combinationSize">Quantidade de Planos :</label>
        <input type="number" id="combinationSize" value="1" min="1">
    </div>

    <!-- Botões de Ação -->
    <button onclick="initiateProcess('findBest')" class="primary-action">Otimizar por Frequência de Divisores</button>
    <button onclick="initiateProcess('forceProportional')" class="secondary">Aplicar Distribuição Proporcional</button>

    <!-- Áreas de Saída -->

    <!-- Seção para Resultados da Combinação -->
    <hr>
    <h2 id="finderTitle" class="output-section">Resultados da Combinação</h2>
    <div id="finderResultsLog" class="output-section">O registro da geração da combinação aparecerá aqui...</div>
    <div id="foundCombinationDisplay" class="output-section">A Combinação de Planos gerada aparecerá aqui...</div>

    <!-- Seção para Resultados do Alocador -->
    <hr>
    <h2 id="allocatorTitle" class="output-section">Resultados do Alocador de Especificações</h2>
    <div id="statusArea" class="output-section">Mensagens de status do alocador aparecerão aqui...</div>
    <div id="strategyComparison" class="output-section">Resultados da Comparação de Estratégias aparecerão aqui...</div>
    <hr style="margin-top: 1.5rem; border-top: 1px solid var(--border); margin-bottom: 0.5rem;">
    <h2 id="detailsTitle" class="output-section" style="margin-top: 0.5rem; font-size: 1.1em;">Resultados Detalhados da Alocação</h2>
    <div id="allocationResults" class="output-section">Resultados detalhados da Alocação por Especificação aparecerão aqui...</div>
    <div id="adjustmentLog" class="output-section">Registro de Ajuste de Preenchimento de Imagens aparecerá aqui...</div>
    <div id="variationLog" class="output-section">Registro de Ajuste de Variação aparecerá aqui...</div>
    <div id="cumulativeUsage" class="output-section">Uso acumulado de Planos aparecerá aqui...</div>
    <div id="lpdBreakdown" class="output-section">Montagem dos Planos por Instância de Especificação aparecerá aqui...</div>
    <div id="finalSummaryTableDiv" class="output-section">Tabela Comparativa Final da Alocação aparecerá aqui...</div>

    <script>
        // --- ARMAZENAMENTO GLOBAL ---
        let globalStrategyResults = [];
        let globalOriginalItems = []; // Especificações Originais
        let globalUniqueLpdValues = []; // Valores Únicos de Plano
        let globalUserLpdCombinationWithDuplicates = []; // Combinação de Planos do Usuário com Duplicatas
        let globalLpdInstanceCounts = {}; // Contagem de Instâncias de Plano
        let globalInitialTotalSlotsPerValue = {}; // Total Inicial de Imagens por Valor
        let globalMaxSlotsPerInstance = Infinity; // Máximo de Imagens por Instância
        let globalMaxSlotsDisplay = "Ilimitado"; // Exibição Máx Imagens
        let globalCurrentlyDisplayedStrategyName = null; // NEW: Track displayed strategy

        // --- REGRAS DE CONFIGURAÇÃO ---
        const MIN_LPD_VALUE = 2000; // Valor Mínimo do Plano
        const OBLIGATORY_RANGE = 500; // Intervalo Obrigatório
        const TARGET_RANGE_BELOW = 500; // Intervalo Alvo Abaixo
        const TARGET_RANGE_ABOVE = 1000; // Intervalo Alvo Acima
        const TARGET_STEP = 500; // Passo do Alvo
        const PROPORTIONAL_ROUNDING_STEP = 50; // Passo de Arredondamento Proporcional
        const MIN_LPD_VALUE_ALLOC = 0; // Valor Mínimo do Plano na Alocação
        const VARIATION_LIMIT_PASS_3 = 0.25; // Limite de Variação Passo 3
        const REPROCESS_VARIATION_LIMIT = 0.30; // Limite de Variação para Reprocessamento

        // --- FUNÇÕES AUXILIARES ---
        function gcd(a, b) { a = Math.abs(a); b = Math.abs(b); if (b === 0) return a; return gcd(b, a % b); } // mdc
        function arrayGcd(numbers) { if (!numbers || numbers.length === 0) return 0; if (numbers.length === 1) return Math.abs(numbers[0]); let result = Math.abs(numbers[0]); for (let i = 1; i < numbers.length; i++) { result = gcd(result, numbers[i]); if (result === 1) return 1; } return result; } // mdcArray
        function findSumCombinationRecursive(lpdValueObjectsToSearch, target, k, startIndex, currentCombinationValues) {
            if (currentCombinationValues.length === k) {
                const currentSum = currentCombinationValues.reduce((sum, item) => sum + item, 0);
                if (Math.abs(currentSum - target) < 0.01) { return [...currentCombinationValues]; }
                return null;
            }
             if (startIndex >= lpdValueObjectsToSearch.length ||
                currentCombinationValues.length > k ||
                (k > 0 && lpdValueObjectsToSearch.length - startIndex < k - currentCombinationValues.length)) { return null; }
            if (k === 0) return null;
            for (let i = startIndex; i < lpdValueObjectsToSearch.length; i++) {
                const currentLpdValue = lpdValueObjectsToSearch[i].value;
                    currentCombinationValues.push(currentLpdValue);
                    const result = findSumCombinationRecursive(lpdValueObjectsToSearch, target, k, i + 1, currentCombinationValues);
                    if (result) { return result; }
                    currentCombinationValues.pop();
            }
            return null;
         }
        function getFrequencyScore(combination, lpdFrequencies) { // obterPontuacaoFrequencia
             let score = 0; for (const lpdValue of combination) { score += (lpdFrequencies[lpdValue] || 0); } return score;
        }
        function roundToNearest(value, multiple) { // arredondarParaMultiploMaisProximo
             if (multiple <= 0) return Math.round(value); return Math.round(value / multiple) * multiple;
        }
        function findClosestSumWithRepetitionAndSlots(uniqueLpdValuesAvailable, target, remainingSlotsMap) { // encontrarSomaMaisProximaComRepeticaoEImagens
            if (!uniqueLpdValuesAvailable || uniqueLpdValuesAvailable.length === 0) { return { sum: 0, difference: 0 - target, combination: [], error: "Nenhum Plano fornecido para alocação" }; }
            if (target < 0) { return { sum: 0, difference: 0 - target, combination: [], error: "Quantidade alvo não pode ser negativa" }; }
            const validLpdsWithSlots = uniqueLpdValuesAvailable.filter(lpd => lpd > 0 && remainingSlotsMap.hasOwnProperty(lpd) && remainingSlotsMap[lpd] > 0).sort((a, b) => a - b);
            if (validLpdsWithSlots.length === 0) { return { sum: 0, difference: 0 - target, combination: [], error: "Lista de Planos vazia ou nenhum Plano tem imagens restantes" }; }
            const smallestLpd = validLpdsWithSlots[0];
            const maxSum = Math.max(target, 0) + smallestLpd;
            const dp = new Array(maxSum + 1).fill(null);
            dp[0] = { count: 0, usage: {}, lastLpd: null };

            for (let i = 1; i <= maxSum; i++) {
                let bestStateForI = null;
                for (const lpd of validLpdsWithSlots) {
                    const prevSum = i - lpd;
                    if (prevSum >= 0 && dp[prevSum] !== null) {
                        const prevState = dp[prevSum];
                        const currentLpdUsageInThisPath = (prevState.usage[lpd] || 0) + 1;
                        const slotsAvailable = remainingSlotsMap[lpd];

                         if (slotsAvailable === Infinity || currentLpdUsageInThisPath <= slotsAvailable) {
                            const newTotalCount = prevState.count + 1;
                            if (bestStateForI === null || newTotalCount < bestStateForI.count) {
                                const newUsage = { ...prevState.usage }; newUsage[lpd] = currentLpdUsageInThisPath;
                                bestStateForI = { count: newTotalCount, usage: newUsage, lastLpd: lpd };
                            }
                        }
                    }
                }
                dp[i] = bestStateForI;
            }

            let minAbsDiff = Infinity; let closestSum = -1; let bestReachableState = null;
            for (let i = target; i >= 0; i--) { if (dp[i] !== null) { const diff = Math.abs(target - i); if (diff < minAbsDiff || (diff === minAbsDiff && dp[i].count < bestReachableState.count)) { minAbsDiff = diff; closestSum = i; bestReachableState = dp[i]; } if (diff > minAbsDiff && closestSum !== -1) break; } }
            for (let i = target + 1; i <= maxSum; i++) { if (dp[i] !== null) { const diff = Math.abs(i - target); if (diff < minAbsDiff || (diff === minAbsDiff && dp[i].count < bestReachableState.count)) { minAbsDiff = diff; closestSum = i; bestReachableState = dp[i]; } if (diff >= minAbsDiff && closestSum !== -1) break; } }

             if (closestSum === -1) {
                 if (target === 0 && dp[0] !== null) {
                     closestSum = 0; bestReachableState = dp[0];
                 } else {
                     return { sum: 0, difference: 0 - target, combination: [], error: "Não foi possível alcançar a soma alvo ou valor próximo" };
                 }
             }

            const combination = []; let currentSum = closestSum; let currentState = bestReachableState; let safetyCounter = 0; const maxLoops = (currentState?.count || 0) + validLpdsWithSlots.length + 100;
            while (currentSum > 0 && currentState?.lastLpd && safetyCounter < maxLoops) { const usedLpd = currentState.lastLpd; combination.push(usedLpd); const prevSum = currentSum - usedLpd; if (prevSum >= 0 && dp[prevSum] !== null) { currentState = dp[prevSum]; currentSum = prevSum; } else { console.error(`Erro de Backtracking DP: Estado faltando para soma ${prevSum}`); return { sum: closestSum, difference: closestSum - target, combination: combination.sort((a, b) => a - b), error: `Erro de backtracking: Estado faltando para soma ${prevSum}` }; } safetyCounter++; }
             if (safetyCounter >= maxLoops) { console.error("Limite de segurança de backtracking DP atingido."); return { sum: closestSum, difference: closestSum - target, combination: combination.sort((a, b) => a - b), error: "Limite de segurança de backtracking atingido" }; }
             if (currentSum !== 0 && closestSum !== 0) { console.error(`Backtracking DP incompleto (soma final ${currentSum})`); return { sum: closestSum, difference: closestSum - target, combination: combination.sort((a, b) => a - b), error: `Backtracking incompleto (soma final ${currentSum})` }; }
             const reconstructedSum = combination.reduce((a, b) => a + b, 0); if (reconstructedSum !== closestSum) { console.error(`Incompatibilidade na reconstrução DP: ${reconstructedSum} != ${closestSum}`); return { sum: closestSum, difference: closestSum - target, combination: combination.sort((a, b) => a - b), error: `Erro de reconstrução (${reconstructedSum} != ${closestSum})` }; }
             const finalUsageCheck = {}; for(const lpd of combination) { finalUsageCheck[lpd] = (finalUsageCheck[lpd] || 0) + 1; if (remainingSlotsMap[lpd] !== Infinity && finalUsageCheck[lpd] > remainingSlotsMap[lpd]) { console.error(`Limite de imagens violado para Plano ${lpd} na verificação (${finalUsageCheck[lpd]} > ${remainingSlotsMap[lpd]})`); return { sum: closestSum, difference: closestSum - target, combination: combination.sort((a, b) => a - b), error: `Limite de imagens violado para Plano ${lpd} na verificação final` }; } }

             return { sum: closestSum, difference: closestSum - target, combination: combination.sort((a, b) => a - b) };
        }
        function calculateMaxVariation(items, allocations) { // calcularVariacaoMaxima
            let maxAbsPercentage = 0; if (!items || !allocations || items.length !== allocations.length) return Infinity;
            for (let i = 0; i < items.length; i++) { const item = items[i]; const alloc = allocations[i]; if (!alloc || alloc.error || alloc.difference === undefined) continue; const targetAmount = item.amount; const difference = alloc.difference; let currentAbsPercentage = 0; if (targetAmount > 0) { currentAbsPercentage = Math.abs(difference / targetAmount); } else if (alloc.sum !== 0) { currentAbsPercentage = Infinity; } if (currentAbsPercentage > maxAbsPercentage) { maxAbsPercentage = currentAbsPercentage; } }
            return maxAbsPercentage;
         }
        function calculateAverageVariation(items, allocations) { // calcularVariacaoMedia
            let totalPercentageSum = 0; let validItemCount = 0; if (!items || !allocations || items.length !== allocations.length) return 0;
            for (let i = 0; i < items.length; i++) { const item = items[i]; const alloc = allocations[i]; if (alloc && !alloc.error && alloc.difference !== undefined && item.amount > 0) { const absPercentage = Math.abs(alloc.difference / item.amount); totalPercentageSum += absPercentage; validItemCount++; } }
            return validItemCount > 0 ? totalPercentageSum / validItemCount : 0;
        }

        // --- FUNÇÃO FINDER DE COMBINAÇÃO (findBestLpdCombination - com logs traduzidos) ---
        function findBestLpdCombination(parsedItemsData, maxSlotsForTargetCalc, requestedCombinationSize) {
             const functionLog = []; let foundCombination = null; let finderStatus = "OK";
             if (!parsedItemsData || parsedItemsData.length === 0) { return { combination: null, log: '<span class="error">Erro do Finder: Nenhum dado de Especificação processado.</span>', status: "Error" }; }
             if (isNaN(maxSlotsForTargetCalc) || maxSlotsForTargetCalc <= 0) { return { combination: null, log: '<span class="error">Erro do Finder: Imagens Máx. Inválidas.</span>', status: "Error" }; }
             if (isNaN(requestedCombinationSize) || requestedCombinationSize < 1) { return { combination: null, log: `<span class="error">Erro do Finder: Tamanho Combo Inválido (>= 1).</span>`, status: "Error" }; }
             const lpdFrequencies = {}; const validRawAmounts = []; let minAmountFound = Infinity; let sumAmounts = 0;
             parsedItemsData.forEach(item => { const amount = item.amount; validRawAmounts.push(amount); sumAmounts += amount; if (amount < minAmountFound) minAmountFound = amount; const lpd = Math.round(amount / 2); if (lpd >= MIN_LPD_VALUE) { lpdFrequencies[lpd] = (lpdFrequencies[lpd] || 0) + 1; } });
             if (validRawAmounts.length === 0) { return { combination: null, log: `<span class="error">Erro do Finder: Nenhuma quantidade válida.</span>`, status: "Error"}; }
             if (sumAmounts === 0 && validRawAmounts.some(a => a !== 0)) { functionLog.push(`<span class="warning">Aviso do Finder: Soma 0 apesar de itens não-zero.</span>`); }
             else if (sumAmounts === 0) { functionLog.push(`Info do Finder: Soma total 0.`); }
             const uniqueValidLpdListWithFreq = Object.entries(lpdFrequencies).map(([lpd, freq]) => ({ value: parseInt(lpd), frequency: freq })).sort((a, b) => b.frequency - a.frequency || b.value - a.value);
             functionLog.push(`--- Registro do Finder de Combinação (Método 'Melhor') ---`);
             functionLog.push(`Qtd Mín Bruta: ${minAmountFound === Infinity ? 'N/A' : minAmountFound}, Soma Total: ${sumAmounts}`);
             functionLog.push(`Imagens Máx (Alvo): ${maxSlotsForTargetCalc}, Tam. Combo Req.: ${requestedCombinationSize}`);
             functionLog.push(`Planos Válidos Únicos (>=${MIN_LPD_VALUE}): ${uniqueValidLpdListWithFreq.length}`);
             functionLog.push(`Planos (Freq/Valor Ord.): ${uniqueValidLpdListWithFreq.map(l => `${l.value}(${l.frequency})`).join(', ')}`);
             let minLpdValueFound = Infinity; uniqueValidLpdListWithFreq.forEach(lpdObj => { if (lpdObj.value < minLpdValueFound) minLpdValueFound = lpdObj.value; });
             functionLog.push(`Plano Mín Válido: ${minLpdValueFound === Infinity ? 'Nenhum' : minLpdValueFound}`);
             const obligatoryCandidates = minLpdValueFound === Infinity ? [] : uniqueValidLpdListWithFreq.filter(lpdObj => Math.abs(lpdObj.value - minLpdValueFound) <= OBLIGATORY_RANGE).sort((a, b) => a.value - b.value);
             functionLog.push(`Candidatos Próximos ao Mín (+/- ${OBLIGATORY_RANGE}): ${obligatoryCandidates.length} [${obligatoryCandidates.map(c=>c.value).join(', ')}]`);

              if (obligatoryCandidates.length === 0 && requestedCombinationSize > 1) { /* --- FALLBACK MDC --- */
                 functionLog.push(`<span class="fallback-gcd">ALERTA: Nenhum Plano próximo ao mín. Usando Fallback MDC.</span>`);
                 let fallbackLog = [`<div class="fallback-section">--- Cálculo Fallback MDC ---`];
                 const baseTargetAmount = sumAmounts / maxSlotsForTargetCalc; fallbackLog.push(`Quantidade Alvo Base: ${baseTargetAmount.toFixed(2)}`);
                 if (validRawAmounts.length < 1) { fallbackLog.push(`<span class="error">Erro: Nenhuma quantidade válida para MDC.</span>`); finderStatus = "Error"; }
                 else { const gcdAmounts = arrayGcd(validRawAmounts); fallbackLog.push(`MDC das quantidades: ${gcdAmounts}`);
                     if (gcdAmounts <= 0) { fallbackLog.push(`<span class="error">Erro: MDC <= 0 (${gcdAmounts}).</span>`); finderStatus = "Error"; }
                     else { const fallbackTarget = baseTargetAmount === 0 ? 0 : roundToNearest(baseTargetAmount, gcdAmounts); fallbackLog.push(`Alvo Fallback (múltiplo MDC): ${fallbackTarget}`);
                         if (fallbackTarget < 0) { fallbackLog.push(`<span class="error">Erro: Alvo Fallback < 0.</span>`); finderStatus = "Error"; }
                         else { const fallbackK = fallbackTarget === 0 ? 0 : Math.round(fallbackTarget / gcdAmounts);
                             if (fallbackK < 0) { fallbackLog.push(`<span class="error">Erro: Unidades MDC < 0.</span>`); finderStatus = "Error"; }
                             else { fallbackLog.push(`Unidades MDC necessárias: ${fallbackK}`); foundCombination = fallbackK > 0 ? Array(fallbackK).fill(gcdAmounts) : []; fallbackLog.push(`<span class="highlight fallback-gcd">Resultado Fallback MDC: [${foundCombination.join(', ')}]</span> (Tamanho: ${fallbackK})`); }
                         }
                     }
                 }
                 functionLog.push(fallbackLog.join('\n') + `</div>`);
              } else { /* --- PADRÃO / FALLBACK PROPORCIONAL --- */
                 let standardSearchAttempted = false; let overallBestCombination = null; let overallBestFrequencyScore = -1; let overallBestTargetSum = null;
                 if (obligatoryCandidates.length > 0) {
                     standardSearchAttempted = true; functionLog.push(`<span class="info">Estratégia padrão selecionada.</span>`);
                     const baseTargetLPD = sumAmounts / maxSlotsForTargetCalc; const lowerBound = baseTargetLPD - TARGET_RANGE_BELOW; const upperBound = baseTargetLPD + TARGET_RANGE_ABOVE; const targetsToTest = []; const firstMultiple = Math.ceil(lowerBound / TARGET_STEP) * TARGET_STEP; const lastMultiple = Math.floor(upperBound / TARGET_STEP) * TARGET_STEP; for (let target = firstMultiple; target <= lastMultiple; target += TARGET_STEP) { if (target > 0 || (target === 0 && baseTargetLPD === 0)) targetsToTest.push(target); }
                     functionLog.push(`Plano Alvo Base: ${baseTargetLPD.toFixed(2)}, Intervalo [${lowerBound.toFixed(2)}, ${upperBound.toFixed(2)}]`);
                     if (targetsToTest.length === 0) { functionLog.push(`<span class="warning">Aviso: Nenhum múltiplo alvo no intervalo. Tentando Proporcional.</span>`); }
                     else { functionLog.push(`Somas Alvo para Testar: [${targetsToTest.join(', ')}]`); const neededOtherLpds = requestedCombinationSize - 1; functionLog.push(`--- Busca de Combinação (Método Padrão, Precisa de ${neededOtherLpds} outros) ---`);
                         for (const currentTargetSum of targetsToTest) { functionLog.push(`<div class="target-section">--- Testando Soma Alvo: ${currentTargetSum} ---`); let foundCombinationForThisTarget = false;
                             for (const currentObligatoryCandidate of obligatoryCandidates) { const currentObligatoryLpdValue = currentObligatoryCandidate.value; functionLog.push(`<div class="candidate-section">=== Tentando Plano Obrigatório: ${currentObligatoryLpdValue} ===`); const searchLpdList = uniqueValidLpdListWithFreq.filter(lpdObj => lpdObj.value !== currentObligatoryLpdValue);
                                  if (neededOtherLpds > 0 && searchLpdList.length < neededOtherLpds) { functionLog.push(`   Pulando: Não há outros suficientes (${searchLpdList.length}) para tamanho ${requestedCombinationSize}.`); functionLog.push(`</div>`); continue; }
                                  const targetForRecursion = currentTargetSum - currentObligatoryLpdValue; functionLog.push(`   Alvo para os ${neededOtherLpds} restantes: ${targetForRecursion.toFixed(2)}`);
                                  if (neededOtherLpds === 0) {
                                      if (Math.abs(targetForRecursion) < 0.01) {
                                          const currentFullCombination = [currentObligatoryLpdValue]; const currentFrequencyScore = getFrequencyScore(currentFullCombination, lpdFrequencies); functionLog.push(`   <span class="success">Encontrada Soma Exata (Tam 1): [${currentFullCombination.join(', ')}] (Soma: ${currentTargetSum}, Freq: ${currentFrequencyScore})</span>`); foundCombinationForThisTarget = true; if (overallBestCombination === null || currentFrequencyScore > overallBestFrequencyScore || (currentFrequencyScore === overallBestFrequencyScore && currentTargetSum < overallBestTargetSum)) { functionLog.push(`   <span class="info">   ** Nova MELHOR GERAL Encontrada **</span>`); overallBestCombination = currentFullCombination; overallBestFrequencyScore = currentFrequencyScore; overallBestTargetSum = currentTargetSum; }
                                       } else { functionLog.push(`   -> Alvo (${currentTargetSum}) != Plano (${currentObligatoryLpdValue}).`); }
                                    } else if (targetForRecursion >= -0.01) {
                                      const adjustedTargetForRecursion = Math.max(0, targetForRecursion);
                                      let foundKMinus1Combination = findSumCombinationRecursive(searchLpdList, adjustedTargetForRecursion, neededOtherLpds, 0, []);
                                     if (foundKMinus1Combination !== null) { const currentFullCombination = [...foundKMinus1Combination, currentObligatoryLpdValue].sort((a, b) => a - b); const currentFrequencyScore = getFrequencyScore(currentFullCombination, lpdFrequencies); functionLog.push(`   <span class="success">Combo Encontrado: [${currentFullCombination.join(', ')}] (Soma: ${currentTargetSum}, Freq: ${currentFrequencyScore})</span>`); foundCombinationForThisTarget = true; if (overallBestCombination === null || currentFrequencyScore > overallBestFrequencyScore || (currentFrequencyScore === overallBestFrequencyScore && currentTargetSum < overallBestTargetSum)) { functionLog.push(`   <span class="info">   ** Nova MELHOR GERAL Encontrada **</span>`); overallBestCombination = currentFullCombination; overallBestFrequencyScore = currentFrequencyScore; overallBestTargetSum = currentTargetSum; } } else { functionLog.push(`   -> Nenhuma combo de ${neededOtherLpds} encontrada para ${adjustedTargetForRecursion.toFixed(2)}.`); }
                                  } else { functionLog.push(`   -> Alvo restante (${targetForRecursion.toFixed(2)}) negativo.`); } functionLog.push(`</div>`);
                              } if (!foundCombinationForThisTarget) { functionLog.push(`   <span class="info">Nenhuma combinação encontrada para o alvo ${currentTargetSum}.</span>`); } functionLog.push(`</div>`);
                         }
                     }
                 }
                 if (overallBestCombination !== null) {
                      functionLog.push(`--- Resultado do Método Padrão ---`); functionLog.push(`<span class="highlight">Melhor Encontrada: [${overallBestCombination.join(', ')}]</span>`); functionLog.push(`(Soma Alvo: ${overallBestTargetSum}, Pontuação Freq: ${overallBestFrequencyScore})`); foundCombination = overallBestCombination;
                 } else { /* --- FALLBACK PROPORCIONAL --- */
                     if (standardSearchAttempted) { functionLog.push(`<span class="error">Método Padrão Falhou. Tentando Proporcional.</span>`); }
                     else if (requestedCombinationSize > 1) { functionLog.push(`<span class="info">Padrão Pulado (Sem candidatos próx. ao min). Tentando Proporcional.</span>`); }
                     functionLog.push(`<span class="fallback-prop">ALERTA: Usando Fallback Proporcional (Arredondar para ${PROPORTIONAL_ROUNDING_STEP}).</span>`);
                     let propFallbackLog = [`<div class="proportional-fallback-section">--- Cálculo Fallback Proporcional ---`];
                     const averageValuePerSlot = (maxSlotsForTargetCalc > 0 && sumAmounts > 0) ? (sumAmounts / maxSlotsForTargetCalc) : 0; propFallbackLog.push(`Valor Médio por Imagem: ${averageValuePerSlot.toFixed(2)}`);
                     if (requestedCombinationSize === 1) { propFallbackLog.push(`Tam. combo 1: Usando média arredondada.`); const roundedAverage = roundToNearest(averageValuePerSlot, PROPORTIONAL_ROUNDING_STEP); if (roundedAverage <= 0 && averageValuePerSlot > 0) { propFallbackLog.push(`<span class="error">Erro: Média arredondada <= 0.</span>`); finderStatus = "Error"; } else if (roundedAverage <= 0) { propFallbackLog.push(`Info: Média arredondada <= 0. Usando combo vazia.`); foundCombination = []; } else { foundCombination = [roundedAverage]; } if (foundCombination !== null) propFallbackLog.push(`Combo Calculada (Tam 1): [${foundCombination.join(', ')}]`);
                     } else { if (uniqueValidLpdListWithFreq.length < requestedCombinationSize) { propFallbackLog.push(`<span class="error">Erro: Planos únicos insuficientes (${uniqueValidLpdListWithFreq.length}) para tamanho ${requestedCombinationSize}.</span>`); finderStatus = "Error"; }
                         else { const selectedTopLpds = uniqueValidLpdListWithFreq.slice(0, requestedCombinationSize); const selectedLpdValues = selectedTopLpds.map(lpd => lpd.value); propFallbackLog.push(`Top ${requestedCombinationSize} Planos: [${selectedLpdValues.join(', ')}]`); const totalLpdValueMass = selectedLpdValues.reduce((sum, val) => sum + val, 0); propFallbackLog.push(`Soma dos Planos (Base): ${totalLpdValueMass}`);
                             if (totalLpdValueMass <= 0) { propFallbackLog.push(`<span class="error">Erro: Soma dos Planos <= 0.</span>`); finderStatus = "Error"; }
                             else if (averageValuePerSlot <= 0) { propFallbackLog.push(`Info: Valor médio <= 0. Resultado vazio.`); foundCombination = []; }
                             else { propFallbackLog.push(`Distribuindo Valor Médio (${averageValuePerSlot.toFixed(2)})...`); const proportionalCombination = selectedLpdValues.map(lpdVal => roundToNearest(averageValuePerSlot * (lpdVal / totalLpdValueMass), PROPORTIONAL_ROUNDING_STEP)); const finalProportionalCombination = proportionalCombination.filter(v => v > 0);
                                 if (finalProportionalCombination.length === 0) { propFallbackLog.push(`<span class="warning">Aviso: Proporcional resultou em nenhum Plano positivo. Usando vazio.</span>`); foundCombination = []; }
                                 else if (finalProportionalCombination.length < requestedCombinationSize) { propFallbackLog.push(`<span class="warning">Aviso: Proporcional resultou em apenas ${finalProportionalCombination.length} Planos positivos (req ${requestedCombinationSize}). Usando valores positivos.</span>`); foundCombination = finalProportionalCombination.sort((a,b) => a - b); }
                                 else { foundCombination = finalProportionalCombination.sort((a,b) => a - b).slice(0, requestedCombinationSize); }
                                 if (foundCombination !== null) { const sumOfProp = foundCombination.reduce((sum, val) => sum + val, 0); propFallbackLog.push(`Combo Proporcional Calculada (Arred., >0): [${foundCombination.join(', ')}]`); propFallbackLog.push(`Soma: ${sumOfProp} (vs Média Imagem: ${averageValuePerSlot.toFixed(2)})`); }
                             }
                         }
                     } functionLog.push(propFallbackLog.join('\n') + `</div>`);
                 }
              }
             return { combination: foundCombination, log: functionLog.join('\n'), status: finderStatus };
        }

        // --- FUNÇÃO DE COMBINAÇÃO PROPORCIONAL DIRETA ---
        function calculateDirectProportionalCombination(parsedItemsData, maxSlotsForTargetCalc, requestedCombinationSize) {
            const functionLog = [];
            let foundCombination = null;
            let finderStatus = "OK";
            if (!parsedItemsData || parsedItemsData.length === 0) { return { combination: null, log: '<span class="error">Erro Calc Prop: Nenhum dado de Especificação processado.</span>', status: "Error" }; }
            if (isNaN(maxSlotsForTargetCalc) || maxSlotsForTargetCalc <= 0) { return { combination: null, log: '<span class="error">Erro Calc Prop: Imagens Máx. Inválidas.</span>', status: "Error" }; }
            if (isNaN(requestedCombinationSize) || requestedCombinationSize < 1) { return { combination: null, log: `<span class="error">Erro Calc Prop: Tamanho Combo Inválido (>= 1).</span>`, status: "Error" }; }
            const lpdFrequencies = {}; const validRawAmounts = []; const allValidLpds = [];
            let sumAmounts = 0; let minAmountFound = Infinity;
            parsedItemsData.forEach(item => { const amount = item.amount; validRawAmounts.push(amount); sumAmounts += amount; if (amount < minAmountFound) minAmountFound = amount; const lpd = Math.round(amount / 2); if (lpd >= MIN_LPD_VALUE) { lpdFrequencies[lpd] = (lpdFrequencies[lpd] || 0) + 1; allValidLpds.push(lpd); } });
            if (validRawAmounts.length === 0) { return { combination: null, log: `<span class="error">Erro Calc Prop: Nenhuma quantidade válida.</span>`, status: "Error"}; }
             if (sumAmounts === 0 && validRawAmounts.some(a => a !== 0)) { functionLog.push(`<span class="warning">Aviso Calc Prop: Soma 0 apesar de itens não-zero.</span>`); }
             else if (sumAmounts === 0) { functionLog.push(`Info Calc Prop: Soma total 0.`); }
            const uniqueValidLpdListWithFreq = Object.entries(lpdFrequencies).map(([lpd, freq]) => ({ value: parseInt(lpd), frequency: freq })).sort((a, b) => b.frequency - a.frequency || b.value - a.value);
            let minLpdValueFound = Infinity; if (allValidLpds.length > 0) { minLpdValueFound = Math.min(...allValidLpds); }
            const nearMinLpds = minLpdValueFound === Infinity ? [] : uniqueValidLpdListWithFreq.filter(lpdObj => Math.abs(lpdObj.value - minLpdValueFound) <= OBLIGATORY_RANGE).sort((a, b) => b.frequency - a.frequency || a.value - b.value);

            functionLog.push(`--- Registro de Cálculo Proporcional Direto ---`);
            functionLog.push(`Qtd Mín Bruta: ${minAmountFound === Infinity ? 'N/A' : minAmountFound}, Soma Total: ${sumAmounts}`);
            functionLog.push(`Imagens Máx (Alvo): ${maxSlotsForTargetCalc}, Tam. Combo Req.: ${requestedCombinationSize}`);
            functionLog.push(`Planos Válidos Únicos (>=${MIN_LPD_VALUE}): ${uniqueValidLpdListWithFreq.length}`);
            functionLog.push(`Planos (Freq/Valor Ord.): ${uniqueValidLpdListWithFreq.map(l => `${l.value}(${l.frequency})`).join(', ')}`);
            functionLog.push(`Plano Mín Válido: ${minLpdValueFound === Infinity ? 'Nenhum' : minLpdValueFound}`);
            functionLog.push(`Candidatos Próximos ao Mín (+/- ${OBLIGATORY_RANGE}): ${nearMinLpds.length} [${nearMinLpds.map(c=>c.value + '(' + c.frequency + ')').join(', ')}]`);

            if (uniqueValidLpdListWithFreq.length < requestedCombinationSize && requestedCombinationSize > 0) {
                 functionLog.push(`<span class="error">Erro: Planos válidos únicos insuficientes (${uniqueValidLpdListWithFreq.length}) disponíveis para o tamanho solicitado ${requestedCombinationSize}.</span>`);
                 return { combination: null, log: functionLog.join('\n'), status: "Error" };
             }

            functionLog.push(`--- Selecionando Planos para Cálculo Proporcional ---`);
            let selectionLog = [];
            let finalSelectedLpdsForProportion = [];
            if (requestedCombinationSize === 1) {
                selectionLog.push(`Tam. combo 1: Ajuste da regra do Plano Mín não aplicado à seleção.`);
                if (uniqueValidLpdListWithFreq.length > 0) { finalSelectedLpdsForProportion = [uniqueValidLpdListWithFreq[0]]; selectionLog.push(`(Usando valor médio; Plano Top para referência: ${finalSelectedLpdsForProportion[0].value})`); }
                else { selectionLog.push(`(Nenhum Plano único encontrado).`); }
            } else if (requestedCombinationSize > 1) {
                const initialTopLpds = uniqueValidLpdListWithFreq.slice(0, requestedCombinationSize);
                selectionLog.push(`Top ${requestedCombinationSize} Planos Iniciais (por Freq/Valor): [${initialTopLpds.map(l => `${l.value}(${l.frequency})`).join(', ')}]`);
                const initialSelectionValues = initialTopLpds.map(lpd => lpd.value);
                const meetsMinLpdRule = nearMinLpds.length === 0 || initialSelectionValues.some(val => nearMinLpds.some(nearLpd => nearLpd.value === val));

                if (meetsMinLpdRule) {
                    selectionLog.push(`<span class="info">Regra do Plano Mín Atendida: Seleção inicial inclui Plano próximo ao mín (ou nenhum existe).</span>`);
                    finalSelectedLpdsForProportion = initialTopLpds;
                } else {
                    selectionLog.push(`<span class="warning">Regra do Plano Mín NÃO Atendida: Tentando substituição.</span>`);
                    if (nearMinLpds.length > 0) {
                        const bestNearMinLpd = nearMinLpds[0];
                        selectionLog.push(`   - Melhor Candidato Próximo ao Mín: ${bestNearMinLpd.value}(${bestNearMinLpd.frequency})`);
                        let indexToReplace = -1; let minFreq = Infinity; let minValueAtMinFreq = Infinity;
                        for(let i = 0; i < initialTopLpds.length; i++) { const lpd = initialTopLpds[i]; if (nearMinLpds.some(near => near.value === lpd.value)) continue; if (lpd.frequency < minFreq) { minFreq = lpd.frequency; minValueAtMinFreq = lpd.value; indexToReplace = i; } else if (lpd.frequency === minFreq && lpd.value < minValueAtMinFreq) { minValueAtMinFreq = lpd.value; indexToReplace = i; } }
                        if (indexToReplace !== -1) {
                            const lpdToReplace = initialTopLpds[indexToReplace];
                            selectionLog.push(`   - Plano a Substituir (Menor Freq): ${lpdToReplace.value}(${lpdToReplace.frequency})`);
                            let adjustedSelectedTopLpds = [...initialTopLpds]; adjustedSelectedTopLpds[indexToReplace] = bestNearMinLpd;
                            adjustedSelectedTopLpds.sort((a, b) => b.frequency - a.frequency || a.value - b.value);
                            finalSelectedLpdsForProportion = adjustedSelectedTopLpds;
                            selectionLog.push(`<span class="info">   => Planos Finais para Cálculo: [${finalSelectedLpdsForProportion.map(l => `${l.value}(${l.frequency})`).join(', ')}]</span>`);
                        } else {
                             selectionLog.push(`<span class="warning">   - Não foi possível encontrar Plano adequado para substituir. Usando seleção inicial.</span>`);
                             finalSelectedLpdsForProportion = initialTopLpds;
                        }
                    } else {
                        selectionLog.push(`<span class="warning">   - Nenhum candidato próximo ao mínimo disponível para substituição. Usando seleção inicial.</span>`);
                        finalSelectedLpdsForProportion = initialTopLpds;
                    }
                }
            } else {
                 selectionLog.push(`Tamanho de combinação solicitado é 0. O resultado será vazio.`);
                 finalSelectedLpdsForProportion = [];
            }
            functionLog.push(selectionLog.join('\n'));

            functionLog.push(`<div class="proportional-direct-section">--- Cálculo Proporcional ---`);
            let propCalcLog = [];
            const averageValuePerSlot = (maxSlotsForTargetCalc > 0 && sumAmounts > 0) ? (sumAmounts / maxSlotsForTargetCalc) : 0;
            propCalcLog.push(`Valor Médio por Imagem: ${averageValuePerSlot.toFixed(2)}`);

            if (requestedCombinationSize === 1) {
                propCalcLog.push(`Tam. combo 1: Usando média arredondada.`);
                const roundedAverage = roundToNearest(averageValuePerSlot, PROPORTIONAL_ROUNDING_STEP);
                 if (roundedAverage <= 0 && averageValuePerSlot > 0) { propCalcLog.push(`<span class="error">Erro: Média arredondada <= 0.</span>`); finderStatus = "Error"; }
                 else if (roundedAverage <= 0) { propCalcLog.push(`Info: Média arredondada <= 0. Usando combo vazia.`); foundCombination = []; }
                 else { foundCombination = [roundedAverage]; }
                 if (foundCombination !== null) propCalcLog.push(`Combo Calculada (Tam 1): [${foundCombination.join(', ')}]`);
            } else if (requestedCombinationSize > 1) {
                const selectedLpdValues = finalSelectedLpdsForProportion.map(lpd => lpd.value);
                propCalcLog.push(`Usando Valores de Planos para Proporções: [${selectedLpdValues.join(', ')}] (Da etapa de seleção)`);
                const totalLpdValueMass = selectedLpdValues.reduce((sum, val) => sum + val, 0);
                propCalcLog.push(`Soma dos Planos (Base): ${totalLpdValueMass}`);
                if (totalLpdValueMass <= 0) { propCalcLog.push(`<span class="error">Erro: Soma dos Planos selecionados <= 0.</span>`); finderStatus = "Error"; }
                else if (averageValuePerSlot <= 0) { propCalcLog.push(`Info: Valor médio <= 0. Resultado vazio.`); foundCombination = []; }
                else {
                    propCalcLog.push(`Distribuindo Valor Médio (${averageValuePerSlot.toFixed(2)})...`);
                    const proportionalCombination = selectedLpdValues.map(lpdVal => roundToNearest(averageValuePerSlot * (lpdVal / totalLpdValueMass), PROPORTIONAL_ROUNDING_STEP));
                    const finalProportionalCombination = proportionalCombination.filter(v => v > 0);
                    if (finalProportionalCombination.length === 0) { propCalcLog.push(`<span class="warning">Aviso: Proporcional resultou em nenhum Plano positivo. Usando vazio.</span>`); foundCombination = []; }
                    else if (finalProportionalCombination.length < requestedCombinationSize) { propCalcLog.push(`<span class="warning">Aviso: Apenas ${finalProportionalCombination.length} Planos positivos resultaram (req ${requestedCombinationSize}). Usando valores positivos.</span>`); foundCombination = finalProportionalCombination.sort((a,b) => a - b); }
                    else { foundCombination = finalProportionalCombination.sort((a,b) => a - b).slice(0, requestedCombinationSize); }
                    if (foundCombination !== null) { const sumOfProp = foundCombination.reduce((sum, val) => sum + val, 0); propCalcLog.push(`Combo Proporcional Calculada (Arred., >0): [${foundCombination.join(', ')}]`); propCalcLog.push(`Soma: ${sumOfProp} (vs Média Imagem: ${averageValuePerSlot.toFixed(2)})`); }
                }
            } else {
                 propCalcLog.push(`Tam. combo 0 solicitado. Resultado vazio.`);
                 foundCombination = [];
            }
            functionLog.push(propCalcLog.join('\n') + `</div>`);

            return { combination: foundCombination, log: functionLog.join('\n'), status: finderStatus };
        }

        // --- LÓGICA CENTRAL DO ALOCADOR (runAllocationProcess - com logs traduzidos) ---
        function runAllocationProcess(itemsToProcess, userLpdCombinationWithDuplicates, maxSlotsPerInstance) {
             const logs = { adjustment: '', variation: '' }; const maxSlotsIsFinite = maxSlotsPerInstance !== Infinity; const maxSlotsDisplayLocal = maxSlotsIsFinite ? maxSlotsPerInstance : "Ilimitado";
             const uniqueLpdValuesLocal = [...new Set(userLpdCombinationWithDuplicates)].sort((a, b) => a - b); const lpdInstanceCountsLocal = {}; userLpdCombinationWithDuplicates.forEach(lpd => { lpdInstanceCountsLocal[lpd] = (lpdInstanceCountsLocal[lpd] || 0) + 1; }); const initialTotalSlotsPerValueLocal = {}; uniqueLpdValuesLocal.forEach(lpd => { const instances = lpdInstanceCountsLocal[lpd] || 0; initialTotalSlotsPerValueLocal[lpd] = maxSlotsIsFinite ? (instances * maxSlotsPerInstance) : Infinity; });
             const currentRemainingSlots = { ...initialTotalSlotsPerValueLocal };
             const currentItemAllocations = new Array(itemsToProcess.length).fill(null).map(() => ({ sum: 0, difference: 0, combination: [], finalUsageCounts: {}, error: null }));
             logs.adjustment += `--- Passo 1: Alocação DP Inicial (Imagens Máx/Instância: ${maxSlotsDisplayLocal}) ---\n`;
             itemsToProcess.forEach((item, i) => { logs.adjustment += `Especificação ${item.index + 1} ('${item.details}', Alvo: ${item.amount}): `; const allocation = findClosestSumWithRepetitionAndSlots([...uniqueLpdValuesLocal], item.amount, currentRemainingSlots); currentItemAllocations[i] = { sum: allocation.sum, difference: allocation.difference, combination: allocation.combination ? [...allocation.combination] : [], finalUsageCounts: {}, error: allocation.error || null }; if (allocation.error) { logs.adjustment += `<span class="error">Erro: ${allocation.error}</span>\n`; } else { logs.adjustment += `Soma Enc ${allocation.sum} (Dif: ${allocation.difference}), Combo: [${allocation.combination.join(', ')}]\n`; if (allocation.combination && allocation.combination.length > 0) { allocation.combination.forEach(lpd => { if (currentRemainingSlots.hasOwnProperty(lpd)) { if (currentRemainingSlots[lpd] > 0) { if (maxSlotsIsFinite) { currentRemainingSlots[lpd]--; } } else { console.warn(`Aviso Imagem Passo 1: Plano ${lpd} usado para Especificação ${item.details} quando imagens eram 0.`); currentItemAllocations[i].error = (currentItemAllocations[i].error || "") + ` Aviso: Usou Plano ${lpd} além das imagens.`; } } else { console.error(`Erro Lógica Passo 1: Plano ${lpd} usado mas não no mapa de imagens.`); currentItemAllocations[i].error = (currentItemAllocations[i].error || "") + ` Erro Crít: Usou Plano ${lpd} não no mapa.`; } }); } } });
             logs.adjustment += `Imagens Rem Após Passo 1: ${JSON.stringify(currentRemainingSlots)}\n`;
             let adjustmentLogHTML = `--- Passo 2: Preenchimento de Imagens (Imagens Máx/Instância: ${maxSlotsDisplayLocal}) ---`; if (maxSlotsIsFinite) { adjustmentLogHTML += `\nImagens Rem Iniciais Passo 2: ${JSON.stringify(currentRemainingSlots, null, 0)}`; let totalRemainingPass2 = Object.values(currentRemainingSlots).reduce((sum, count) => count === Infinity ? sum : sum + count, 0); adjustmentLogHTML += `\nTotal Imagens Finitas Rem: ${totalRemainingPass2}`; let adjustmentSafetyCounter = 0; const maxAdjustments = totalRemainingPass2 + itemsToProcess.length * uniqueLpdValuesLocal.length + 50; while (totalRemainingPass2 > 0 && adjustmentSafetyCounter < maxAdjustments) { adjustmentSafetyCounter++; let bestMove = { lpdToAdd: null, itemIndex: -1, minImpact: Infinity, currentAbsDiff: Infinity }; for (const lpd of uniqueLpdValuesLocal) { if (currentRemainingSlots[lpd] > 0) { for (let i = 0; i < currentItemAllocations.length; i++) { const currentAlloc = currentItemAllocations[i]; if (currentAlloc.error || currentAlloc.sum === undefined) continue; const originalAmount = itemsToProcess[i].amount; const currentSum = currentAlloc.sum; const currentAbsDifference = Math.abs(currentAlloc.difference); const newSum = currentSum + lpd; const newAbsDifference = Math.abs(newSum - originalAmount); const impact = newAbsDifference - currentAbsDifference; if (impact < bestMove.minImpact) { bestMove = { lpdToAdd: lpd, itemIndex: i, minImpact: impact, currentAbsDiff: currentAbsDifference }; } else if (impact === bestMove.minImpact && currentAbsDifference > bestMove.currentAbsDiff) { bestMove = { lpdToAdd: lpd, itemIndex: i, minImpact: impact, currentAbsDiff: currentAbsDifference }; } } } } if (bestMove.lpdToAdd !== null) { const lpd = bestMove.lpdToAdd; const itemIdx = bestMove.itemIndex; adjustmentLogHTML += `<div class="adjustment-step">Passo ${adjustmentSafetyCounter}: Adic Plano <span class="info">${lpd}</span> ao Especificação ${itemsToProcess[itemIdx].index + 1} ('${itemsToProcess[itemIdx].details}') (Impacto: ${bestMove.minImpact >= 0 ? '+' : ''}${bestMove.minImpact.toFixed(0)})`; currentItemAllocations[itemIdx].combination.push(lpd); currentItemAllocations[itemIdx].combination.sort((a, b) => a - b); currentItemAllocations[itemIdx].sum += lpd; currentItemAllocations[itemIdx].difference = currentItemAllocations[itemIdx].sum - itemsToProcess[itemIdx].amount; if (maxSlotsIsFinite) { currentRemainingSlots[lpd]--; totalRemainingPass2--; adjustmentLogHTML += `\n   -> Nova Soma: ${currentItemAllocations[itemIdx].sum}, Dif: ${currentItemAllocations[itemIdx].difference.toFixed(0)}, Imagens Rem ${lpd}: ${currentRemainingSlots[lpd]}</div>`; } else { adjustmentLogHTML += `\n   -> Nova Soma: ${currentItemAllocations[itemIdx].sum}, Dif: ${currentItemAllocations[itemIdx].difference.toFixed(0)} (Imagens Ilimitadas)</div>`; } } else { adjustmentLogHTML += `\n<span class="warning">Parado Passo 2: Nenhum movimento benéfico. ${totalRemainingPass2} imagens finitas restantes.</span>`; break; } } if (adjustmentSafetyCounter >= maxAdjustments) { adjustmentLogHTML += `\n<span class="error">Parado Passo 2: Limite de segurança (${maxAdjustments}) atingido.</span>`; } adjustmentLogHTML += `\nImagens Rem Após Passo 2: ${JSON.stringify(currentRemainingSlots)}`; } else { adjustmentLogHTML += `\n(Pulado: Imagens Máx Ilimitadas)`; } logs.adjustment = adjustmentLogHTML;
             let variationLogHTML = `--- Passo 3: Correção de Variação (Alvo: ±${(VARIATION_LIMIT_PASS_3 * 100).toFixed(0)}%) ---`; let madeVariationAdjustment = true; let variationLoopCounter = 0; const maxVariationLoops = itemsToProcess.length * uniqueLpdValuesLocal.length * 3 + 50; while (madeVariationAdjustment && variationLoopCounter < maxVariationLoops) { variationLoopCounter++; madeVariationAdjustment = false; let worstViolation = { index: -1, percentageDiff: 0, absDifference: 0 }; currentItemAllocations.forEach((alloc, i) => { if (alloc && !alloc.error && alloc.difference !== undefined) { const item = itemsToProcess[i]; const targetAmount = item.amount; let currentAbsPercentage = 0; const currentAbsDifference = Math.abs(alloc.difference); if (targetAmount > 0) { currentAbsPercentage = currentAbsDifference / targetAmount; } else if (alloc.sum !== 0) { currentAbsPercentage = Infinity; } if (currentAbsPercentage > VARIATION_LIMIT_PASS_3) { if (currentAbsPercentage > worstViolation.percentageDiff || (currentAbsPercentage === worstViolation.percentageDiff && currentAbsDifference > worstViolation.absDifference)) { worstViolation = { index: i, percentageDiff: currentAbsPercentage, absDifference: currentAbsDifference }; } } } }); if (worstViolation.index === -1) { variationLogHTML += `\nIter ${variationLoopCounter}: Nenhum item > ±${(VARIATION_LIMIT_PASS_3 * 100).toFixed(0)}%. Passo 3 completo.`; break; } const itemIdx = worstViolation.index; const currentAlloc = currentItemAllocations[itemIdx]; const originalAmount = itemsToProcess[itemIdx].amount; variationLogHTML += `<div class="variation-step">Iter ${variationLoopCounter}: Corrigindo Especificação ${itemsToProcess[itemIdx].index + 1} ('${itemsToProcess[itemIdx].details}') - Dif: ${currentAlloc.difference.toFixed(0)} (${(worstViolation.percentageDiff * 100).toFixed(1)}%)`; let bestFix = { action: null, lpd: null, finalAbsDiff: Math.abs(currentAlloc.difference), finalPercDiff: worstViolation.percentageDiff }; const currentCombinationCopy = [...currentAlloc.combination]; for (const lpdToRemove of new Set(currentCombinationCopy)) { const newSum = currentAlloc.sum - lpdToRemove; const newAbsDiff = Math.abs(newSum - originalAmount); let newPercentageDiff = originalAmount > 0 ? newAbsDiff / originalAmount : (newSum === 0 ? 0 : Infinity); if (newPercentageDiff <= VARIATION_LIMIT_PASS_3) { if (newAbsDiff < bestFix.finalAbsDiff) { bestFix = { action: 'remove', lpd: lpdToRemove, finalAbsDiff: newAbsDiff, finalPercDiff: newPercentageDiff }; } } else if (bestFix.action === null && newAbsDiff < bestFix.finalAbsDiff) { bestFix = { action: 'remove', lpd: lpdToRemove, finalAbsDiff: newAbsDiff, finalPercDiff: newPercentageDiff }; } } for (const lpdToAdd of uniqueLpdValuesLocal) { if (maxSlotsIsFinite && currentRemainingSlots[lpdToAdd] <= 0) continue; const newSum = currentAlloc.sum + lpdToAdd; const newAbsDiff = Math.abs(newSum - originalAmount); let newPercentageDiff = originalAmount > 0 ? newAbsDiff / originalAmount : (newSum === 0 ? 0 : Infinity); if (newPercentageDiff <= VARIATION_LIMIT_PASS_3) { if (newAbsDiff < bestFix.finalAbsDiff) { bestFix = { action: 'add', lpd: lpdToAdd, finalAbsDiff: newAbsDiff, finalPercDiff: newPercentageDiff }; } } else if (bestFix.action === null && newAbsDiff < bestFix.finalAbsDiff) { bestFix = { action: 'add', lpd: lpdToAdd, finalAbsDiff: newAbsDiff, finalPercDiff: newPercentageDiff }; } } if (bestFix.action) { madeVariationAdjustment = true; const lpd = bestFix.lpd; variationLogHTML += ` -> Ação: <span class="info">${bestFix.action === 'remove' ? 'REMOVER' : 'ADICIONAR'} ${lpd}</span>`; if (bestFix.action === 'remove') { const indexToRemove = currentItemAllocations[itemIdx].combination.indexOf(lpd); if (indexToRemove > -1) { currentItemAllocations[itemIdx].combination.splice(indexToRemove, 1); currentItemAllocations[itemIdx].sum -= lpd; currentItemAllocations[itemIdx].difference -= lpd; if (maxSlotsIsFinite) { currentRemainingSlots[lpd]++; } } else { console.error(`Erro VFix: remover ${lpd} não encontrado em ${itemIdx}`); variationLogHTML += ` <span class="error">(Erro!)</span>`; madeVariationAdjustment = false; } } else { currentItemAllocations[itemIdx].combination.push(lpd); currentItemAllocations[itemIdx].combination.sort((a, b) => a - b); currentItemAllocations[itemIdx].sum += lpd; currentItemAllocations[itemIdx].difference += lpd; if (maxSlotsIsFinite) { currentRemainingSlots[lpd]--; } } const finalPercDiffCheck = originalAmount > 0 ? Math.abs(currentItemAllocations[itemIdx].difference / originalAmount) : (currentItemAllocations[itemIdx].sum === 0 ? 0 : Infinity); variationLogHTML += ` -> Nova Dif: ${currentItemAllocations[itemIdx].difference.toFixed(0)} (${(finalPercDiffCheck * 100).toFixed(1)}%)`; if (finalPercDiffCheck <= VARIATION_LIMIT_PASS_3) { variationLogHTML += ` <span class="success">(OK)</span>`; } else { variationLogHTML += ` <span class="warning">(Ainda Alto)</span>`; } if (maxSlotsIsFinite) { variationLogHTML += `, Imagens Rem ${lpd}: ${currentRemainingSlots[lpd]}`; } } else { variationLogHTML += ` -> <span class="warning">Nenhuma correção encontrada. Parando Passo 3.</span>`; madeVariationAdjustment = false; } variationLogHTML += `</div>`; } if (variationLoopCounter >= maxVariationLoops) { variationLogHTML += `\n<span class="error">Parado Passo 3: Limite de loop (${maxVariationLoops}) atingido.</span>`; } logs.variation = variationLogHTML;
             let finalCumulativeUsage = {}; uniqueLpdValuesLocal.forEach(lpd => { finalCumulativeUsage[lpd] = 0; }); currentItemAllocations.forEach(alloc => { alloc.finalUsageCounts = {}; if (!alloc.error && alloc.combination) { alloc.combination.forEach(lpd => { alloc.finalUsageCounts[lpd] = (alloc.finalUsageCounts[lpd] || 0) + 1; if (finalCumulativeUsage.hasOwnProperty(lpd)) { finalCumulativeUsage[lpd]++; } else { console.error(`Erro Lógica Contagem Final: Plano ${lpd} usado mas não na lista única.`); } }); } });
             return { itemAllocations: currentItemAllocations, cumulativeUsage: finalCumulativeUsage, remainingSlots: currentRemainingSlots, logs: logs };
        }

        // --- FUNÇÕES DE EXIBIÇÃO DO ALOCADOR ---
        function displayStrategyDetails(encodedStrategyName) { // exibirDetalhesEstrategia
             const strategyName = decodeURIComponent(encodedStrategyName);
             globalCurrentlyDisplayedStrategyName = strategyName; // Store the name
             console.log(`Exibindo detalhes para: ${strategyName}`);

             // Get references to DOM elements
             const statusAreaDiv = document.getElementById('statusArea');
             const detailsTitle = document.getElementById('detailsTitle');
             const allocationResultsDiv = document.getElementById('allocationResults');
             const adjustmentLogDiv = document.getElementById('adjustmentLog');
             const variationLogDiv = document.getElementById('variationLog');
             const cumulativeUsageDiv = document.getElementById('cumulativeUsage');
             const lpdBreakdownDiv = document.getElementById('lpdBreakdown');
             const finalSummaryTableDiv = document.getElementById('finalSummaryTableDiv');
             // Find the result data for the selected strategy
             const selectedResult = globalStrategyResults.find(res => res.strategyName === strategyName);

             // Reset UI elements
             allocationResultsDiv.innerHTML = 'Carregando...';
             adjustmentLogDiv.innerHTML = '';
             variationLogDiv.innerHTML = '';
             cumulativeUsageDiv.innerHTML = '';
             lpdBreakdownDiv.innerHTML = '';
             finalSummaryTableDiv.innerHTML = '';

             // Validate if result data exists
             if (!selectedResult) {
                 statusAreaDiv.innerHTML = `<span class="error">Erro: Não foi possível encontrar resultados para "${strategyName}".</span>`;
                 detailsTitle.innerHTML = 'Resultados Detalhados';
                 allocationResultsDiv.innerHTML = '';
                 globalCurrentlyDisplayedStrategyName = null; // Reset on error
                 return;
             }
             if (!selectedResult.resultData || !selectedResult.resultData.itemAllocations) {
                 statusAreaDiv.innerHTML = `<span class="error">Erro: Dados incompletos para "${strategyName}".</span>`;
                 detailsTitle.innerHTML = 'Resultados Detalhados';
                 allocationResultsDiv.innerHTML = '<span class="error">Dados incompletos.</span>';
                 globalCurrentlyDisplayedStrategyName = null; // Reset on error
                 return;
             }

             // Start displaying results
             try {
                 statusAreaDiv.innerHTML = `Exibindo detalhes para estratégia: <span class="info">${strategyName}</span>`;
                 detailsTitle.innerHTML = `Resultados Detalhados da Alocação (Estratégia: ${strategyName})`;

                 // Destructure necessary data from the selected result
                 const finalItems = selectedResult.itemsUsed;
                 const finalAllocations = selectedResult.resultData.itemAllocations;
                 const finalCumulativeUsage = selectedResult.resultData.cumulativeUsage;
                 const finalRemainingSlots = selectedResult.resultData.remainingSlots;
                 const finalLogs = selectedResult.resultData.logs;
                 const uniqueLpdValuesDisplay = globalUniqueLpdValues;
                 const maxSlotsDisplayLocal = globalMaxSlotsDisplay;
                 const originalItemsUnsorted = globalOriginalItems;
                 const initialTotalSlotsPerValueLocal = globalInitialTotalSlotsPerValue;
                 const lpdInstanceCountsLocal = globalLpdInstanceCounts;
                 const userLpdCombinationWithDuplicatesLocal = globalUserLpdCombinationWithDuplicates;
                 const maxSlotsNum = globalMaxSlotsPerInstance;
                 const maxSlotsIsFinite = globalMaxSlotsPerInstance !== Infinity;

                 // Display Adjustment and Variation Logs
                 adjustmentLogDiv.innerHTML = finalLogs.adjustment || "Nenhum registro de ajuste.";
                 variationLogDiv.innerHTML = finalLogs.variation || "Nenhum registro de variação.";

                 // --- 1. Generate HTML for Final Item Allocations ---
                 let finalAllocationHTML = `--- Alocações Finais por Especificação (Estratégia: ${selectedResult.strategyName}) ---`;
                 if (finalItems && finalAllocations && finalItems.length === finalAllocations.length) {
                     finalItems.forEach((item, i) => {
                         finalAllocationHTML += `<div class="item-allocation">`;
                         finalAllocationHTML += `<b>${i + 1}. ${item.details}</b> (Linha Orig: ${item.originalIndex + 1}, Alvo: ${item.amount})\n`;
                         const finalAlloc = finalAllocations[i];
                         if (!finalAlloc) {
                             finalAllocationHTML += `<span class="error">Dados de aloc. ausentes.</span>\n`;
                         } else if (finalAlloc.error) {
                             finalAllocationHTML += `<span class="error">Erro Aloc: ${finalAlloc.error}</span>\n`;
                         } else if (finalAlloc.sum !== undefined) {
                             const finalPercDiff = item.amount > 0 ? (finalAlloc.difference / item.amount) : (finalAlloc.sum === 0 ? 0 : Infinity);
                             const absFinalPercDiff = Math.abs(finalPercDiff);
                             let diffClass = finalAlloc.difference === 0 ? 'zero-diff' : (finalAlloc.difference > 0 ? 'positive-diff' : 'negative-diff');
                             let diffSign = finalAlloc.difference > 0 ? '+' : '';
                             finalAllocationHTML += `<span class="highlight">Soma: ${finalAlloc.sum}</span> (Dif: <span class="${diffClass}">${diffSign}${finalAlloc.difference.toFixed(0)}</span>`;
                             if (item.amount > 0) {
                                 finalAllocationHTML += ` / ${(finalPercDiff * 100).toFixed(1)}%`;
                                 if (absFinalPercDiff > REPROCESS_VARIATION_LIMIT) { finalAllocationHTML += ` <span class="violation">>±${(REPROCESS_VARIATION_LIMIT * 100).toFixed(0)}%</span>`; }
                                 else if (absFinalPercDiff > VARIATION_LIMIT_PASS_3) { finalAllocationHTML += ` <span class="warning">>±${(VARIATION_LIMIT_PASS_3 * 100).toFixed(0)}%</span>`; }
                             } else if (finalAlloc.sum !== 0) {
                                 finalAllocationHTML += ` <span class="violation">Soma não zero para alvo zero</span>`;
                             }
                             finalAllocationHTML += `)\n`;
                             if (finalAlloc.combination && finalAlloc.combination.length > 0) {
                                 finalAllocationHTML += `   Combo (${finalAlloc.combination.length}): [${finalAlloc.combination.join(', ')}]`;
                                 if (finalAlloc.finalUsageCounts && Object.keys(finalAlloc.finalUsageCounts).length > 0) {
                                     finalAllocationHTML += `\n   Uso: { ${Object.entries(finalAlloc.finalUsageCounts).map(([lpd, count]) => `"${lpd}": ${count}`).join(', ')} }`;
                                 } else { finalAllocationHTML += `\n   Uso: {}`; }
                             } else { finalAllocationHTML += `   (Nenhum Plano alocado)`; }
                         } else { finalAllocationHTML += "<span class='error'>Estrutura Aloc Inválida</span>"; }
                         finalAllocationHTML += `</div>`;
                     });
                 } else { finalAllocationHTML += '<span class="error">Incompatibilidade Especificação/Aloc.</span>'; }
                 allocationResultsDiv.innerHTML = finalAllocationHTML;

                 // --- 2. Generate HTML for Cumulative Usage ---
                 let usageSummaryHTML = `<div class="usage-summary">--- Uso Acumulado de Planos (Estrat: ${selectedResult.strategyName}, Imagens Máx/Inst: ${maxSlotsDisplayLocal}) ---<ul>`;
                 if (uniqueLpdValuesDisplay && uniqueLpdValuesDisplay.length > 0) {
                     uniqueLpdValuesDisplay.forEach(lpd => {
                         const initialTotal = initialTotalSlotsPerValueLocal[lpd] || 0;
                         const usedTotal = finalCumulativeUsage[lpd] || 0;
                         let remainingTotal;
                         if(maxSlotsIsFinite) { remainingTotal = finalRemainingSlots.hasOwnProperty(lpd) ? finalRemainingSlots[lpd] : (initialTotal - usedTotal); }
                         else { remainingTotal = Infinity; }
                         const numInstances = lpdInstanceCountsLocal[lpd] || 0;
                         usageSummaryHTML += `<li>Plano <b>${lpd}</b> (${numInstances} inst): Usado <b>${usedTotal}</b>`;
                         if (maxSlotsIsFinite) {
                             usageSummaryHTML += ` (Inicial: ${initialTotal}, Rem: ${remainingTotal})`;
                             if (remainingTotal < 0) { usageSummaryHTML += ` <span class="error">(Erro de Imagem!)</span>`; }
                             else if (usedTotal + remainingTotal !== initialTotal && initialTotal !== Infinity) { console.warn(`Incompatibilidade Imagem Plano ${lpd}: Usado ${usedTotal}, Rem ${remainingTotal}, Inicial ${initialTotal}. Estrat: ${strategyName}`); usageSummaryHTML += ` <span class="warning">(Incompatibilidade Contagem?)</span>`; }
                         }
                         usageSummaryHTML += `</li>`;
                     });
                 } else { usageSummaryHTML += "<li>Nenhum Plano para rastrear.</li>"; }
                 usageSummaryHTML += "</ul></div>";
                 cumulativeUsageDiv.innerHTML = usageSummaryHTML;

                 // --- 3. Generate HTML for Plan Assembly (Montagem dos Planos)
                 let lpdBreakdownHTML = `<div class="lpd-section-title" style="text-align: center; font-size: 1.1em; margin-bottom: 1rem;">--- Montagem dos Planos (Estratégia: ${selectedResult.strategyName}) ---</div>`;
                 const allLpdUses = [];
                 finalItems.forEach((item, i) => {
                     const finalAlloc = finalAllocations[i];
                     if (finalAlloc && !finalAlloc.error && finalAlloc.combination) {
                         finalAlloc.combination.forEach(lpdVal => {
                             allLpdUses.push({ itemIndex: i, itemDetails: item.details, lpdValue: lpdVal, assignedInstanceKey: null });
                         });
                     }
                 });

                 const lpdInstanceCounters = {};
                 const breakdownByInstance = {}; // Temporary map to assign items
                 let planAssemblyDataForExport = []; // Array to store structured data

                 if (userLpdCombinationWithDuplicatesLocal && userLpdCombinationWithDuplicatesLocal.length > 0) {
                     // --- First Pass: Assign items to instances based on availability ---
                     userLpdCombinationWithDuplicatesLocal.forEach(lpdInputVal => {
                         const currentInstanceNum = (lpdInstanceCounters[lpdInputVal] || 0) + 1;
                         lpdInstanceCounters[lpdInputVal] = currentInstanceNum;
                         const instanceKey = `${lpdInputVal}_${currentInstanceNum}`;
                         breakdownByInstance[instanceKey] = { lpdValue: lpdInputVal, instanceNum: currentInstanceNum, itemsData: [], totalUsed: 0 }; // Initialize temporary structure
                         let assignedToThisInstance = 0;
                         for (let use of allLpdUses) {
                             if (use.lpdValue === lpdInputVal && use.assignedInstanceKey === null) {
                                 if (!maxSlotsIsFinite || assignedToThisInstance < maxSlotsNum) {
                                     use.assignedInstanceKey = instanceKey; // Mark item as assigned to this instance
                                     assignedToThisInstance++;
                                 }
                                 if (maxSlotsIsFinite && assignedToThisInstance >= maxSlotsNum) break; // Stop if instance is full
                             }
                         }
                     });

                     // --- Second Pass: Aggregate assigned items and structure data ---
                     Object.keys(breakdownByInstance).forEach(instanceKey => {
                         const instanceDataTemp = breakdownByInstance[instanceKey];
                         const usesForThisInstance = allLpdUses.filter(use => use.assignedInstanceKey === instanceKey);
                         const totalUsedInInstance = usesForThisInstance.length; // Actual number of slots used
                         const itemsMap = {}; // Aggregate items per instance
                         usesForThisInstance.forEach(use => { itemsMap[use.itemDetails] = (itemsMap[use.itemDetails] || 0) + 1; });
                         const itemsArray = Object.entries(itemsMap).map(([details, count]) => ({ details, count })).sort((a, b) => a.details.localeCompare(b.details)); // Sort items alphabetically

                         // Add the structured data to the export array
                         planAssemblyDataForExport.push({
                             planValue: instanceDataTemp.lpdValue,
                             instanceNum: instanceDataTemp.instanceNum, // Keep original instance num if needed elsewhere
                             totalUsed: totalUsedInInstance,
                             maxSlots: maxSlotsIsFinite ? maxSlotsNum : Infinity,
                             items: itemsArray
                         });
                     });

                     // Sort the final structured data by plan value, then instance number (ensures consistent order)
                     planAssemblyDataForExport.sort((a, b) => {
                         return a.planValue - b.planValue || a.instanceNum - b.instanceNum;
                     });
                     selectedResult.planAssemblyDataForExport = planAssemblyDataForExport;

                     // --- Third Pass: Generate HTML using the structured data (new card format) ---
                     if (planAssemblyDataForExport.length > 0) {
                         let overallPlanIndex = 0; // Initialize overall counter
                         planAssemblyDataForExport.forEach(instance => {
                             // Check if this instance actually has items assigned before creating the card
                             if (instance.items.length > 0 || instance.totalUsed > 0) {
                                 overallPlanIndex++; // Increment counter for each displayed plan

                                 lpdBreakdownHTML += `<div class="plan-container">`;
                                 // Use the overallPlanIndex for sequential numbering
                                 lpdBreakdownHTML += `<h1>Plano ${overallPlanIndex} - ${instance.planValue} Folhas</h1>`;
                                 lpdBreakdownHTML += `<table><thead><tr><th>Item</th><th>Img</th><th>Qtd</th></tr></thead><tbody>`;

                                 let totalInstanceQtd = 0;
                                 instance.items.forEach(item => {
                                     const itemQtd = item.count * instance.planValue;
                                     totalInstanceQtd += itemQtd;
                                     // CORRECTED: Removed comments from template literal
                                     lpdBreakdownHTML += `<tr>
                                                            <td>${item.details}</td>
                                                            <td>${item.count}</td>
                                                            <td>${itemQtd.toFixed(0)}</td>
                                                         </tr>`;
                                 });

                                 // Total Row for the instance
                                 // CORRECTED: Removed comments from template literal
                                 lpdBreakdownHTML += `<tr class="total-row">
                                                        <td><strong>TOTAL</strong></td>
                                                        <td><strong>${instance.totalUsed}</strong></td>
                                                        <td><strong>${totalInstanceQtd.toFixed(0)}</strong></td>
                                                     </tr>`;

                                 lpdBreakdownHTML += `</tbody></table></div>`; // Close table and container
                             }
                         });
                         // If after checking all instances, none had items, display a message
                         if (overallPlanIndex === 0) { // Check if any plan was actually generated
                              lpdBreakdownHTML += "<p style='text-align: center; color: var(--text-muted);'>Nenhuma instância de plano com itens alocados para exibir.</p>";
                         }

                     } else {
                          lpdBreakdownHTML += "<p style='text-align: center; color: var(--text-muted);'>Nenhuma instância de plano para exibir.</p>";
                     }

                     // Check for unassigned uses (important sanity check)
                     const unassignedUses = allLpdUses.filter(use => use.assignedInstanceKey === null);
                     if (unassignedUses.length > 0) {
                         console.warn(`Estrat ${strategyName}: ${unassignedUses.length} usos de Plano não atribuídos.`, unassignedUses);
                         lpdBreakdownHTML += `<div class="lpd-section" style="text-align: center;"><span class="lpd-section-title warning">Aviso: ${unassignedUses.length} usos de Plano não atribuídos.</span></div>`;
                     }

                 } else { // Case where no LPD combination was generated
                     lpdBreakdownHTML += "<p style='text-align: center; color: var(--text-muted);'>Nenhuma combinação de Planos para detalhar.</p>";
                     selectedResult.planAssemblyDataForExport = []; // Ensure export data exists but is empty
                 }
                 lpdBreakdownDiv.innerHTML = lpdBreakdownHTML; // Update the div content


                 // --- 4. Generate HTML for Final Summary Table (Tabela Comparativa) with Totals ---
                 let summaryTableHTML = `<div class="lpd-section-title">--- Tabela Comparativa (Estrat: ${selectedResult.strategyName}) ---</div><table id="finalSummaryTable"><thead><tr><th>Especificação</th><th>Quantidade</th><th>Empenho</th><th>Dif</th><th>Var (%)</th></tr></thead><tbody>`;
                 const allocationMap = new Map();
                 finalItems.forEach((item, i) => { allocationMap.set(item.originalIndex, { itemData: item, allocationData: finalAllocations[i] }); });

                 let totalOriginal = 0;
                 let totalEmpenhado = 0;

                 originalItemsUnsorted.forEach(originalItem => {
                     totalOriginal += originalItem.amount; // Sum original quantity
                     const resultEntry = allocationMap.get(originalItem.originalIndex);
                     let Especificação = originalItem.details;
                     let quantidade = originalItem.amount;
                     let empenho = 'N/A';
                     let difHtml = 'N/A';
                     let varHtml = 'N/A';
                     if (resultEntry && resultEntry.allocationData) {
                         const finalAlloc = resultEntry.allocationData;
                         if (!finalAlloc.error && finalAlloc.sum !== undefined) {
                             empenho = finalAlloc.sum.toFixed(0);
                             totalEmpenhado += finalAlloc.sum; // Sum allocated quantity
                             const dif = finalAlloc.difference;
                             let difClass = dif === 0 ? 'zero-diff' : (dif > 0 ? 'positive-diff' : 'negative-diff');
                             let difSign = dif > 0 ? '+' : '';
                             difHtml = `<span class="${difClass}">${difSign}${dif.toFixed(0)}</span>`;
                             if (quantidade > 0) {
                                 const percentage = (dif / quantidade);
                                 const percentageFmt = (percentage * 100).toFixed(1) + '%';
                                 varHtml = percentageFmt;
                                 if (Math.abs(percentage) > REPROCESS_VARIATION_LIMIT) { varHtml = `<span class="violation">${percentageFmt}</span>`; }
                                 else if (Math.abs(percentage) > VARIATION_LIMIT_PASS_3) { varHtml = `<span class="warning">${percentageFmt}</span>`; }
                              } else if (finalAlloc.sum !== 0) { varHtml = `<span class="violation">N/A</span>`; }
                              else { varHtml = '0.0%'; }
                         } else if (finalAlloc.error) {
                             empenho = `<span class="error">Erro</span>`;
                             let shortError = finalAlloc.error.length > 50 ? finalAlloc.error.substring(0, 47) + '...' : finalAlloc.error;
                             difHtml = `<span class="error" title="${finalAlloc.error}">${shortError}</span>`;
                             varHtml = `<span class="error">Erro</span>`;
                         }
                     } else {
                         empenho = '<span class="warning">N/A</span>';
                         difHtml = '<span class="warning">N/A</span>';
                         varHtml = '<span class="warning">N/A</span>';
                     }
                     summaryTableHTML += `<tr><td>${Especificação}</td><td>${quantidade}</td><td>${empenho}</td><td>${difHtml}</td><td>${varHtml}</td></tr>`;
                 });
                 summaryTableHTML += `</tbody>`;

                 // Add Total Row
                 const totalDiferenca = totalEmpenhado - totalOriginal;
                 let totalDifClass = totalDiferenca === 0 ? 'zero-diff' : (totalDiferenca > 0 ? 'positive-diff' : 'negative-diff');
                 let totalDifSign = totalDiferenca > 0 ? '+' : '';
                 summaryTableHTML += `<tfoot><tr>
                                        <th>TOTAL</th>
                                        <td>${totalOriginal.toFixed(0)}</td>
                                        <td>${totalEmpenhado.toFixed(0)}</td>
                                        <td><span class="${totalDifClass}">${totalDifSign}${totalDiferenca.toFixed(0)}</span></td>
                                        <td></td>
                                     </tr></tfoot>`;

                 summaryTableHTML += `</table>`;
                 finalSummaryTableDiv.innerHTML = summaryTableHTML;

                 // --- 6. Update Strategy Comparison Highlight ---
                 updateComparisonTableHighlight(strategyName);

             // --- Error Handling for Display ---
             } catch (e) {
                 console.error(`Erro ao exibir detalhes para ${strategyName}:`, e);
                 statusAreaDiv.innerHTML = `<span class="error">Erro ao exibir detalhes para "${strategyName}". Verifique o console. Err: ${e.message}</span>`;
                 // Clear potentially broken output areas
                 allocationResultsDiv.innerHTML = '<span class="error">Erro de Exibição</span>';
                 adjustmentLogDiv.innerHTML = '';
                 variationLogDiv.innerHTML = '';
                 cumulativeUsageDiv.innerHTML = '';
                 lpdBreakdownDiv.innerHTML = '';
                 finalSummaryTableDiv.innerHTML = '';
                 detailsTitle.innerHTML = `Resultados Detalhados (Erro)`;
                 globalCurrentlyDisplayedStrategyName = null; // Reset on error
             }
        } // End displayStrategyDetails
        
        function updateComparisonTableHighlight(selectedStrategyName) {
             const table = document.getElementById('comparisonTable'); if (!table) return; const tbody = table.getElementsByTagName('tbody')[0]; if (!tbody) return; const rows = tbody.getElementsByTagName('tr'); for (let row of rows) { row.classList.remove('best-effort'); const firstCell = row.cells[0]; if (firstCell) { firstCell.textContent = firstCell.textContent.replace(/\s*\(Selecionado\)$/, '').trim(); const currentStrategyName = firstCell.textContent; const resultEntry = globalStrategyResults.find(res => res.strategyName === currentStrategyName); row.classList.remove('strategy-error-row'); if (resultEntry && resultEntry.hasAllocationError) { row.classList.add('strategy-error-row'); } if (currentStrategyName === selectedStrategyName) { row.classList.add('best-effort'); firstCell.textContent = `${currentStrategyName} (Selecionado)`; } } }
        }
        function toggleErrorStrategies() {
             const container = document.getElementById('comparisonTableContainer'); const button = document.getElementById('toggleErrorsBtn'); if (container && button) { const hiding = container.classList.toggle('hide-errors'); const errorRowCount = globalStrategyResults.filter(r => r.hasAllocationError).length; button.textContent = hiding ? `Mostrar ${errorRowCount} Estrat. c/ Erro...` : `Ocultar ${errorRowCount} Estrat. c/ Erro...`; }
        }

        // --- FUNÇÃO PRINCIPAL DE CONTROLE ---
        function initiateProcess(mode) {
            console.clear();
            console.log(`--- Iniciando Processo (Modo: ${mode}) ---`);
            const tableDataInput = document.getElementById('tableData').value.trim();
            const maxSlotsInput = document.getElementById('maxSlots').value.trim();
            const combinationSizeInput = document.getElementById('combinationSize').value.trim();
            const finderResultsLogDiv = document.getElementById('finderResultsLog');
            const foundCombinationDisplayDiv = document.getElementById('foundCombinationDisplay');
            const statusAreaDiv = document.getElementById('statusArea');
            const strategyComparisonDiv = document.getElementById('strategyComparison');
            const allocationResultsDiv = document.getElementById('allocationResults');
            const adjustmentLogDiv = document.getElementById('adjustmentLog');
            const variationLogDiv = document.getElementById('variationLog');
            const cumulativeUsageDiv = document.getElementById('cumulativeUsage');
            const lpdBreakdownDiv = document.getElementById('lpdBreakdown');
            const finalSummaryTableDiv = document.getElementById('finalSummaryTableDiv');
            const detailsTitleH2 = document.getElementById('detailsTitle');

            finderResultsLogDiv.innerHTML = `Processando Combinação (Modo: ${mode})...`;
            foundCombinationDisplayDiv.innerHTML = "";
            statusAreaDiv.innerHTML = "Aguardando Combinação...";
            strategyComparisonDiv.innerHTML = ""; allocationResultsDiv.innerHTML = ""; adjustmentLogDiv.innerHTML = ""; variationLogDiv.innerHTML = ""; cumulativeUsageDiv.innerHTML = ""; lpdBreakdownDiv.innerHTML = ""; finalSummaryTableDiv.innerHTML = ""; detailsTitleH2.innerHTML = 'Resultados Detalhados da Alocação';
             globalCurrentlyDisplayedStrategyName = null; // Reseta estratégia selecionada

            globalStrategyResults = []; globalOriginalItems = []; globalUniqueLpdValues = []; globalUserLpdCombinationWithDuplicates = []; globalLpdInstanceCounts = {}; globalInitialTotalSlotsPerValue = {}; globalMaxSlotsPerInstance = Infinity; globalMaxSlotsDisplay = "Ilimitado";

            if (!tableDataInput) { finderResultsLogDiv.innerHTML = '<span class="error">Erro: Dados da tabela vazios.</span>'; return; }
            if (!maxSlotsInput) { finderResultsLogDiv.innerHTML = '<span class="error">Erro: "Imagens no Plano" é obrigatório.</span>'; return; }
            if (!combinationSizeInput) { finderResultsLogDiv.innerHTML = '<span class="error">Erro: "Quantidade de Planos" é obrigatório.</span>'; return; }
            let maxSlotsPerInstance; let combinationSize;
             try { maxSlotsPerInstance = parseInt(maxSlotsInput); if (isNaN(maxSlotsPerInstance) || maxSlotsPerInstance < 1) throw new Error('"Imagens no Plano" >= 1.'); globalMaxSlotsPerInstance = maxSlotsPerInstance; globalMaxSlotsDisplay = String(maxSlotsPerInstance); } catch (e) { finderResultsLogDiv.innerHTML = `<span class="error">Erro de Entrada: ${e.message}</span>`; return; }
             try { combinationSize = parseInt(combinationSizeInput); if (isNaN(combinationSize) || combinationSize < 1) throw new Error('"Quantidade de Planos" >= 1.'); } catch (e) { finderResultsLogDiv.innerHTML = `<span class="error">Erro de Entrada: ${e.message}</span>`; return; }

            let parsedItems = []; let parseErrors = []; const lines = tableDataInput.split('\n'); let minRawAmount = Infinity, maxRawAmount = -Infinity, sumRawAmount = 0, validItemCount = 0;
            lines.forEach((line, index) => { line = line.trim(); if (!line) return; let parts = line.split('\t'); let details = ''; if (parts.length < 2) parts = line.split(/\s+/); if (parts.length < 2) { parseErrors.push(`L${index + 1}: Não foi possível dividir: "${line}"`); return; } const amountStr = parts[parts.length - 1].replace(/\./g, '').replace(/,/g, '.'); // Handle both . and , as separators
             details = parts.slice(0, -1).join(parts.length > 2 && line.includes('\t') ? '\t' : ' '); const amount = parseFloat(amountStr); if (isNaN(amount)) { parseErrors.push(`L${index + 1}: Quantidade NaN ('${parts[parts.length - 1]}') para "${details}"`); return; } if (amount < 0) { parseErrors.push(`L${index + 1}: Quantidade negativa (${amount}) para "${details}"`); return; } parsedItems.push({ details: details, amount: Math.round(amount), originalIndex: index }); sumRawAmount += Math.round(amount); validItemCount++; if (Math.round(amount) < minRawAmount) minRawAmount = Math.round(amount); if (Math.round(amount) > maxRawAmount) maxRawAmount = Math.round(amount); });
            if (parseErrors.length > 0) { finderResultsLogDiv.innerHTML = `<span class="error">Erros ao Processar:</span>\n${parseErrors.join('\n')}`; return; }
            if (parsedItems.length === 0) { finderResultsLogDiv.innerHTML = `<span class="error">Erro: Nenhuma Especificação válida processada.</span>`; return; }
            globalOriginalItems = parsedItems;
            console.log(`Processados ${validItemCount} Especificações. Soma: ${sumRawAmount}, Mín: ${minRawAmount}, Máx: ${maxRawAmount}`);

            finderResultsLogDiv.innerHTML = `Gerando Combinação (Modo: ${mode})...`;
            setTimeout(() => {
                try {
                    let combinationResult = null;
                    let combinationMethodDescription = "";

                    if (mode === 'findBest') {
                        console.log("Chamando findBestLpdCombination...");
                        combinationResult = findBestLpdCombination(globalOriginalItems, maxSlotsPerInstance, combinationSize);
                        combinationMethodDescription = "Método Melhor Plano (Padrão/MDC/Prop. Fallback)";
                    } else if (mode === 'forceProportional') {
                        console.log("Chamando calculateDirectProportionalCombination...");
                        combinationResult = calculateDirectProportionalCombination(globalOriginalItems, maxSlotsPerInstance, combinationSize);
                        combinationMethodDescription = "Método Proporcional Direto";
                    } else {
                        throw new Error(`Modo desconhecido: ${mode}`);
                    }

                    finderResultsLogDiv.innerHTML = combinationResult.log;

                    if (combinationResult.status === "Error" || !combinationResult.combination || combinationResult.combination.length === 0) {
                        if (combinationResult.status === "OK" && Array.isArray(combinationResult.combination) && combinationResult.combination.length === 0) {
                             foundCombinationDisplayDiv.innerHTML = `<span class="warning">Geração da Combinação resultou em lista vazia []. Prosseguindo para Alocador sem Planos.</span>`;
                             statusAreaDiv.innerHTML = "Combinação vazia. Executando Alocador...";
                             globalUserLpdCombinationWithDuplicates = [];
                             globalUniqueLpdValues = [];
                             globalLpdInstanceCounts = {};
                             globalInitialTotalSlotsPerValue = {};
                        } else {
                            foundCombinationDisplayDiv.innerHTML = `<span class="error">Geração da Combinação falhou (Modo: ${mode}). Não é possível prosseguir.</span>`;
                            statusAreaDiv.innerHTML = "Alocador Abortado (Falha na Combinação).";
                            return;
                        }
                    } else {
                        globalUserLpdCombinationWithDuplicates = combinationResult.combination;
                        globalUniqueLpdValues = [...new Set(globalUserLpdCombinationWithDuplicates)].sort((a, b) => a - b);
                        globalLpdInstanceCounts = {}; globalUserLpdCombinationWithDuplicates.forEach(lpd => { globalLpdInstanceCounts[lpd] = (globalLpdInstanceCounts[lpd] || 0) + 1; });
                        globalInitialTotalSlotsPerValue = {}; globalUniqueLpdValues.forEach(lpd => { const instances = globalLpdInstanceCounts[lpd] || 0; globalInitialTotalSlotsPerValue[lpd] = globalMaxSlotsPerInstance !== Infinity ? (instances * globalMaxSlotsPerInstance) : Infinity; });

                        console.log("Resultado Combinação (Valores):", globalUserLpdCombinationWithDuplicates);
                        console.log("Resultado Combinação (Únicos):", globalUniqueLpdValues);
                        console.log("Resultado Combinação (Contagens):", globalLpdInstanceCounts);
                        console.log("Resultado Combinação (Imagens Iniciais):", globalInitialTotalSlotsPerValue);

                        foundCombinationDisplayDiv.innerHTML = `Combinação Gerada (<span class="info">${combinationMethodDescription}</span>): <b>[${globalUserLpdCombinationWithDuplicates.join(', ')}]</b> (Tamanho: ${globalUserLpdCombinationWithDuplicates.length})`;
                        statusAreaDiv.innerHTML = `Combinação completa (Modo: ${mode}). Executando Alocador...`;
                    }

                    runAllocatorPhase();

                } catch (combinationError) {
                    console.error(`Erro durante Geração da Combinação (Modo: ${mode}):`, combinationError);
                    finderResultsLogDiv.innerHTML += `\n<span class="error">Ocorreu um erro inesperado durante a geração da combinação: ${combinationError.message}</span>`;
                    foundCombinationDisplayDiv.innerHTML = `<span class="error">Geração da combinação falhou (Modo: ${mode}).</span>`;
                    statusAreaDiv.innerHTML = "Alocador Abortado (Falha na Combinação).";
                }
            }, 10);

        } // Fim initiateProcess

        // --- Função da Fase do Alocador ---
        function runAllocatorPhase() {
            console.log("--- Iniciando Fase do Alocador ---");
            const statusAreaDiv = document.getElementById('statusArea');
            const strategyComparisonDiv = document.getElementById('strategyComparison');
            const allocationResultsDiv = document.getElementById('allocationResults');

            if (!globalOriginalItems || globalOriginalItems.length === 0) {
                statusAreaDiv.innerHTML = `<span class="error">Erro Alocador: Especificações processados ausentes.</span>`;
                return;
            }
            if (!globalUserLpdCombinationWithDuplicates || globalUserLpdCombinationWithDuplicates.length === 0) {
                console.warn("Fase Alocador: Executando com combinação de Planos vazia.");
            }

             const strategies = [
                 { name: "Ordem Original de Entrada", sortFn: (items) => [...items] },
                 { name: "Quantidade Ascendente", sortFn: (items) => [...items].sort((a, b) => a.amount - b.amount) },
                 { name: "Quantidade Descendente", sortFn: (items) => [...items].sort((a, b) => b.amount - a.amount) },
                 { name: "Especificação Ascendente (A-Z)", sortFn: (items) => [...items].sort((a, b) => a.details.localeCompare(b.details)) },
                 { name: "Especificação Descendente (Z-A)", sortFn: (items) => [...items].sort((a, b) => b.details.localeCompare(a.details)) },
                 { name: "Quantidade Meio-para-Fora (Baixo/Cima)", sortFn: (items) => { const s = [...items].sort((a, b) => a.amount - b.amount), r = [], n = s.length; if (n === 0) return []; const m = Math.floor(n / 2); r.push(s[m]); let l = m - 1, g = m + 1; while (l >= 0 || g < n) { if (l >= 0) r.push(s[l--]); if (g < n) r.push(s[g++]); } return r; }},
                 { name: "Quantidade Meio-para-Fora (Cima/Baixo)", sortFn: (items) => { const s = [...items].sort((a, b) => a.amount - b.amount), r = [], n = s.length; if (n === 0) return []; const m = Math.floor(n / 2); r.push(s[m]); let l = m - 1, g = m + 1; while (l >= 0 || g < n) { if (g < n) r.push(s[g++]); if (l >= 0) r.push(s[l--]); } return r; }},
                 { name: "Especificação Meio-para-Fora (Baixo/Cima)", sortFn: (items) => { const s = [...items].sort((a,b)=>a.details.localeCompare(b.details)), r = [], n = s.length; if (n === 0) return []; const m = Math.floor(n / 2); r.push(s[m]); let l = m - 1, g = m + 1; while (l >= 0 || g < n) { if (l >= 0) r.push(s[l--]); if (g < n) r.push(s[g++]); } return r; }},
                 { name: "Especificação Meio-para-Fora (Cima/Baixo)", sortFn: (items) => { const s = [...items].sort((a,b)=>a.details.localeCompare(b.details)), r = [], n = s.length; if (n === 0) return []; const m = Math.floor(n / 2); r.push(s[m]); let l = m - 1, g = m + 1; while (l >= 0 || g < n) { if (g < n) r.push(s[g++]); if (l >= 0) r.push(s[l--]); } return r; }},
                 { name: "Quantidade Fora-para-Dentro (Intercalado)", sortFn: (items) => { const s = [...items].sort((a,b)=>a.amount - b.amount), r = []; let l = 0, g = s.length - 1; while(l <= g) { r.push(s[l++]); if (l <= g) { r.push(s[g--]); } } return r; }},
                 { name: "Especificação Fora-para-Dentro (Intercalado)", sortFn: (items) => { const s = [...items].sort((a,b)=>a.details.localeCompare(b.details)), r = []; let l = 0, g = s.length - 1; while(l <= g) { r.push(s[l++]); if (l <= g) { r.push(s[g--]); } } return r; }},
                 { name: "Qtd Asc, Especificação Asc (Desempate)", sortFn: (items) => [...items].sort((a, b) => a.amount - b.amount || a.details.localeCompare(b.details)) },
                 { name: "Qtd Asc, Índice Asc (Desempate)", sortFn: (items) => [...items].sort((a, b) => a.amount - b.amount || a.originalIndex - b.originalIndex) },
                 { name: "Qtd Asc, Índice Desc (Desempate)", sortFn: (items) => [...items].sort((a, b) => a.amount - b.amount || b.originalIndex - a.originalIndex) },
                 { name: "Qtd Desc, Índice Asc (Desempate)", sortFn: (items) => [...items].sort((a, b) => b.amount - a.amount || a.originalIndex - b.originalIndex) },
                 { name: "Qtd Desc, Índice Desc (Desempate)", sortFn: (items) => [...items].sort((a, b) => b.amount - a.amount || b.originalIndex - a.originalIndex) },
                 { name: "Quantidade por Último Dígito", sortFn: (items) => [...items].sort((a, b) => (a.amount % 10) - (b.amount % 10) || a.amount - b.amount) },
                 { name: "Quantidade por Primeiro Dígito", sortFn: (items) => { const fd = (n) => {n=Math.abs(n); if(n===0) return 0; while(n>=10) n=Math.floor(n/10); return n;}; return [...items].sort((a, b) => fd(a.amount) - fd(b.amount) || a.amount - b.amount); }},
                 { name: "Qtd Asc (Processa Terços P->G->M)", sortFn: (items) => { const s = [...items].sort((a,b)=>a.amount-b.amount), n=s.length, t=Math.ceil(n/3); return [...s.slice(0,t), ...s.slice(n-t), ...s.slice(t,n-t)]; }},
                 { name: "Qtd Desc (Processa Terços G->P->M)", sortFn: (items) => { const s = [...items].sort((a,b)=>b.amount-a.amount), n=s.length, t=Math.ceil(n/3); return [...s.slice(0,t), ...s.slice(n-t), ...s.slice(t,n-t)]; }},
                 { name: "Qtd Asc (Intercala por 3: 0,3.. 1,4.. 2,5..)", sortFn: (items) => { const s=[...items].sort((a,b)=>a.amount-b.amount), r=[], n=s.length; for(let k=0;k<3;k++) for(let i=k;i<n;i+=3) r.push(s[i]); return r; }},
                 { name: "Qtd Desc (Intercala por 3: 0,3.. 1,4.. 2,5..)", sortFn: (items) => { const s=[...items].sort((a,b)=>b.amount-a.amount), r=[], n=s.length; for(let k=0;k<3;k++) for(let i=k;i<n;i+=3) r.push(s[i]); return r; }},
                 { name: "Desvio da Média Qtd (Mais Próximo Primeiro)", sortFn: (items) => { if(items.length===0) return []; const avg = items.reduce((sum,i)=>sum+i.amount,0)/items.length; return [...items].sort((a,b)=>Math.abs(a.amount-avg)-Math.abs(b.amount-avg)); }},
                 { name: "Desvio da Média Qtd (Mais Distante Primeiro)", sortFn: (items) => { if(items.length===0) return []; const avg = items.reduce((sum,i)=>sum+i.amount,0)/items.length; return [...items].sort((a,b)=>Math.abs(b.amount-avg)-Math.abs(a.amount-avg)); }},
             ];

            let localStrategyResults = [];
            let firstSuccessfulResult = null;
            const comboString = globalUserLpdCombinationWithDuplicates.length > 0 ? `[${globalUserLpdCombinationWithDuplicates.join(', ')}]` : '[Vazia]';
            statusAreaDiv.innerHTML = `Executando alocação para ${strategies.length} estratégias usando combinação ${comboString}... Por favor, aguarde.`;

            setTimeout(() => {
                try {
                    for (const strategy of strategies) {
                        console.log(`--- Executando Estratégia Alocador: ${strategy.name} ---`);
                        const currentItemsOrdered = strategy.sortFn(globalOriginalItems).map((item, idx) => ({ ...item, index: idx }));
                        const result = runAllocationProcess(currentItemsOrdered, [...globalUserLpdCombinationWithDuplicates], globalMaxSlotsPerInstance);
                        let hasAllocationError = false; let firstErrorMessage = "";
                        if (result && result.itemAllocations) { for(let i = 0; i < result.itemAllocations.length; i++) { const alloc = result.itemAllocations[i]; const item = currentItemsOrdered[i]; if (!alloc) { hasAllocationError = true; firstErrorMessage = "Objeto aloc ausente"; break;} if (alloc.error) { hasAllocationError = true; if (!firstErrorMessage) firstErrorMessage = alloc.error; } if (!alloc.error && item.amount > 0 && alloc.sum === 0 && alloc.combination.length === 0) { hasAllocationError = true; const zeroSumError = "Soma 0 para alvo > 0 (Falha DP?)"; alloc.error = alloc.error ? (alloc.error + "; " + zeroSumError) : zeroSumError; if (!firstErrorMessage) firstErrorMessage = zeroSumError; } } } else { hasAllocationError = true; firstErrorMessage = "Estrutura de resultado inválida"; } if (hasAllocationError) console.warn(`--- Aloc Estrat ${strategy.name}: Erro(s). Primeiro: "${firstErrorMessage}"`);
                        const maxVariation = calculateMaxVariation(currentItemsOrdered, result.itemAllocations); const avgVariation = calculateAverageVariation(currentItemsOrdered, result.itemAllocations); const meetsLimit = !hasAllocationError && maxVariation <= REPROCESS_VARIATION_LIMIT;
                        console.log(`--- Aloc Estrat ${strategy.name} Resultado: VarMáx=${(maxVariation * 100).toFixed(2)}%, VarMéd=${(avgVariation * 100).toFixed(2)}%, TemErro=${hasAllocationError}, AtendeLimite=${meetsLimit}`);
                        const resultEntry = { strategyName: strategy.name, itemsUsed: currentItemsOrdered, resultData: result, maxVariation: maxVariation, avgVariation: avgVariation, meetsLimit: meetsLimit, hasAllocationError: hasAllocationError }; localStrategyResults.push(resultEntry);
                        if (meetsLimit && !firstSuccessfulResult) { firstSuccessfulResult = resultEntry; console.log(`--- Encontrada primeira estratégia alocadora bem-sucedida: ${strategy.name} ---`); }
                    }

                    globalStrategyResults = localStrategyResults;
                    let finalResultToShow = null; let statusMessage = "";
                    if (firstSuccessfulResult) { finalResultToShow = firstSuccessfulResult; statusMessage = `<span class="success">Visão Padrão: Primeira estratégia dentro do limite: ${finalResultToShow.strategyName}</span>. Clique abaixo...`; }
                    else { if (globalStrategyResults.length > 0) { const errorFreeStrategies = globalStrategyResults.filter(r => !r.hasAllocationError); if (errorFreeStrategies.length > 0) { errorFreeStrategies.sort((a, b) => a.avgVariation - b.avgVariation); finalResultToShow = errorFreeStrategies[0]; const vStr = finalResultToShow.maxVariation === Infinity ? 'Inf' : `${(finalResultToShow.maxVariation * 100).toFixed(1)}%`; const avgStr = (finalResultToShow.avgVariation * 100).toFixed(1) + '%'; statusMessage = `<span class="warning">Visão Padrão: Nenhuma estratégia atendeu ao limite. Mostrando menor <span class="info">var média</span> (sem erro):</span> <span class="info">${finalResultToShow.strategyName}</span> (Máx: ${vStr}, Média: ${avgStr}). Clique abaixo...`; } else { globalStrategyResults.sort((a, b) => a.avgVariation - b.avgVariation); finalResultToShow = globalStrategyResults[0]; const vStr = finalResultToShow.maxVariation === Infinity ? 'Inf' : `${(finalResultToShow.maxVariation * 100).toFixed(1)}%`; const avgStr = (finalResultToShow.avgVariation * 100).toFixed(1) + '%'; statusMessage = `<span class="error">Visão Padrão: Todas as estratégias tiveram erros. Mostrando menor <span class="info">var média</span>:</span> <span class="info">${finalResultToShow.strategyName}</span> (Máx: ${vStr}, Média: ${avgStr}). Clique abaixo...`; } } else { statusMessage = `<span class="error">Erro: Nenhum resultado de estratégia gerado.</span>`; allocationResultsDiv.innerHTML = ''; return; } }
                    statusAreaDiv.innerHTML = statusMessage;

                    let comparisonHTML = `<div class="comparison-title">--- Resumo da Comparação de Estratégias ---</div><div id="comparisonTableContainer" class="comparison-table-container hide-errors"><table id="comparisonTable"><thead><tr><th>Estratégia</th><th>Var Máx (%)</th><th>Var Média (%)</th><th>Resultado</th></tr></thead><tbody>`;
                    const successResults = []; const highVarResults = []; const errorResults = []; globalStrategyResults.forEach(res => { if (res.hasAllocationError) errorResults.push(res); else if (res.meetsLimit) successResults.push(res); else highVarResults.push(res); }); const sortByAvgVar = (a, b) => a.avgVariation - b.avgVariation; successResults.sort(sortByAvgVar); highVarResults.sort(sortByAvgVar); errorResults.sort(sortByAvgVar); const sortedResults = [...successResults, ...highVarResults, ...errorResults]; let errorCount = errorResults.length;
                    sortedResults.forEach(res => { let maxVarStr = ""; if (res.maxVariation === Infinity) { maxVarStr = '<span class="violation">Infinita</span>'; } else { maxVarStr = (res.maxVariation * 100).toFixed(1) + '%'; if (!res.meetsLimit && !res.hasAllocationError) maxVarStr = `<span class="warning">${maxVarStr}</span>`; } let avgVarStr = (res.avgVariation * 100).toFixed(1) + '%'; let outcomeStr = ''; let rowClass = ''; if (res.hasAllocationError) { outcomeStr = `<span class="error">Erro</span>`; rowClass = 'strategy-error-row'; } else if (res.meetsLimit) { outcomeStr = `<span class="success">Sucesso</span>`; } else { outcomeStr = `<span class="warning">Var Alta</span>`; } const isSelectedStrategy = (finalResultToShow && res.strategyName === finalResultToShow.strategyName); if (isSelectedStrategy) rowClass = `${rowClass} best-effort`.trim(); comparisonHTML += `<tr class="${rowClass}"><td class="strategy-name" onclick="displayStrategyDetails('${encodeURIComponent(res.strategyName)}')">${res.strategyName} ${isSelectedStrategy ? '(Selecionado)' : ''}</td><td>${maxVarStr}</td><td>${avgVarStr}</td><td>${outcomeStr}</td></tr>`; });
                    comparisonHTML += `</tbody></table></div>`; if (errorCount > 0) { comparisonHTML += `<button id="toggleErrorsBtn" onclick="toggleErrorStrategies()">Mostrar ${errorCount} Estrat. c/ Erro...</button>`; } strategyComparisonDiv.innerHTML = comparisonHTML;

                    if (finalResultToShow) displayStrategyDetails(encodeURIComponent(finalResultToShow.strategyName));
                    else allocationResultsDiv.innerHTML = 'Nenhuma estratégia padrão disponível.';

                } catch (allocatorError) {
                    console.error("Erro durante processamento da estratégia do Alocador:", allocatorError);
                    statusAreaDiv.innerHTML = `<span class="error">Erro na fase do Alocador. Verifique o console. Err: ${allocatorError.message}</span>`;
                    allocationResultsDiv.innerHTML = `<span class="error">Alocador Falhou</span>`; strategyComparisonDiv.innerHTML = "";
                }
            }, 10);

        } // Fim runAllocatorPhase
    </script>

</body>
</html>
