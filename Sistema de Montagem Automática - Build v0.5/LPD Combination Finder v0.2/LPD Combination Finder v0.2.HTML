<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>LPD Combination Finder (Exact Sum, Max Freq near Min)</title>
    <style>
         /* Basic styling */
         body { font-family: sans-serif; padding: 20px; }
        label { display: block; margin-top: 10px; margin-bottom: 5px; font-weight: bold; }
        textarea { width: 90%; min-height: 150px; margin-bottom: 10px; font-family: monospace; }
        input[type="number"] { padding: 8px; margin-bottom: 10px; width: 120px; }
        button { padding: 10px 15px; cursor: pointer; background-color: #007bff; color: white; border: none; border-radius: 4px; margin-top: 10px; }
        button:hover { background-color: #0056b3; }
        #results { margin-top: 20px; padding: 15px; border: 1px solid #ccc; background-color: #f9f9f9; white-space: pre-wrap; font-family: monospace; }
        .error { color: red; font-weight: bold; }
        .info { color: blue; }
        .input-group { margin-bottom: 15px; }
        .highlight { background-color: yellow; font-weight: bold; }
        .candidate-section { border-left: 3px solid #ddd; padding-left: 10px; margin-top: 5px; margin-bottom: 5px; }
    </style>
</head>
<body>

    <h1>LPD Combination Finder (Exact Sum, Highest Frequency near Min Amount, >=2000)</h1>
    <p>Finds the best combination of LPDs based on frequency, including one LPD near the minimum amount found.</p>

    <!-- Input fields -->
    <div class="input-group">
        <label for="tableData">Table Data (Details + Amount, one per line):</label>
        <textarea id="tableData" placeholder="Example:
Item A	3000 (min amount)
Item C	7500 (freq 8)
..."></textarea>
    </div>
    <div class="input-group">
        <label for="targetSum">Target Sum for LPD Combination (Exact):</label>
        <input type="number" id="targetSum" placeholder="e.g., 36500">
    </div>
    <div class="input-group">
        <label for="combinationSize">Number of Distinct LPDs (>=2000) in Combination:</label>
        <input type="number" id="combinationSize" value="4" min="2">
    </div>
    <button onclick="findBestCombination()">Find Best Combination</button>

    <!-- Output area -->
    <div id="results">LPD Combination results will appear here...</div>


    <script>
        // --- CONFIGURATION RULES ---
        const MIN_LPD_VALUE = 2000;
        const OBLIGATORY_RANGE = 500; // Range +/- from minAmountFound
        // --- ---

        // --- Recursive Combination Finder ---
        // Purpose: Finds *one* combination of exactly 'k' distinct LPD values from a given list
        //          that sum up precisely to a specified 'target'.
        function findSumCombinationRecursive(lpdValueObjectsToSearch, target, k, startIndex, currentCombinationValues) {
            if (currentCombinationValues.length === k) {
                const currentSum = currentCombinationValues.reduce((sum, item) => sum + item, 0);
                if (Math.abs(currentSum - target) < 0.01) { return [...currentCombinationValues]; } return null;
            }
            if (startIndex >= lpdValueObjectsToSearch.length || currentCombinationValues.length > k || lpdValueObjectsToSearch.length - startIndex < k - currentCombinationValues.length) { return null; }
            for (let i = startIndex; i < lpdValueObjectsToSearch.length; i++) {
                const currentLpdValue = lpdValueObjectsToSearch[i].value;
                if (!currentCombinationValues.includes(currentLpdValue)) {
                    currentCombinationValues.push(currentLpdValue);
                    const result = findSumCombinationRecursive(lpdValueObjectsToSearch, target, k, i + 1, currentCombinationValues);
                    if (result) { return result; }
                    currentCombinationValues.pop(); // Backtrack
                }
            }
            return null;
        }


        // --- Main Processing Function for Combination Finder ---
        function findBestCombination() {
            // 1. Read and Validate Inputs
            const tableDataInput = document.getElementById('tableData').value.trim();
            const targetSumInput = document.getElementById('targetSum').value;
            const combinationSizeInput = document.getElementById('combinationSize').value;
            const resultsDiv = document.getElementById('results');

            resultsDiv.innerHTML = `Processing LPD Combination (>= ${MIN_LPD_VALUE}, Exact Sum, Max Freq near Min Amount)...`;

            if (!tableDataInput) { resultsDiv.innerHTML = '<span class="error">Error: Table data cannot be empty.</span>'; return; }
            const exactTargetSum = parseInt(targetSumInput);
            const combinationSize = parseInt(combinationSizeInput);
            if (isNaN(exactTargetSum)) { resultsDiv.innerHTML = '<span class="error">Error: Invalid Target Sum.</span>'; return; }
            if (isNaN(combinationSize) || combinationSize < 2) { resultsDiv.innerHTML = `<span class="error">Error: Invalid Number of LPDs (must be >= 2).</span>`; return; }


            // 2. Parse Table Data & Find Min Amount
            const lines = tableDataInput.split('\n');
            const lpdFrequencies = {}; // Map: { lpdValue: frequency }
            let parseErrors = [];
            let minAmountFound = Infinity;

            lines.forEach((line, index) => { /* ... parsing logic ... */
                line = line.trim(); if (!line) return;
                let parts = line.split('\t'); if (parts.length < 2) parts = line.split(/\s+/);
                if (parts.length < 2) { parseErrors.push(`L${index + 1}: Cannot split: "${line}"`); return; }
                const amountStr = parts[parts.length - 1]; const amount = parseInt(amountStr);
                if (isNaN(amount)) { parseErrors.push(`L${index + 1}: Amount NaN "${amountStr}"`); return; }
                if (amount <= 0) { parseErrors.push(`L${index + 1}: Amount <=0 "${amount}"`); return; }
                if (amount % 2 !== 0) { parseErrors.push(`L${index + 1}: Amount odd "${amount}"`); return; }
                if (amount < minAmountFound) { minAmountFound = amount; }
                const lpd = amount / 2;
                if (lpd >= MIN_LPD_VALUE) { lpdFrequencies[lpd] = (lpdFrequencies[lpd] || 0) + 1; }
            });

            if (parseErrors.length > 0) { resultsDiv.innerHTML = `<span class="error">Parse Errors:</span>\n${parseErrors.join('\n')}`; return; }
            if (minAmountFound === Infinity) { resultsDiv.innerHTML = `<span class="error">Error: No valid amounts found.</span>`; return; }


            // 3. Identify Obligatory Candidate LPDs
            let obligatoryLog = [`Minimum Amount in table: ${minAmountFound}`];
            const uniqueValidLpdListWithFreq = Object.entries(lpdFrequencies)
                                      .map(([lpd, freq]) => ({ value: parseInt(lpd), frequency: freq }));

            const obligatoryCandidates = uniqueValidLpdListWithFreq.filter(lpdObj => {
                 const diff = Math.abs(lpdObj.value - minAmountFound);
                 return diff <= OBLIGATORY_RANGE;
            }).sort((a, b) => a.value - b.value);

            obligatoryLog.push(`Valid LPDs Found (>=${MIN_LPD_VALUE}): [${uniqueValidLpdListWithFreq.map(l=>l.value).sort((a,b)=>a-b).join(', ')}]`);
            obligatoryLog.push(`Found ${obligatoryCandidates.length} candidate LPD(s) within +/- ${OBLIGATORY_RANGE} of Min Amount (${minAmountFound}): [${obligatoryCandidates.map(c=>c.value).join(', ')}]`);

            if (obligatoryCandidates.length === 0) {
                 resultsDiv.innerHTML = `<span class="error">Error: No valid LPD (>= ${MIN_LPD_VALUE}) found within +/- ${OBLIGATORY_RANGE} of the Minimum Amount (${minAmountFound}). Cannot proceed.</span>\n${obligatoryLog.join('\n')}`;
                 return;
            }


            // 4. Prepare Full LPD List for Searching 'Other' LPDs
            uniqueValidLpdListWithFreq.sort((a, b) => { /* Sort by Freq DESC, Value DESC */
                if (b.frequency !== a.frequency) return b.frequency - a.frequency;
                return b.value - a.value;
            });
            let frequencyLog = [`Valid LPDs Sorted by Frequency (Value(Frequency)): ${uniqueValidLpdListWithFreq.map(l => `${l.value}(${l.frequency})`).join(', ')}`];


            // 5. Search for the Best Combination (Exact Sum, Max Freq)
            const neededOtherLpds = combinationSize - 1;
            let overallSearchLog = [`--- Obligatory Candidate Selection ---`];
            overallSearchLog.push(...obligatoryLog);
            overallSearchLog.push(`--- Available LPDs ---`);
            overallSearchLog.push(...frequencyLog);
            overallSearchLog.push(`--- Combination Search ---`);
            overallSearchLog.push(`Searching for combination of size ${combinationSize} summing EXACTLY to ${exactTargetSum}, using each candidate LPD near minimum amount...`);

            let bestCombinationFound = null;
            let bestCombinationFrequencyScore = -1;

            function getFrequencyScore(combination) { /* ... same helper function ... */
                 let score = 0; for (const lpdValue of combination) { score += (lpdFrequencies[lpdValue] || 0); } return score;
            }

            // --- Search Loop ---
            for (const currentObligatoryCandidate of obligatoryCandidates) {
                const currentObligatoryLpdValue = currentObligatoryCandidate.value;
                overallSearchLog.push(`<div class="candidate-section">=== Trying with Obligatory Candidate: ${currentObligatoryLpdValue} ===`);

                const searchLpdList = uniqueValidLpdListWithFreq.filter(lpdObj => lpdObj.value !== currentObligatoryLpdValue);

                if (neededOtherLpds > 0 && searchLpdList.length < neededOtherLpds) {
                    overallSearchLog.push(`   Skipping: Not enough other LPDs available.`);
                    overallSearchLog.push(`</div>`); continue;
                }

                const targetForRecursion = exactTargetSum - currentObligatoryLpdValue;
                overallSearchLog.push(`   Target sum for remaining ${neededOtherLpds} LPDs: ${exactTargetSum} - ${currentObligatoryLpdValue} = ${targetForRecursion}`);

                let foundKMinus1Combination = null;
                if (targetForRecursion < 0 && neededOtherLpds > 0) { overallSearchLog.push(`   Skipping: Target for remaining LPDs is negative.`); }
                else if (neededOtherLpds >= 0) { foundKMinus1Combination = findSumCombinationRecursive(searchLpdList, targetForRecursion, neededOtherLpds, 0, []); }

                if (foundKMinus1Combination !== null) {
                    const currentFullCombination = [...foundKMinus1Combination, currentObligatoryLpdValue].sort((a,b)=>a-b);
                    const currentFrequencyScore = getFrequencyScore(currentFullCombination);
                    overallSearchLog.push(`   <span class="highlight">Found Exact Sum Combination: [${currentFullCombination.join(', ')}] (Sum: ${exactTargetSum}, Freq Score: ${currentFrequencyScore})</span>`);
                    if (bestCombinationFound === null || currentFrequencyScore > bestCombinationFrequencyScore) {
                        overallSearchLog.push(`   <span class="info">   ** New Best Combination Found (Higher Freq Score) **</span>`);
                        bestCombinationFound = currentFullCombination;
                        bestCombinationFrequencyScore = currentFrequencyScore;
                    }
                } else { overallSearchLog.push(`   -> No combination found including ${currentObligatoryLpdValue} that sums exactly to ${exactTargetSum}.`); }
                overallSearchLog.push(`</div>`);
            } // End outer obligatory candidate loop


            // 6. Display Final Result
            if (bestCombinationFound) {
                resultsDiv.innerHTML = overallSearchLog.join('\n')
                                 + `\n\n<span class="highlight">Best LPD Combination Found (${combinationSize} LPDs): [${bestCombinationFound.join(', ')}]</span>`
                                 + `\n(Chosen for highest frequency score among combinations summing exactly to ${exactTargetSum})`
                                 + `\nTotal Frequency Score: ${bestCombinationFrequencyScore}`;
            } else {
                 resultsDiv.innerHTML = overallSearchLog.join('\n')
                                    + `\n\n<span class="error">No combination of ${combinationSize} distinct LPDs (>=${MIN_LPD_VALUE}, including one near min amount ${minAmountFound}) found summing EXACTLY to ${exactTargetSum} after trying all valid candidates.</span>`;
            }
        } // End findBestCombination

    </script>

</body>
</html>