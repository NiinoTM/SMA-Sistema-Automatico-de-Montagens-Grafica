<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>LPD Combination Finder v0.3.4 (Round to 50 Fallback)</title>
    <style>
        /* Basic styling (same as v0.3.3) */
        body { font-family: sans-serif; padding: 20px; }
        label { display: block; margin-top: 10px; margin-bottom: 5px; font-weight: bold; }
        textarea { width: 90%; min-height: 150px; margin-bottom: 10px; font-family: monospace; }
        input[type="number"] { padding: 8px; margin-bottom: 10px; width: 120px; }
        button { padding: 10px 15px; cursor: pointer; background-color: #007bff; color: white; border: none; border-radius: 4px; margin-top: 10px; }
        button:hover { background-color: #0056b3; }
        #results { margin-top: 20px; padding: 15px; border: 1px solid #ccc; background-color: #f9f9f9; white-space: pre-wrap; font-family: monospace; }
        .error { color: red; font-weight: bold; }
        .info { color: blue; }
        .success { color: green; font-weight: bold; }
        .fallback-gcd { color: darkorange; font-weight: bold; }
        .fallback-prop { color: purple; font-weight: bold; }
        .input-group { margin-bottom: 15px; }
        .highlight { background-color: yellow; font-weight: bold; }
        .target-section { border-top: 2px solid #aaa; padding-top: 10px; margin-top: 15px; }
        .candidate-section { border-left: 3px solid #ddd; padding-left: 10px; margin-top: 5px; margin-bottom: 5px; }
        .fallback-section { border-top: 2px solid darkorange; padding-top: 10px; margin-top: 15px; }
        .proportional-fallback-section { border-top: 2px solid purple; padding-top: 10px; margin-top: 15px; }
    </style>
</head>
<body>

    <h1>LPD Combination Finder (Target Range / Fallbacks, Round to 50, Highest Freq near Min LPD, >=2000)</h1>
    <p>Tries standard search using target range. If no LPD near min LPD, uses GCD Fallback. If standard search fails, uses Proportional Fallback (rounded to nearest 50).</p>

    <!-- Input fields -->
    <div class="input-group">
        <label for="tableData">Table Data (Details + Amount, one per line):</label>
        <textarea id="tableData" placeholder="Example:
Item A 10000
Item B 7500
Item C 20000
..."></textarea>
    </div>
    <div class="input-group">
        <label for="maxSlots">Max Slots per LPD Instance (Cumulative):</label>
        <input type="number" id="maxSlots" min="1" placeholder="e.g., 8" required>
    </div>
    <div class="input-group">
        <label for="combinationSize">Number of Distinct LPDs in Combination (Standard/Proportional):</label>
        <input type="number" id="combinationSize" value="2" min="2">
    </div>
    <button onclick="findBestCombination()">Find Best Combination</button>

    <!-- Output area -->
    <div id="results">LPD Combination results will appear here...</div>

    <script>
        // --- CONFIGURATION RULES ---
        const MIN_LPD_VALUE = 2000;
        const OBLIGATORY_RANGE = 500;
        const TARGET_RANGE_BELOW = 500;
        const TARGET_RANGE_ABOVE = 1000;
        const TARGET_STEP = 500;
        const PROPORTIONAL_ROUNDING_STEP = 50; // Added constant for rounding
        // --- ---

        // --- Helper Functions ---
        function gcd(a, b) { /* ... (same as v0.3.3) ... */
             a = Math.abs(a); b = Math.abs(b); if (b === 0) return a; return gcd(b, a % b);
         }
        function arrayGcd(numbers) { /* ... (same as v0.3.3) ... */
              if (!numbers || numbers.length === 0) return 0; if (numbers.length === 1) return Math.abs(numbers[0]); let result = Math.abs(numbers[0]); for (let i = 1; i < numbers.length; i++) { result = gcd(result, numbers[i]); if (result === 1) return 1; } return result;
          }
        function findSumCombinationRecursive(lpdValueObjectsToSearch, target, k, startIndex, currentCombinationValues) { /* ... (same as v0.3.3) ... */
             if (currentCombinationValues.length === k) { const currentSum = currentCombinationValues.reduce((sum, item) => sum + item, 0); if (Math.abs(currentSum - target) < 0.01) { return [...currentCombinationValues]; } return null; } if (startIndex >= lpdValueObjectsToSearch.length || currentCombinationValues.length > k || lpdValueObjectsToSearch.length - startIndex < k - currentCombinationValues.length) { return null; } for (let i = startIndex; i < lpdValueObjectsToSearch.length; i++) { const currentLpdValue = lpdValueObjectsToSearch[i].value; if (!currentCombinationValues.includes(currentLpdValue)) { currentCombinationValues.push(currentLpdValue); const result = findSumCombinationRecursive(lpdValueObjectsToSearch, target, k, i + 1, currentCombinationValues); if (result) { return result; } currentCombinationValues.pop(); } } return null;
          }
        function getFrequencyScore(combination, lpdFrequencies) { /* ... (same as v0.3.3) ... */
              let score = 0; for (const lpdValue of combination) { score += (lpdFrequencies[lpdValue] || 0); } return score;
         }
        // Helper to round to nearest multiple
        function roundToNearest(value, multiple) {
            if (multiple <= 0) return Math.round(value); // Avoid division by zero or invalid multiple
            return Math.round(value / multiple) * multiple;
        }


        // --- Main Processing Function ---
        function findBestCombination() {
            // 1. Read and Validate Inputs
            const tableDataInput = document.getElementById('tableData').value.trim();
            const maxSlotsInput = document.getElementById('maxSlots').value.trim();
            const combinationSizeInput = document.getElementById('combinationSize').value;
            const resultsDiv = document.getElementById('results');

            resultsDiv.innerHTML = `Processing LPD Combination (>= ${MIN_LPD_VALUE}, Target Range / Fallbacks, Round to ${PROPORTIONAL_ROUNDING_STEP})...`; // Updated title

            if (!tableDataInput) { resultsDiv.innerHTML = '<span class="error">Error: Table data cannot be empty.</span>'; return; }
            if (!maxSlotsInput) { resultsDiv.innerHTML = '<span class="error">Error: Max Slots value is required.</span>'; return; }

            // 2. Parse Table Data
            const lines = tableDataInput.split('\n');
            const lpdFrequencies = {};
            const validRawAmounts = [];
            let parseErrors = [];
            let minAmountFound = Infinity;
            let sumAmounts = 0;
            const allValidLpds = [];

            lines.forEach((line, index) => {
                line = line.trim(); if (!line) return;
                let parts = line.split('\t'); if (parts.length < 2) parts = line.split(/\s+/);
                if (parts.length < 2) { parseErrors.push(`L${index + 1}: Cannot split line: "${line}"`); return; }
                const amountStr = parts[parts.length - 1];
                const amount = parseInt(amountStr);
                if (isNaN(amount)) { parseErrors.push(`L${index + 1}: Amount NaN: "${amountStr}"`); return; }
                if (amount <= 0) { parseErrors.push(`L${index + 1}: Amount <= 0: "${amount}"`); return; }

                validRawAmounts.push(amount);
                sumAmounts += amount;
                if (amount < minAmountFound) minAmountFound = amount;

                const lpd = Math.round(amount / 2); // Use Math.round for LPD calculation itself
                if (lpd >= MIN_LPD_VALUE) {
                    lpdFrequencies[lpd] = (lpdFrequencies[lpd] || 0) + 1;
                    allValidLpds.push(lpd);
                }
            });
            // ... (Error handling for parseErrors, minAmountFound, sumAmounts same as before) ...
            if (parseErrors.length > 0) { resultsDiv.innerHTML = `<span class="error">Input Data Parse Errors:</span>\n${parseErrors.join('\n')}`; return; }
            if (minAmountFound === Infinity || validRawAmounts.length === 0) { resultsDiv.innerHTML = `<span class="error">Error: No valid amounts found in the table data.</span>`; return; }
            if (sumAmounts === 0) { resultsDiv.innerHTML = `<span class="error">Error: Total sum of amounts is zero.</span>`; return; }

            // 3. Prepare Base Data and Validate Inputs
            const maxSlots = parseInt(maxSlotsInput);
             if (isNaN(maxSlots) || maxSlots <= 0) { /* ... Error ... */ resultsDiv.innerHTML = '<span class="error">Error: Invalid Max Slots value.</span>'; return; }
            const combinationSize = parseInt(combinationSizeInput);
            if (isNaN(combinationSize) || combinationSize < 2) { /* ... Error ... */ resultsDiv.innerHTML = `<span class="error">Error: Invalid Number of Distinct LPDs (must be >= 2).</span>`; return; }

            const uniqueValidLpdListWithFreq = Object.entries(lpdFrequencies)
                                      .map(([lpd, freq]) => ({ value: parseInt(lpd), frequency: freq }));
            uniqueValidLpdListWithFreq.sort((a, b) => { /* ... Sort by Freq Desc, Value Desc ... */
                 if (b.frequency !== a.frequency) return b.frequency - a.frequency; return b.value - a.value;
             });

            let initialLog = [];
            initialLog.push(`Minimum Amount Found in Table: ${minAmountFound}`);
            initialLog.push(`Total Sum of Amounts: ${sumAmounts}`);
            initialLog.push(`Valid Amounts Found (${validRawAmounts.length}): [${validRawAmounts.join(', ')}]`);
            initialLog.push(`Max Slots: ${maxSlots}`);
            initialLog.push(`Required Combination Size (Standard/Proportional): ${combinationSize}`);
            initialLog.push(`Unique Valid LPDs (>=${MIN_LPD_VALUE}) Found: ${uniqueValidLpdListWithFreq.length} values.`);
            let frequencyLog = `Unique Valid LPDs Sorted by Freq/Value: ${uniqueValidLpdListWithFreq.map(l => `${l.value}(${l.frequency})`).join(', ')}`;
            initialLog.push(frequencyLog);

            // 4. Check for Obligatory Candidates (Based on Min LPD Value)
            let minLpdValueFound = Infinity;
             uniqueValidLpdListWithFreq.forEach(lpdObj => { if (lpdObj.value < minLpdValueFound) minLpdValueFound = lpdObj.value; });
             initialLog.push(`Minimum Valid LPD Value Found: ${minLpdValueFound === Infinity ? 'None' : minLpdValueFound}`);

            const obligatoryCandidates = minLpdValueFound === Infinity ? [] : uniqueValidLpdListWithFreq.filter(lpdObj => {
                 const diff = Math.abs(lpdObj.value - minLpdValueFound); return diff <= OBLIGATORY_RANGE;
            }).sort((a, b) => a.value - b.value);
            initialLog.push(`Found ${obligatoryCandidates.length} candidate LPD(s) within +/- ${OBLIGATORY_RANGE} of Min LPD Value (${minLpdValueFound === Infinity ? 'N/A' : minLpdValueFound}): [${obligatoryCandidates.map(c=>c.value).join(', ')}]`);


            // 5. Decide Strategy: Standard, GCD Fallback, or Proportional Fallback
            if (obligatoryCandidates.length === 0) {
                // ---=== GCD FALLBACK STRATEGY ===---
                // ... (GCD Fallback logic remains exactly the same as v0.3.3) ...
                initialLog.push(`<span class="fallback-gcd">ALERT: No valid LPDs found near minimum LPD value. Attempting GCD Fallback Strategy.</span>`);
                let fallbackLog = [`<div class="fallback-section">--- GCD Fallback Calculation ---`];
                const baseTargetAmount = sumAmounts / maxSlots;
                fallbackLog.push(`Base Target Amount (Sum/Slots): ${baseTargetAmount.toFixed(2)}`);
                if (validRawAmounts.length < 1) { fallbackLog.push(`<span class="error">Error: Cannot calculate GCD fallback, no valid amounts.</span>`); resultsDiv.innerHTML = initialLog.join('\n') + '\n' + fallbackLog.join('\n') + `</div>`; return; }
                const gcdAmounts = arrayGcd(validRawAmounts);
                fallbackLog.push(`GCD of all valid amounts (${validRawAmounts.length} values): ${gcdAmounts}`);
                if (gcdAmounts <= 0) { fallbackLog.push(`<span class="error">Error: Calculated GCD of amounts is ${gcdAmounts}.</span>`); resultsDiv.innerHTML = initialLog.join('\n') + '\n' + fallbackLog.join('\n') + `</div>`; return; }
                const fallbackTarget = Math.round(baseTargetAmount / gcdAmounts) * gcdAmounts; // Use integer round for target
                fallbackLog.push(`Fallback Target (Nearest multiple of GCD to Base Target): ${fallbackTarget}`);
                if (fallbackTarget <= 0) { fallbackLog.push(`<span class="error">Error: Calculated Fallback Target <= 0.</span>`); resultsDiv.innerHTML = initialLog.join('\n') + '\n' + fallbackLog.join('\n') + `</div>`; return; }
                if (fallbackTarget % gcdAmounts !== 0) { fallbackLog.push(`<span class="error">Error: Fallback Target not divisible by GCD. Calc error.</span>`); resultsDiv.innerHTML = initialLog.join('\n') + '\n' + fallbackLog.join('\n') + `</div>`; return; }
                const fallbackK = fallbackTarget / gcdAmounts;
                fallbackLog.push(`Required number of GCD units (Target / GCD): ${fallbackK}`);
                const fallbackCombination = Array(fallbackK).fill(gcdAmounts);
                resultsDiv.innerHTML = initialLog.join('\n') + '\n' + fallbackLog.join('\n') + `\n\n<span class="highlight fallback-gcd">GCD Fallback Result: [${fallbackCombination.join(', ')}]</span>` + `\n(Based on GCD of input amounts, aiming for target amount ${fallbackTarget})` + `\nCombination Size: ${fallbackK}` + `</div>`;

            } else {
                // ---=== STANDARD STRATEGY ===---
                initialLog.push(`<span class="info">Standard strategy selected (found LPDs near minimum LPD).</span>`);
                // ... (Target range calculation logic same as v0.3.3) ...
                const baseTargetLPD = sumAmounts / maxSlots;
                const lowerBound = baseTargetLPD - TARGET_RANGE_BELOW;
                const upperBound = baseTargetLPD + TARGET_RANGE_ABOVE;
                const targetsToTest = [];
                const firstMultiple = Math.ceil(lowerBound / TARGET_STEP) * TARGET_STEP;
                const lastMultiple = Math.floor(upperBound / TARGET_STEP) * TARGET_STEP;
                for (let target = firstMultiple; target <= lastMultiple; target += TARGET_STEP) { if (target > 0) targetsToTest.push(target); }
                initialLog.push(`Base Calculated Target (Sum/Slots): ${baseTargetLPD.toFixed(2)}`);
                initialLog.push(`Target Range Tested (-${TARGET_RANGE_BELOW} / +${TARGET_RANGE_ABOVE}): [${lowerBound.toFixed(2)}, ${upperBound.toFixed(2)}]`);
                if (targetsToTest.length === 0) { initialLog.push(`<span class="error">Error: No positive multiples of ${TARGET_STEP} found in target range for standard method.</span>`); resultsDiv.innerHTML = initialLog.join('\n'); return; }
                initialLog.push(`Target Sums (multiples of ${TARGET_STEP} in range) to be Tested: [${targetsToTest.join(', ')}]`);

                // --- Start Standard Search ---
                const neededOtherLpds = combinationSize - 1;
                let overallSearchLog = [`--- Initial Setup ---`];
                overallSearchLog.push(...initialLog);
                overallSearchLog.push(`--- Combination Search (Standard Method) ---`);
                let overallBestCombination = null;
                let overallBestFrequencyScore = -1;
                let overallBestTargetSum = null;

                // ... (Standard search loop using findSumCombinationRecursive - same as v0.3.3) ...
                for (const currentTargetSum of targetsToTest) {
                    overallSearchLog.push(`<div class="target-section">--- Testing Target Sum: ${currentTargetSum} ---`);
                    let foundCombinationForThisTarget = false;
                    for (const currentObligatoryCandidate of obligatoryCandidates) {
                        const currentObligatoryLpdValue = currentObligatoryCandidate.value;
                        overallSearchLog.push(`<div class="candidate-section">=== Trying Obligatory Candidate LPD: ${currentObligatoryLpdValue} for target ${currentTargetSum} ===`);
                        const searchLpdList = uniqueValidLpdListWithFreq.filter(lpdObj => lpdObj.value !== currentObligatoryLpdValue);
                        if (neededOtherLpds > 0 && searchLpdList.length < neededOtherLpds) { overallSearchLog.push(`   Skipping: Not enough other unique LPDs (${searchLpdList.length}) available.`); overallSearchLog.push(`</div>`); continue; }
                        const targetForRecursion = currentTargetSum - currentObligatoryLpdValue;
                        overallSearchLog.push(`   Target sum for remaining ${neededOtherLpds} LPDs: ${currentTargetSum} - ${currentObligatoryLpdValue} = ${targetForRecursion}`);
                        let foundKMinus1Combination = null;
                        if (targetForRecursion < 0 && neededOtherLpds > 0) { overallSearchLog.push(`   Skipping: Target for remaining LPDs (${targetForRecursion}) is negative.`); }
                        else if (neededOtherLpds === 0) { if (Math.abs(targetForRecursion) < 0.01) { foundKMinus1Combination = []; } else { overallSearchLog.push(`   Skipping: Need 0 more LPDs, but obligatory ${currentObligatoryLpdValue} != target ${currentTargetSum}.`); } }
                        else if (targetForRecursion === 0 && neededOtherLpds > 0) { overallSearchLog.push(`   Skipping: Need ${neededOtherLpds} more LPDs, but remaining target is 0.`); }
                        else if (neededOtherLpds > 0 && targetForRecursion > 0) { foundKMinus1Combination = findSumCombinationRecursive(searchLpdList, targetForRecursion, neededOtherLpds, 0, []); }
                        if (foundKMinus1Combination !== null) {
                            const currentFullCombination = [...foundKMinus1Combination, currentObligatoryLpdValue].sort((a, b) => a - b);
                            const currentFrequencyScore = getFrequencyScore(currentFullCombination, lpdFrequencies);
                            overallSearchLog.push(`   <span class="success">Found Exact Sum Combination: [${currentFullCombination.join(', ')}] (Sum: ${currentTargetSum}, Freq Score: ${currentFrequencyScore})</span>`);
                            foundCombinationForThisTarget = true;
                            if (overallBestCombination === null || currentFrequencyScore > overallBestFrequencyScore) {
                                overallSearchLog.push(`   <span class="info">   ** New OVERALL Best Combination Found (Higher Freq Score) **</span>`);
                                overallBestCombination = currentFullCombination;
                                overallBestFrequencyScore = currentFrequencyScore;
                                overallBestTargetSum = currentTargetSum;
                            }
                        } else { overallSearchLog.push(`   -> No combination of ${neededOtherLpds} other distinct LPDs found summing to ${targetForRecursion}.`); }
                        overallSearchLog.push(`</div>`);
                    }
                    if (!foundCombinationForThisTarget) { overallSearchLog.push(`   <span class="info">No combinations found for target ${currentTargetSum} after trying all obligatory candidates.</span>`); }
                     overallSearchLog.push(`</div>`);
                }

                // --- Display Result or Trigger Proportional Fallback ---
                resultsDiv.innerHTML = overallSearchLog.join('\n');

                if (overallBestCombination !== null) {
                    // --- Standard Method SUCCESS ---
                    resultsDiv.innerHTML += `\n\n<hr>\n`
                                     + `<span class="highlight">Overall Best LPD Combination Found (${combinationSize} LPDs): [${overallBestCombination.join(', ')}]</span>`
                                     + `\n(Standard Method: Highest frequency score among valid combinations for targets [${targetsToTest.join(', ')}])`
                                     + `\nAchieved Target Sum: ${overallBestTargetSum}`
                                     + `\nTotal Frequency Score: ${overallBestFrequencyScore}`;
                } else {
                    // --- Standard Method FAILED -> PROPORTIONAL FALLBACK ---
                    resultsDiv.innerHTML += `\n\n<hr>\n`
                                         + `<span class="error">Standard Method Failed: No exact sum combination found for targets [${targetsToTest.join(', ')}].</span>`
                                         + `\n<span class="fallback-prop">ALERT: Attempting Proportional Fallback Strategy (Rounding to nearest ${PROPORTIONAL_ROUNDING_STEP}).</span>`; // Updated Alert

                    let propFallbackLog = [`<div class="proportional-fallback-section">--- Proportional Fallback Calculation (Round to ${PROPORTIONAL_ROUNDING_STEP}) ---`]; // Updated Section Title

                    const averageValuePerSlot = sumAmounts / maxSlots;
                    propFallbackLog.push(`Average Value Per Slot (Total Sum / Max Slots): ${averageValuePerSlot.toFixed(2)}`);

                    if (uniqueValidLpdListWithFreq.length < combinationSize) { /* ... Error handling ... */ propFallbackLog.push(`<span class="error">Error: Not enough unique valid LPDs (${uniqueValidLpdListWithFreq.length}) for proportional combination size ${combinationSize}.</span>`); resultsDiv.innerHTML += '\n' + propFallbackLog.join('\n') + `</div>`; return; }

                    const selectedTopLpds = uniqueValidLpdListWithFreq.slice(0, combinationSize);
                    const selectedLpdValues = selectedTopLpds.map(lpd => lpd.value);
                    propFallbackLog.push(`Selected Top ${combinationSize} LPD Values for Proportions: [${selectedLpdValues.join(', ')}]`);

                    const totalLpdValueMass = selectedLpdValues.reduce((sum, val) => sum + val, 0);
                    propFallbackLog.push(`Sum of Selected LPD Values (Proportional Mass): ${totalLpdValueMass}`);

                    if (totalLpdValueMass <= 0) { /* ... Error handling ... */ propFallbackLog.push(`<span class="error">Error: Sum of selected LPD values is ${totalLpdValueMass}. Cannot calculate proportions.</span>`); resultsDiv.innerHTML += '\n' + propFallbackLog.join('\n') + `</div>`; return; }

                    // --- MODIFIED CALCULATION: Round to nearest 50 ---
                    const proportionalCombination = selectedLpdValues.map(lpdVal => {
                        const exactProportion = averageValuePerSlot * lpdVal / totalLpdValueMass;
                        return roundToNearest(exactProportion, PROPORTIONAL_ROUNDING_STEP); // Use helper function
                    });
                    // --- End Modification ---

                    const sumOfProportionalCombination = proportionalCombination.reduce((sum, val) => sum + val, 0);

                    propFallbackLog.push(`Calculated Proportional Combination (Rounded to ${PROPORTIONAL_ROUNDING_STEP}): [${proportionalCombination.join(', ')}]`);
                    propFallbackLog.push(`Sum of Proportional Combination: ${sumOfProportionalCombination} (Compare to Average Value Per Slot: ${averageValuePerSlot.toFixed(2)})`);

                    resultsDiv.innerHTML += '\n' + propFallbackLog.join('\n')
                                        + `\n\n<span class="highlight fallback-prop">Proportional Fallback Result: [${proportionalCombination.join(', ')}]</span>`
                                        + `\n(Distributed average value per slot proportionally based on top ${combinationSize} LPDs by freq/value, rounded to nearest ${PROPORTIONAL_ROUNDING_STEP})` // Updated description
                                        + `</div>`;
                }
            } // End Standard vs GCD Fallback if/else

        } // End findBestCombination
    </script>
</body>
</html>