<!DOCTYPE html>
<html lang="pt-BR">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <!-- MUDANÇA: Título mais específico -->
    <title>Sistema de Montagem de Planos v0.5 (Método Selecionável)</title>
    <style>/* Resetando alguns estilos padrão e definindo variáveis */
        :root {
            /* Cores - Dark Mode */
            --bg-primary: #121212;
            --bg-secondary: #1e1e1e;
            --bg-tertiary: #252525;
            --bg-card: #2d2d2d;
            --text-primary: #e0e0e0;
            --text-secondary: #b0b0b0;
            --text-muted: #888888;
            --border: #444444;
            --primary: #3b82f6;
            --primary-dark: #2563eb;
            --primary-light: #1e40af;
            --secondary: #64748b;
            --secondary-dark: #475569;
            --success: #10b981;
            --success-dark: #059669;
            --warning: #f59e0b;
            --warning-dark: #d97706;
            --danger: #ef4444;
            --danger-dark: #dc2626;
            --code-bg: #2d2d2d;
            --sidebar-width: 200px;
            
            /* Elementos de UI */
            --border-radius: 4px;
            --shadow-sm: 0 1px 3px rgba(0,0,0,0.2);
            --shadow: 0 4px 6px rgba(0,0,0,0.3);
            --transition: all 0.2s ease;
            --font-sans: 'Inter', -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, Helvetica, Arial, sans-serif;
            --font-mono: 'Roboto Mono', 'Fira Code', 'Courier New', monospace;
        }
        
        /* Estilos Base */
        * {
            box-sizing: border-box;
            margin: 0;
            padding: 0;
        }
        
        html {
            scroll-behavior: smooth;
        }
        
        body {
            font-family: var(--font-sans);
            font-size: 0.9rem;
            line-height: 1.5;
            color: var(--text-primary);
            background-color: var(--bg-primary);
            padding-left: calc(var(--sidebar-width) + 20px);
            padding-top: 10px;
            padding-right: 15px;
            padding-bottom: 20px;
        }
        
        h1, h2, h3, h4, h5, h6 {
            font-weight: 600;
            line-height: 1.2;
            margin-bottom: 0.75rem;
            color: var(--text-primary);
        }
        
        h1 {
            font-size: 1.5rem;
            margin-top: 0.5rem;
            padding-bottom: 0.5rem;
            border-bottom: 1px solid var(--border);
        }
        
        h2 {
            font-size: 1.25rem;
            margin-top: 1.5rem;
            padding-bottom: 0.25rem;
        }
        
        p {
            margin-bottom: 0.75rem;
        }
        
        /* Formulários e Entradas */
        label {
            display: block;
            margin-top: 0.75rem;
            margin-bottom: 0.25rem;
            font-weight: 500;
            color: var(--text-primary);
            font-size: 0.9rem;
        }
        
        textarea, input[type="text"], input[type="number"] {
            width: 100%;
            padding: 0.5rem;
            border: 1px solid var(--border);
            border-radius: var(--border-radius);
            background-color: var(--bg-tertiary);
            color: var(--text-primary);
            font-family: var(--font-sans);
            font-size: 0.85rem;
            transition: var(--transition);
        }
        
        textarea {
            min-height: 130px;
            font-family: var(--font-mono);
            line-height: 1.4;
            resize: vertical;
        }
        
        textarea:focus, input[type="text"]:focus, input[type="number"]:focus {
            outline: none;
            border-color: var(--primary);
            box-shadow: 0 0 0 2px rgba(59, 130, 246, 0.2);
        }
        
        input[type="number"] {
            max-width: 150px;
        }
        
        .input-group {
            margin-bottom: 1rem;
        }
        
        /* Botões */
        button {
            display: inline-flex;
            align-items: center;
            justify-content: center;
            padding: 0.5rem 1rem;
            font-size: 0.85rem;
            font-weight: 500;
            line-height: 1.5;
            color: white;
            background-color: var(--primary);
            border: none;
            border-radius: var(--border-radius);
            cursor: pointer;
            transition: var(--transition);
            box-shadow: var(--shadow-sm);
            margin-right: 0.5rem;
            margin-bottom: 0.5rem;
        }
        
        button:hover {
            background-color: var(--primary-dark);
            box-shadow: var(--shadow);
        }
        
        button:active {
            transform: translateY(1px);
            box-shadow: var(--shadow-sm);
        }
        
        button.secondary {
            background-color: var(--secondary);
        }
        
        button.secondary:hover {
            background-color: var(--secondary-dark);
        }
        
        /* Sidebar */
        #sidebar {
            position: fixed;
            left: 0;
            top: 0;
            width: var(--sidebar-width);
            height: 100%;
            background-color: var(--bg-secondary);
            border-right: 1px solid var(--border);
            padding: 1rem 0.75rem;
            overflow-y: auto;
            z-index: 100;
        }
        
        #sidebar h3 {
            margin-top: 0;
            margin-bottom: 1rem;
            padding: 0 0.5rem 0.5rem 0.5rem;
            border-bottom: 1px solid var(--border);
            font-size: 1rem;
            color: var(--text-primary);
        }
        
        #sidebar ul {
            list-style: none;
            padding: 0;
            margin: 0;
        }
        
        #sidebar li {
            margin-bottom: 0.15rem;
        }
        
        #sidebar li a {
            display: block;
            padding: 0.4rem 0.5rem;
            text-decoration: none;
            color: var(--text-secondary);
            border-radius: var(--border-radius);
            transition: var(--transition);
            font-size: 0.85rem;
        }
        
        #sidebar li a:hover {
            background-color: var(--bg-tertiary);
            color: var(--primary);
        }
        
        /* Caixas de Resultado */
        #finderResultsLog, #foundCombinationDisplay, #statusArea, #strategyComparison, 
        #allocationResults, #cumulativeUsage, #adjustmentLog, #lpdBreakdown, 
        #finalSummaryTableDiv, #variationLog {
            margin-top: 1rem;
            padding: 0.75rem;
            border-radius: var(--border-radius);
            background-color: var(--bg-card);
            box-shadow: var(--shadow-sm);
            font-family: var(--font-mono);
            font-size: 0.85rem;
            line-height: 1.4;
            overflow-x: auto;
            border-left: 2px solid var(--border);
        }
        
        /* Estilo específico para cada tipo de caixa */
        #finderResultsLog {
            white-space: pre-wrap;
            border-left-color: var(--primary);
        }
        
        #foundCombinationDisplay {
            padding: 0.75rem;
            border: none;
            background-color: var(--bg-tertiary);
            font-weight: 600;
            border-left: 2px solid var(--primary);
        }
        
        #statusArea {
            border-left-color: var(--secondary);
        }
        
        #strategyComparison {
            border-left-color: var(--secondary);
        }
        
        #allocationResults, #adjustmentLog, #cumulativeUsage, #lpdBreakdown {
            border-left-color: var(--success);
        }
        
        #variationLog {
            border-left-color: var(--warning);
        }
        
        #finalSummaryTableDiv {
            border-left-color: var(--primary);
        }
        
        /* Separadores */
        hr {
            border: none;
            height: 1px;
            background-color: var(--border);
            margin: 1.5rem 0 1rem 0;
        }
        
        /* Alertas e Destaques */
        .error {
            color: var(--danger);
            font-weight: 500;
        }
        
        .info {
            color: var(--primary);
        }
        
        .warning {
            color: var(--warning);
            font-weight: 500;
        }
        
        .success {
            color: var(--success);
            font-weight: 500;
        }
        
        .highlight {
            background-color: rgba(245, 158, 11, 0.15);
            font-weight: 500;
            border-radius: 2px;
            padding: 0.1rem 0.3rem;
            border: none;
        }
        
        /* Classes de Combinação */
        .fallback-gcd {
            color: var(--warning);
            font-weight: 600;
        }
        
        .fallback-prop {
            color: var(--secondary);
            font-weight: 600;
        }
        
        .target-section {
            border-top: 1px solid var(--border);
            padding-top: 0.75rem;
            margin-top: 1rem;
        }
        
        .candidate-section {
            border-left: 2px solid var(--border);
            padding-left: 0.75rem;
            margin: 0.5rem 0;
            padding-top: 0.25rem;
            padding-bottom: 0.25rem;
        }
        
        .fallback-section {
            border-top: 1px solid var(--warning-dark);
            padding-top: 0.75rem;
            margin-top: 1rem;
        }
        
        .proportional-fallback-section, .proportional-direct-section {
            border-top: 1px solid var(--secondary-dark);
            padding-top: 0.75rem;
            margin-top: 1rem;
        }
        
        /* Classes de Alocação */
        .positive-diff {
            color: var(--danger);
            font-weight: 500;
        }
        
        .negative-diff {
            color: var(--success);
            font-weight: 500;
        }
        
        .zero-diff {
            color: var(--text-muted);
        }
        
        .violation {
            background-color: rgba(239, 68, 68, 0.15);
            color: var(--danger);
            border-radius: 2px;
            padding: 0.1rem 0.3rem;
            font-weight: 500;
        }
        
        .item-allocation, .adjustment-step, .lpd-section, .variation-step {
            border-top: 1px dashed var(--border);
            margin-top: 0.75rem;
            padding-top: 0.75rem;
        }
        
        .usage-summary, .lpd-section-title, .comparison-title {
            margin-top: 1rem;
            font-weight: 600;
            color: var(--text-primary);
        }
        
        .lpd-item-list {
            margin-left: 1.25rem;
            list-style-type: none;
            padding-left: 0;
        }
        
        .lpd-item-list li {
            margin-bottom: 0.15rem;
            padding: 0.15rem 0;
        }
        
        .lpd-total {
            margin-top: 0.5rem;
            font-style: italic;
            padding-left: 1.25rem;
            color: var(--text-muted);
        }
        
        /* Tabelas */
        #finalSummaryTable, #comparisonTable {
            width: 100%;
            border-collapse: separate;
            border-spacing: 0;
            margin-top: 1rem;
            border-radius: var(--border-radius);
            overflow: hidden;
            box-shadow: var(--shadow-sm);
        }
        
        #finalSummaryTable th, #finalSummaryTable td, 
        #comparisonTable th, #comparisonTable td {
            border: 1px solid var(--border);
            padding: 0.5rem 0.75rem;
            text-align: left;
            font-size: 0.85rem;
        }
        
        #finalSummaryTable th, #comparisonTable th {
            background-color: var(--bg-tertiary);
            font-weight: 600;
            color: var(--text-primary);
            border-bottom: 2px solid var(--border);
        }
        
        #finalSummaryTable td:nth-child(n+2), 
        #comparisonTable td:nth-child(n+2) {
            text-align: right;
        }
        
        #finalSummaryTable tr:nth-child(even), 
        #comparisonTable tr:nth-child(even) {
            background-color: rgba(255, 255, 255, 0.025);
        }
        
        #finalSummaryTable tr:hover, 
        #comparisonTable tr:hover {
            background-color: rgba(59, 130, 246, 0.05);
        }
        
        .best-effort {
            background-color: rgba(245, 158, 11, 0.1) !important;
            border-left: 3px solid var(--warning);
            font-weight: 500;
        }
        
        .strategy-error-row {
            background-color: rgba(239, 68, 68, 0.1) !important;
            border-left: 3px solid var(--danger);
        }
        
        #comparisonTable .strategy-name {
            cursor: pointer;
            text-decoration: underline;
            color: var(--primary);
            text-align: left !important;
            transition: var(--transition);
        }
        
        #comparisonTable .strategy-name:hover {
            color: var(--primary-dark);
        }
        
        .comparison-table-container.hide-errors .strategy-error-row {
            display: none;
        }
        
        #toggleErrorsBtn {
            background-color: var(--secondary);
            margin-left: 0.5rem;
            font-size: 0.8rem;
            padding: 0.35rem 0.75rem;
        }
        
        #toggleErrorsBtn:hover {
            background-color: var(--secondary-dark);
        }
        
        /* Classes Específicas para Feedback Visual */
        .output-section {
            scroll-margin-top: 15px;
            transition: var(--transition);
        }
        
        /* Scrollbar customizada */
        ::-webkit-scrollbar {
            width: 8px;
            height: 8px;
        }
        
        ::-webkit-scrollbar-track {
            background: var(--bg-tertiary);
        }
        
        ::-webkit-scrollbar-thumb {
            background: var(--border);
            border-radius: 4px;
        }
        
        ::-webkit-scrollbar-thumb:hover {
            background: var(--text-muted);
        }
        
        /* Responsividade */
        @media screen and (max-width: 1100px) {
            body {
                padding-left: 15px;
                padding-right: 15px;
            }
            
            #sidebar {
                display: none;
            }
        }
        
        @media screen and (max-width: 768px) {
            body {
                padding: 10px;
                font-size: 0.85rem;
            }
            
            button {
                width: 100%;
                margin-right: 0;
            }
            
            #finderResultsLog, #foundCombinationDisplay, #statusArea, #strategyComparison, 
            #allocationResults, #cumulativeUsage, #adjustmentLog, #lpdBreakdown, 
            #finalSummaryTableDiv, #variationLog {
                padding: 0.65rem;
            }
            
            h1 {
                font-size: 1.3rem;
            }
            
            h2 {
                font-size: 1.1rem;
            }
        }
        </style>
</head>
<body>

    <!-- Navegação Lateral (Igual à v0.4) -->
    <div id="sidebar">
         <h3>Navegação</h3>
         <ul>
             <li><a href="#inputSection">Entradas</a></li>
             <li><a href="#finderTitle">Resultados da Combinação</a></li>
             <li><a href="#finderResultsLog">   • Registro da Combinação</a></li>
             <li><a href="#foundCombinationDisplay">   • Combinação Resultante</a></li>
             <li style="margin-top:10px; border-top: 1px solid #ccc; padding-top: 5px;"><a href="#allocatorTitle">Resultados do Alocador</a></li>
             <li><a href="#statusArea">   • Status</a></li>
             <li><a href="#strategyComparison">   • Comparação de Estratégias</a></li>
             <li><a href="#detailsTitle">   • Resultados Detalhados</a></li>
             <li><a href="#allocationResults">   • • Alocações por Especificação</a></li>
             <li><a href="#adjustmentLog">   • • Registro de Preenchimento</a></li>
             <li><a href="#variationLog">   • • Registro de Variação</a></li>
             <li><a href="#cumulativeUsage">   • • Uso Acumulado</a></li>
             <li><a href="#lpdBreakdown">   • • Montagem dos Planos</a></li>
             <li><a href="#finalSummaryTableDiv">   • • Tabela Comparativa Final</a></li>
         </ul>
    </div>

    <!-- Área de Conteúdo Principal -->
    <h1 id="inputSection">Sistema de Montagem de Planos (Método Selecionável)</h1>
    <p>Insira os dados brutos das Especificações e Quantidades. Escolha entre encontrar a 'melhor' combinação de Planos (usando lógica Padrão/MDC/Proporcional) OU calcular diretamente uma combinação Proporcional, e então alocar os Especificações usando a combinação escolhida.</p>

    <!-- Campos de Entrada (Iguais) -->
    <div class="input-group">
        <label for="tableData">Dados da Tabela (Especificação + Quantidade, um por linha):</label>
        <textarea id="tableData" placeholder="Exemplo:
Especificação A	10000
Especificação B	7500
Especificação C	20000
..."></textarea>
    </div>
    <div class="input-group">
        <label for="maxSlots">Imagens no Plano :</label>
        <input type="number" id="maxSlots" min="1" placeholder="ex: 8" required>
    </div>
    <div class="input-group">
        <label for="combinationSize">Quantidade de Planos :</label>
        <input type="number" id="combinationSize" value="1" min="1">
    </div>

    <!-- MUDANÇA: Dois botões -->
    <button onclick="initiateProcess('findBest')">Buscar por Frequência MDC & Montar</button>
    <button onclick="initiateProcess('forceProportional')" class="secondary">Buscar por Proporção & Montar</button>

    <!-- Áreas de Saída -->

    <!-- Seção para Resultados da Combinação -->
    <hr style="margin-top: 25px; border-top: 2px solid #007bff;">
    <h2 id="finderTitle" class="output-section">Resultados da Combinação</h2>
    <div id="finderResultsLog" class="output-section">O registro da geração da combinação aparecerá aqui...</div>
    <div id="foundCombinationDisplay" class="output-section">A Combinação de Planos gerada aparecerá aqui...</div>

    <!-- Seção para Resultados do Alocador (Estrutura igual) -->
    <hr style="margin-top: 25px; border-top: 2px solid #28a745;">
    <h2 id="allocatorTitle" class="output-section">Resultados do Alocador de Especificações</h2>
    <div id="statusArea" class="output-section">Mensagens de status do alocador aparecerão aqui...</div>
    <div id="strategyComparison" class="output-section">Resultados da Comparação de Estratégias aparecerão aqui...</div>
    <hr style="margin-top: 25px; border-top: 1px solid #bbb;">
    <h2 id="detailsTitle" class="output-section" style="margin-top: 5px; font-size: 1.1em;">Resultados Detalhados da Alocação</h2>
    <div id="allocationResults" class="output-section">Resultados detalhados da Alocação por Especificação aparecerão aqui...</div>
    <div id="adjustmentLog" class="output-section">Registro de Ajuste de Preenchimento de Imagens aparecerá aqui...</div>
    <div id="variationLog" class="output-section">Registro de Ajuste de Variação aparecerá aqui...</div>
    <div id="cumulativeUsage" class="output-section">Uso acumulado de Planos aparecerá aqui...</div>
    <div id="lpdBreakdown" class="output-section">Montagem dos Planos por Instância de Especificação aparecerá aqui...</div>
    <div id="finalSummaryTableDiv" class="output-section">Tabela Comparativa Final da Alocação aparecerá aqui...</div>


    <script>
        // --- ARMAZENAMENTO GLOBAL (Igual à v0.4) ---
        let globalStrategyResults = [];
        let globalOriginalItems = []; // Renomeado mentalmente para Especificações Originais
        let globalUniqueLpdValues = []; // Renomeado mentalmente para Valores Únicos de Plano
        let globalUserLpdCombinationWithDuplicates = []; // Renomeado mentalmente para Combinação de Planos do Usuário com Duplicatas
        let globalLpdInstanceCounts = {}; // Renomeado mentalmente para Contagem de Instâncias de Plano
        let globalInitialTotalSlotsPerValue = {}; // Renomeado mentalmente para Total Inicial de Imagens por Valor
        let globalMaxSlotsPerInstance = Infinity; // Renomeado mentalmente para Máximo de Imagens por Instância
        let globalMaxSlotsDisplay = "Ilimitado"; // Renomeado mentalmente para Exibição Máx Imagens

        // --- REGRAS DE CONFIGURAÇÃO (Iguais à v0.4) ---
        const MIN_LPD_VALUE = 2000; // Valor Mínimo do Plano
        const OBLIGATORY_RANGE = 500; // Intervalo Obrigatório
        const TARGET_RANGE_BELOW = 500; // Intervalo Alvo Abaixo
        const TARGET_RANGE_ABOVE = 1000; // Intervalo Alvo Acima
        const TARGET_STEP = 500; // Passo do Alvo
        const PROPORTIONAL_ROUNDING_STEP = 50; // Passo de Arredondamento Proporcional
        const MIN_LPD_VALUE_ALLOC = 0; // Valor Mínimo do Plano na Alocação
        const VARIATION_LIMIT_PASS_3 = 0.25; // Limite de Variação Passo 3
        const REPROCESS_VARIATION_LIMIT = 0.30; // Limite de Variação para Reprocessamento

        // --- FUNÇÕES AUXILIARES (Iguais à v0.4) ---
        function gcd(a, b) { a = Math.abs(a); b = Math.abs(b); if (b === 0) return a; return gcd(b, a % b); } // mdc
        function arrayGcd(numbers) { if (!numbers || numbers.length === 0) return 0; if (numbers.length === 1) return Math.abs(numbers[0]); let result = Math.abs(numbers[0]); for (let i = 1; i < numbers.length; i++) { result = gcd(result, numbers[i]); if (result === 1) return 1; } return result; } // mdcArray
        function findSumCombinationRecursive(lpdValueObjectsToSearch, target, k, startIndex, currentCombinationValues) { // encontrarCombinacaoSomaRecursiva (nomes de variáveis internos mantidos em inglês)
            if (currentCombinationValues.length === k) {
                const currentSum = currentCombinationValues.reduce((sum, item) => sum + item, 0);
                if (Math.abs(currentSum - target) < 0.01) { return [...currentCombinationValues]; }
                return null;
            }
             if (startIndex >= lpdValueObjectsToSearch.length ||
                currentCombinationValues.length > k ||
                (k > 0 && lpdValueObjectsToSearch.length - startIndex < k - currentCombinationValues.length)) { return null; }
            if (k === 0) return null;
            for (let i = startIndex; i < lpdValueObjectsToSearch.length; i++) {
                const currentLpdValue = lpdValueObjectsToSearch[i].value;
                // Permitir duplicatas se k for maior que o número de objetos únicos
                // if (!currentCombinationValues.includes(currentLpdValue)) { // Removido para permitir duplicatas se necessário para a soma
                    currentCombinationValues.push(currentLpdValue);
                    const result = findSumCombinationRecursive(lpdValueObjectsToSearch, target, k, i + 1, currentCombinationValues); // i + 1 para não repetir o mesmo índice, mas o valor pode ser repetido
                    if (result) { return result; }
                    currentCombinationValues.pop();
                // }
            }
            return null;
         }
        function getFrequencyScore(combination, lpdFrequencies) { // obterPontuacaoFrequencia
             let score = 0; for (const lpdValue of combination) { score += (lpdFrequencies[lpdValue] || 0); } return score;
        }
        function roundToNearest(value, multiple) { // arredondarParaMultiploMaisProximo
             if (multiple <= 0) return Math.round(value); return Math.round(value / multiple) * multiple;
        }
        function findClosestSumWithRepetitionAndSlots(uniqueLpdValuesAvailable, target, remainingSlotsMap) { // encontrarSomaMaisProximaComRepeticaoEImagens
            if (!uniqueLpdValuesAvailable || uniqueLpdValuesAvailable.length === 0) { return { sum: 0, difference: 0 - target, combination: [], error: "Nenhum Plano fornecido para alocação" }; }
            if (target < 0) { return { sum: 0, difference: 0 - target, combination: [], error: "Quantidade alvo não pode ser negativa" }; }
            const validLpdsWithSlots = uniqueLpdValuesAvailable.filter(lpd => lpd > 0 && remainingSlotsMap.hasOwnProperty(lpd) && remainingSlotsMap[lpd] > 0).sort((a, b) => a - b);
            if (validLpdsWithSlots.length === 0) { return { sum: 0, difference: 0 - target, combination: [], error: "Lista de Planos vazia ou nenhum Plano tem imagens restantes" }; }
            const smallestLpd = validLpdsWithSlots[0];
            const maxSum = Math.max(target, 0) + smallestLpd; // Ajuste para garantir que o alvo e valores próximos sejam alcançáveis
            const dp = new Array(maxSum + 1).fill(null); // dp[i] = { count, usage, lastLpd } para alcançar a soma i com o mínimo de LPDs
            dp[0] = { count: 0, usage: {}, lastLpd: null }; // Estado base: soma 0 usa 0 LPDs

            for (let i = 1; i <= maxSum; i++) {
                let bestStateForI = null; // Melhor estado encontrado para alcançar a soma i
                for (const lpd of validLpdsWithSlots) {
                    const prevSum = i - lpd;
                    if (prevSum >= 0 && dp[prevSum] !== null) {
                        const prevState = dp[prevSum];
                        const currentLpdUsageInThisPath = (prevState.usage[lpd] || 0) + 1;
                        const slotsAvailable = remainingSlotsMap[lpd];

                         if (slotsAvailable === Infinity || currentLpdUsageInThisPath <= slotsAvailable) {
                            // Podemos usar este LPD
                            const newTotalCount = prevState.count + 1;
                            if (bestStateForI === null || newTotalCount < bestStateForI.count) {
                                // Este caminho é melhor (usa menos LPDs)
                                const newUsage = { ...prevState.usage }; newUsage[lpd] = currentLpdUsageInThisPath;
                                bestStateForI = { count: newTotalCount, usage: newUsage, lastLpd: lpd };
                            }
                        }
                    }
                }
                dp[i] = bestStateForI;
            }

            // Encontrar a soma alcançável mais próxima do alvo
            let minAbsDiff = Infinity; let closestSum = -1; let bestReachableState = null;
            // Procurar para baixo a partir do alvo
            for (let i = target; i >= 0; i--) { if (dp[i] !== null) { const diff = Math.abs(target - i); if (diff < minAbsDiff || (diff === minAbsDiff && dp[i].count < bestReachableState.count)) { minAbsDiff = diff; closestSum = i; bestReachableState = dp[i]; } if (diff > minAbsDiff && closestSum !== -1) break; /* Otimização */ } }
            // Procurar para cima a partir do alvo
            for (let i = target + 1; i <= maxSum; i++) { if (dp[i] !== null) { const diff = Math.abs(i - target); if (diff < minAbsDiff || (diff === minAbsDiff && dp[i].count < bestReachableState.count)) { minAbsDiff = diff; closestSum = i; bestReachableState = dp[i]; } if (diff >= minAbsDiff && closestSum !== -1) break; /* Otimização */ } }

             if (closestSum === -1) { // Caso especial: alvo é 0 e dp[0] existe
                 if (target === 0 && dp[0] !== null) {
                     closestSum = 0; bestReachableState = dp[0];
                 } else {
                     return { sum: 0, difference: 0 - target, combination: [], error: "Não foi possível alcançar a soma alvo ou valor próximo" };
                 }
             }

            // Reconstruir a combinação a partir do estado DP
            const combination = []; let currentSum = closestSum; let currentState = bestReachableState; let safetyCounter = 0; const maxLoops = (currentState?.count || 0) + validLpdsWithSlots.length + 100; // Limite de segurança generoso
            while (currentSum > 0 && currentState?.lastLpd && safetyCounter < maxLoops) { const usedLpd = currentState.lastLpd; combination.push(usedLpd); const prevSum = currentSum - usedLpd; if (prevSum >= 0 && dp[prevSum] !== null) { currentState = dp[prevSum]; currentSum = prevSum; } else { console.error(`Erro de Backtracking DP: Estado faltando para soma ${prevSum}`); return { sum: closestSum, difference: closestSum - target, combination: combination.sort((a, b) => a - b), error: `Erro de backtracking: Estado faltando para soma ${prevSum}` }; } safetyCounter++; }
             if (safetyCounter >= maxLoops) { console.error("Limite de segurança de backtracking DP atingido."); return { sum: closestSum, difference: closestSum - target, combination: combination.sort((a, b) => a - b), error: "Limite de segurança de backtracking atingido" }; }
             if (currentSum !== 0 && closestSum !== 0) { // A soma final deve ser 0, a menos que a soma alvo fosse 0
                 console.error(`Backtracking DP incompleto (soma final ${currentSum})`);
                 return { sum: closestSum, difference: closestSum - target, combination: combination.sort((a, b) => a - b), error: `Backtracking incompleto (soma final ${currentSum})` };
             }
             // Verificação de sanidade: a soma reconstruída corresponde?
             const reconstructedSum = combination.reduce((a, b) => a + b, 0); if (reconstructedSum !== closestSum) { console.error(`Incompatibilidade na reconstrução DP: ${reconstructedSum} != ${closestSum}`); return { sum: closestSum, difference: closestSum - target, combination: combination.sort((a, b) => a - b), error: `Erro de reconstrução (${reconstructedSum} != ${closestSum})` }; }
             // Verificação final de uso de imagens
             const finalUsageCheck = {}; for(const lpd of combination) { finalUsageCheck[lpd] = (finalUsageCheck[lpd] || 0) + 1; if (remainingSlotsMap[lpd] !== Infinity && finalUsageCheck[lpd] > remainingSlotsMap[lpd]) { console.error(`Limite de imagens violado para Plano ${lpd} na verificação (${finalUsageCheck[lpd]} > ${remainingSlotsMap[lpd]})`); return { sum: closestSum, difference: closestSum - target, combination: combination.sort((a, b) => a - b), error: `Limite de imagens violado para Plano ${lpd} na verificação final` }; } }

             return { sum: closestSum, difference: closestSum - target, combination: combination.sort((a, b) => a - b) };
        }
        function calculateMaxVariation(items, allocations) { // calcularVariacaoMaxima
            let maxAbsPercentage = 0; if (!items || !allocations || items.length !== allocations.length) return Infinity;
            for (let i = 0; i < items.length; i++) { const item = items[i]; const alloc = allocations[i]; if (!alloc || alloc.error || alloc.difference === undefined) continue; const targetAmount = item.amount; const difference = alloc.difference; let currentAbsPercentage = 0; if (targetAmount > 0) { currentAbsPercentage = Math.abs(difference / targetAmount); } else if (alloc.sum !== 0) { currentAbsPercentage = Infinity; /* Variação infinita se a soma não for zero para um alvo zero */ } if (currentAbsPercentage > maxAbsPercentage) { maxAbsPercentage = currentAbsPercentage; } }
            return maxAbsPercentage;
         }
        function calculateAverageVariation(items, allocations) { // calcularVariacaoMedia
            let totalPercentageSum = 0; let validItemCount = 0; if (!items || !allocations || items.length !== allocations.length) return 0;
            for (let i = 0; i < items.length; i++) { const item = items[i]; const alloc = allocations[i]; if (alloc && !alloc.error && alloc.difference !== undefined && item.amount > 0) { const absPercentage = Math.abs(alloc.difference / item.amount); totalPercentageSum += absPercentage; validItemCount++; } }
            return validItemCount > 0 ? totalPercentageSum / validItemCount : 0;
        }

        // --- FUNÇÃO FINDER DE COMBINAÇÃO (findBestLpdCombination - Permanece a mesma da v0.4, com traduções nos logs) ---
        // Tenta Padrão -> Fallback MDC -> Fallback Proporcional
        function findBestLpdCombination(parsedItemsData, maxSlotsForTargetCalc, requestedCombinationSize) {
             // ... (Lógica exatamente igual à da versão anterior v0.4, mas com logs traduzidos) ...
             // Retorna { combination: [], log: "", status: "OK"/"Error" }
             const functionLog = []; let foundCombination = null; let finderStatus = "OK";
             // 1. Validação Básica...
             if (!parsedItemsData || parsedItemsData.length === 0) { return { combination: null, log: '<span class="error">Erro do Finder: Nenhum dado de Especificação processado.</span>', status: "Error" }; }
             if (isNaN(maxSlotsForTargetCalc) || maxSlotsForTargetCalc <= 0) { return { combination: null, log: '<span class="error">Erro do Finder: Imagens Máx. Inválidas.</span>', status: "Error" }; }
             if (isNaN(requestedCombinationSize) || requestedCombinationSize < 1) { return { combination: null, log: `<span class="error">Erro do Finder: Tamanho Combo Inválido (>= 1).</span>`, status: "Error" }; }
             // 2. Processar Dados...
             const lpdFrequencies = {}; const validRawAmounts = []; let minAmountFound = Infinity; let sumAmounts = 0;
             parsedItemsData.forEach(item => { const amount = item.amount; validRawAmounts.push(amount); sumAmounts += amount; if (amount < minAmountFound) minAmountFound = amount; const lpd = Math.round(amount / 2); if (lpd >= MIN_LPD_VALUE) { lpdFrequencies[lpd] = (lpdFrequencies[lpd] || 0) + 1; } });
             if (validRawAmounts.length === 0) { return { combination: null, log: `<span class="error">Erro do Finder: Nenhuma quantidade válida.</span>`, status: "Error"}; }
             if (sumAmounts === 0 && validRawAmounts.some(a => a !== 0)) { functionLog.push(`<span class="warning">Aviso do Finder: Soma 0 apesar de itens não-zero.</span>`); }
             else if (sumAmounts === 0) { functionLog.push(`Info do Finder: Soma total 0.`); }
             // 3. Preparar Lista de Planos & Log Inicial...
             const uniqueValidLpdListWithFreq = Object.entries(lpdFrequencies).map(([lpd, freq]) => ({ value: parseInt(lpd), frequency: freq })).sort((a, b) => b.frequency - a.frequency || b.value - a.value); // Corrigido sort
             functionLog.push(`--- Registro do Finder de Combinação (Método 'Melhor') ---`);
             functionLog.push(`Qtd Mín Bruta: ${minAmountFound === Infinity ? 'N/A' : minAmountFound}, Soma Total: ${sumAmounts}`);
             functionLog.push(`Imagens Máx (Alvo): ${maxSlotsForTargetCalc}, Tam. Combo Req.: ${requestedCombinationSize}`);
             functionLog.push(`Planos Válidos Únicos (>=${MIN_LPD_VALUE}): ${uniqueValidLpdListWithFreq.length}`);
             functionLog.push(`Planos (Freq/Valor Ord.): ${uniqueValidLpdListWithFreq.map(l => `${l.value}(${l.frequency})`).join(', ')}`);
             // 4. Candidatos Obrigatórios...
             let minLpdValueFound = Infinity; uniqueValidLpdListWithFreq.forEach(lpdObj => { if (lpdObj.value < minLpdValueFound) minLpdValueFound = lpdObj.value; });
             functionLog.push(`Plano Mín Válido: ${minLpdValueFound === Infinity ? 'Nenhum' : minLpdValueFound}`);
             const obligatoryCandidates = minLpdValueFound === Infinity ? [] : uniqueValidLpdListWithFreq.filter(lpdObj => Math.abs(lpdObj.value - minLpdValueFound) <= OBLIGATORY_RANGE).sort((a, b) => a.value - b.value);
             functionLog.push(`Candidatos Próximos ao Mín (+/- ${OBLIGATORY_RANGE}): ${obligatoryCandidates.length} [${obligatoryCandidates.map(c=>c.value).join(', ')}]`);
             // 5. Decidir Estratégia...
              if (obligatoryCandidates.length === 0 && requestedCombinationSize > 1) { /* --- FALLBACK MDC --- */
                 functionLog.push(`<span class="fallback-gcd">ALERTA: Nenhum Plano próximo ao mín. Usando Fallback MDC.</span>`);
                 let fallbackLog = [`<div class="fallback-section">--- Cálculo Fallback MDC ---`];
                 const baseTargetAmount = sumAmounts / maxSlotsForTargetCalc; fallbackLog.push(`Quantidade Alvo Base: ${baseTargetAmount.toFixed(2)}`);
                 if (validRawAmounts.length < 1) { fallbackLog.push(`<span class="error">Erro: Nenhuma quantidade válida para MDC.</span>`); finderStatus = "Error"; }
                 else { const gcdAmounts = arrayGcd(validRawAmounts); fallbackLog.push(`MDC das quantidades: ${gcdAmounts}`);
                     if (gcdAmounts <= 0) { fallbackLog.push(`<span class="error">Erro: MDC <= 0 (${gcdAmounts}).</span>`); finderStatus = "Error"; }
                     else { const fallbackTarget = baseTargetAmount === 0 ? 0 : roundToNearest(baseTargetAmount, gcdAmounts); fallbackLog.push(`Alvo Fallback (múltiplo MDC): ${fallbackTarget}`);
                         if (fallbackTarget < 0) { fallbackLog.push(`<span class="error">Erro: Alvo Fallback < 0.</span>`); finderStatus = "Error"; }
                         else { const fallbackK = fallbackTarget === 0 ? 0 : Math.round(fallbackTarget / gcdAmounts);
                             if (fallbackK < 0) { fallbackLog.push(`<span class="error">Erro: Unidades MDC < 0.</span>`); finderStatus = "Error"; }
                             else { fallbackLog.push(`Unidades MDC necessárias: ${fallbackK}`); foundCombination = fallbackK > 0 ? Array(fallbackK).fill(gcdAmounts) : []; fallbackLog.push(`<span class="highlight fallback-gcd">Resultado Fallback MDC: [${foundCombination.join(', ')}]</span> (Tamanho: ${fallbackK})`); }
                         }
                     }
                 }
                 functionLog.push(fallbackLog.join('\n') + `</div>`);
              } else { /* --- PADRÃO / FALLBACK PROPORCIONAL --- */
                 let standardSearchAttempted = false; let overallBestCombination = null; let overallBestFrequencyScore = -1; let overallBestTargetSum = null;
                 if (obligatoryCandidates.length > 0) {
                     standardSearchAttempted = true; functionLog.push(`<span class="info">Estratégia padrão selecionada.</span>`);
                     const baseTargetLPD = sumAmounts / maxSlotsForTargetCalc; const lowerBound = baseTargetLPD - TARGET_RANGE_BELOW; const upperBound = baseTargetLPD + TARGET_RANGE_ABOVE; const targetsToTest = []; const firstMultiple = Math.ceil(lowerBound / TARGET_STEP) * TARGET_STEP; const lastMultiple = Math.floor(upperBound / TARGET_STEP) * TARGET_STEP; for (let target = firstMultiple; target <= lastMultiple; target += TARGET_STEP) { if (target > 0 || (target === 0 && baseTargetLPD === 0)) targetsToTest.push(target); }
                     functionLog.push(`Plano Alvo Base: ${baseTargetLPD.toFixed(2)}, Intervalo [${lowerBound.toFixed(2)}, ${upperBound.toFixed(2)}]`);
                     if (targetsToTest.length === 0) { functionLog.push(`<span class="warning">Aviso: Nenhum múltiplo alvo no intervalo. Tentando Proporcional.</span>`); }
                     else { functionLog.push(`Somas Alvo para Testar: [${targetsToTest.join(', ')}]`); const neededOtherLpds = requestedCombinationSize - 1; functionLog.push(`--- Busca de Combinação (Método Padrão, Precisa de ${neededOtherLpds} outros) ---`);
                         for (const currentTargetSum of targetsToTest) { functionLog.push(`<div class="target-section">--- Testando Soma Alvo: ${currentTargetSum} ---`); let foundCombinationForThisTarget = false;
                             for (const currentObligatoryCandidate of obligatoryCandidates) { const currentObligatoryLpdValue = currentObligatoryCandidate.value; functionLog.push(`<div class="candidate-section">=== Tentando Plano Obrigatório: ${currentObligatoryLpdValue} ===`); const searchLpdList = uniqueValidLpdListWithFreq.filter(lpdObj => lpdObj.value !== currentObligatoryLpdValue);
                                  if (neededOtherLpds > 0 && searchLpdList.length < neededOtherLpds) { functionLog.push(`   Pulando: Não há outros suficientes (${searchLpdList.length}) para tamanho ${requestedCombinationSize}.`); functionLog.push(`</div>`); continue; }
                                  const targetForRecursion = currentTargetSum - currentObligatoryLpdValue; functionLog.push(`   Alvo para os ${neededOtherLpds} restantes: ${targetForRecursion.toFixed(2)}`);
                                  if (neededOtherLpds === 0) { // Caso base: k=1
                                      if (Math.abs(targetForRecursion) < 0.01) { // A soma alvo é o próprio LPD obrigatório
                                          const currentFullCombination = [currentObligatoryLpdValue]; const currentFrequencyScore = getFrequencyScore(currentFullCombination, lpdFrequencies); functionLog.push(`   <span class="success">Encontrada Soma Exata (Tam 1): [${currentFullCombination.join(', ')}] (Soma: ${currentTargetSum}, Freq: ${currentFrequencyScore})</span>`); foundCombinationForThisTarget = true; if (overallBestCombination === null || currentFrequencyScore > overallBestFrequencyScore || (currentFrequencyScore === overallBestFrequencyScore && currentTargetSum < overallBestTargetSum)) { functionLog.push(`   <span class="info">   ** Nova MELHOR GERAL Encontrada **</span>`); overallBestCombination = currentFullCombination; overallBestFrequencyScore = currentFrequencyScore; overallBestTargetSum = currentTargetSum; }
                                       } else { functionLog.push(`   -> Alvo (${currentTargetSum}) != Plano (${currentObligatoryLpdValue}).`); }
                                    } else if (targetForRecursion >= -0.01) { // Precisa de outros Planos e o alvo restante não é negativo
                                      const adjustedTargetForRecursion = Math.max(0, targetForRecursion);
                                      // Usar a lista 'searchLpdList' que exclui o obrigatório atual
                                      let foundKMinus1Combination = findSumCombinationRecursive(searchLpdList, adjustedTargetForRecursion, neededOtherLpds, 0, []);
                                     if (foundKMinus1Combination !== null) { const currentFullCombination = [...foundKMinus1Combination, currentObligatoryLpdValue].sort((a, b) => a - b); const currentFrequencyScore = getFrequencyScore(currentFullCombination, lpdFrequencies); functionLog.push(`   <span class="success">Combo Encontrado: [${currentFullCombination.join(', ')}] (Soma: ${currentTargetSum}, Freq: ${currentFrequencyScore})</span>`); foundCombinationForThisTarget = true; if (overallBestCombination === null || currentFrequencyScore > overallBestFrequencyScore || (currentFrequencyScore === overallBestFrequencyScore && currentTargetSum < overallBestTargetSum)) { functionLog.push(`   <span class="info">   ** Nova MELHOR GERAL Encontrada **</span>`); overallBestCombination = currentFullCombination; overallBestFrequencyScore = currentFrequencyScore; overallBestTargetSum = currentTargetSum; } } else { functionLog.push(`   -> Nenhuma combo de ${neededOtherLpds} encontrada para ${adjustedTargetForRecursion.toFixed(2)}.`); }
                                  } else { functionLog.push(`   -> Alvo restante (${targetForRecursion.toFixed(2)}) negativo.`); } functionLog.push(`</div>`);
                              } if (!foundCombinationForThisTarget) { functionLog.push(`   <span class="info">Nenhuma combinação encontrada para o alvo ${currentTargetSum}.</span>`); } functionLog.push(`</div>`);
                         }
                     }
                 }
                 if (overallBestCombination !== null) { /* --- MÉTODO PADRÃO SUCESSO --- */
                      functionLog.push(`--- Resultado do Método Padrão ---`); functionLog.push(`<span class="highlight">Melhor Encontrada: [${overallBestCombination.join(', ')}]</span>`); functionLog.push(`(Soma Alvo: ${overallBestTargetSum}, Pontuação Freq: ${overallBestFrequencyScore})`); foundCombination = overallBestCombination;
                 } else { /* --- FALLBACK PROPORCIONAL --- */
                     if (standardSearchAttempted) { functionLog.push(`<span class="error">Método Padrão Falhou. Tentando Proporcional.</span>`); }
                     else if (requestedCombinationSize > 1) { functionLog.push(`<span class="info">Padrão Pulado (Sem candidatos próx. ao min). Tentando Proporcional.</span>`); }
                     functionLog.push(`<span class="fallback-prop">ALERTA: Usando Fallback Proporcional (Arredondar para ${PROPORTIONAL_ROUNDING_STEP}).</span>`);
                     let propFallbackLog = [`<div class="proportional-fallback-section">--- Cálculo Fallback Proporcional ---`];
                     const averageValuePerSlot = (maxSlotsForTargetCalc > 0 && sumAmounts > 0) ? (sumAmounts / maxSlotsForTargetCalc) : 0; propFallbackLog.push(`Valor Médio por Imagem: ${averageValuePerSlot.toFixed(2)}`);
                     if (requestedCombinationSize === 1) { propFallbackLog.push(`Tam. combo 1: Usando média arredondada.`); const roundedAverage = roundToNearest(averageValuePerSlot, PROPORTIONAL_ROUNDING_STEP); if (roundedAverage <= 0 && averageValuePerSlot > 0) { propFallbackLog.push(`<span class="error">Erro: Média arredondada <= 0.</span>`); finderStatus = "Error"; } else if (roundedAverage <= 0) { propFallbackLog.push(`Info: Média arredondada <= 0. Usando combo vazia.`); foundCombination = []; } else { foundCombination = [roundedAverage]; } if (foundCombination !== null) propFallbackLog.push(`Combo Calculada (Tam 1): [${foundCombination.join(', ')}]`);
                     } else { if (uniqueValidLpdListWithFreq.length < requestedCombinationSize) { propFallbackLog.push(`<span class="error">Erro: Planos únicos insuficientes (${uniqueValidLpdListWithFreq.length}) para tamanho ${requestedCombinationSize}.</span>`); finderStatus = "Error"; }
                         else { const selectedTopLpds = uniqueValidLpdListWithFreq.slice(0, requestedCombinationSize); const selectedLpdValues = selectedTopLpds.map(lpd => lpd.value); propFallbackLog.push(`Top ${requestedCombinationSize} Planos: [${selectedLpdValues.join(', ')}]`); const totalLpdValueMass = selectedLpdValues.reduce((sum, val) => sum + val, 0); propFallbackLog.push(`Soma dos Planos (Base): ${totalLpdValueMass}`);
                             if (totalLpdValueMass <= 0) { propFallbackLog.push(`<span class="error">Erro: Soma dos Planos <= 0.</span>`); finderStatus = "Error"; }
                             else if (averageValuePerSlot <= 0) { propFallbackLog.push(`Info: Valor médio <= 0. Resultado vazio.`); foundCombination = []; }
                             else { propFallbackLog.push(`Distribuindo Valor Médio (${averageValuePerSlot.toFixed(2)})...`); const proportionalCombination = selectedLpdValues.map(lpdVal => roundToNearest(averageValuePerSlot * (lpdVal / totalLpdValueMass), PROPORTIONAL_ROUNDING_STEP)); const finalProportionalCombination = proportionalCombination.filter(v => v > 0);
                                 if (finalProportionalCombination.length === 0) { propFallbackLog.push(`<span class="warning">Aviso: Proporcional resultou em nenhum Plano positivo. Usando vazio.</span>`); foundCombination = []; }
                                 else if (finalProportionalCombination.length < requestedCombinationSize) { propFallbackLog.push(`<span class="warning">Aviso: Proporcional resultou em apenas ${finalProportionalCombination.length} Planos positivos (req ${requestedCombinationSize}). Usando valores positivos.</span>`); foundCombination = finalProportionalCombination.sort((a,b) => a - b); }
                                 else { foundCombination = finalProportionalCombination.sort((a,b) => a - b).slice(0, requestedCombinationSize); } // Garante o tamanho correto se houver mais positivos
                                 if (foundCombination !== null) { const sumOfProp = foundCombination.reduce((sum, val) => sum + val, 0); propFallbackLog.push(`Combo Proporcional Calculada (Arred., >0): [${foundCombination.join(', ')}]`); propFallbackLog.push(`Soma: ${sumOfProp} (vs Média Imagem: ${averageValuePerSlot.toFixed(2)})`); }
                             }
                         }
                     } functionLog.push(propFallbackLog.join('\n') + `</div>`);
                 }
              }
             return { combination: foundCombination, log: functionLog.join('\n'), status: finderStatus };
        }


        // --- NOVO: FUNÇÃO DE COMBINAÇÃO PROPORCIONAL DIRETA ---
        // Calcula a combinação *apenas* usando o método Proporcional com a regra do Plano Mínimo
        function calculateDirectProportionalCombination(parsedItemsData, maxSlotsForTargetCalc, requestedCombinationSize) {
            const functionLog = [];
            let foundCombination = null;
            let finderStatus = "OK";

            // 1. Validação Básica (Similar a findBest...)
            if (!parsedItemsData || parsedItemsData.length === 0) { return { combination: null, log: '<span class="error">Erro Calc Prop: Nenhum dado de Especificação processado.</span>', status: "Error" }; }
            if (isNaN(maxSlotsForTargetCalc) || maxSlotsForTargetCalc <= 0) { return { combination: null, log: '<span class="error">Erro Calc Prop: Imagens Máx. Inválidas.</span>', status: "Error" }; }
            if (isNaN(requestedCombinationSize) || requestedCombinationSize < 1) { return { combination: null, log: `<span class="error">Erro Calc Prop: Tamanho Combo Inválido (>= 1).</span>`, status: "Error" }; }

            // 2. Processar Dados & Calcular Frequências (Similar a findBest...)
            const lpdFrequencies = {}; const validRawAmounts = []; const allValidLpds = [];
            let sumAmounts = 0; let minAmountFound = Infinity;
            parsedItemsData.forEach(item => { const amount = item.amount; validRawAmounts.push(amount); sumAmounts += amount; if (amount < minAmountFound) minAmountFound = amount; const lpd = Math.round(amount / 2); if (lpd >= MIN_LPD_VALUE) { lpdFrequencies[lpd] = (lpdFrequencies[lpd] || 0) + 1; allValidLpds.push(lpd); } });
            if (validRawAmounts.length === 0) { return { combination: null, log: `<span class="error">Erro Calc Prop: Nenhuma quantidade válida.</span>`, status: "Error"}; }
             if (sumAmounts === 0 && validRawAmounts.some(a => a !== 0)) { functionLog.push(`<span class="warning">Aviso Calc Prop: Soma 0 apesar de itens não-zero.</span>`); }
             else if (sumAmounts === 0) { functionLog.push(`Info Calc Prop: Soma total 0.`); }

            // 3. Preparar Lista Única de Planos & Dados da Regra do Plano Mín (Similar à lógica v0.3.7)
            const uniqueValidLpdListWithFreq = Object.entries(lpdFrequencies).map(([lpd, freq]) => ({ value: parseInt(lpd), frequency: freq })).sort((a, b) => b.frequency - a.frequency || b.value - a.value); // Ordena por freq (desc) e valor (asc)
            let minLpdValueFound = Infinity; if (allValidLpds.length > 0) { minLpdValueFound = Math.min(...allValidLpds); }
            const nearMinLpds = minLpdValueFound === Infinity ? [] : uniqueValidLpdListWithFreq.filter(lpdObj => Math.abs(lpdObj.value - minLpdValueFound) <= OBLIGATORY_RANGE).sort((a, b) => b.frequency - a.frequency || a.value - b.value); // Perto do mínimo, ordenado por freq (desc) e valor (asc)

            functionLog.push(`--- Registro de Cálculo Proporcional Direto ---`);
            functionLog.push(`Qtd Mín Bruta: ${minAmountFound === Infinity ? 'N/A' : minAmountFound}, Soma Total: ${sumAmounts}`);
            functionLog.push(`Imagens Máx (Alvo): ${maxSlotsForTargetCalc}, Tam. Combo Req.: ${requestedCombinationSize}`);
            functionLog.push(`Planos Válidos Únicos (>=${MIN_LPD_VALUE}): ${uniqueValidLpdListWithFreq.length}`);
            functionLog.push(`Planos (Freq/Valor Ord.): ${uniqueValidLpdListWithFreq.map(l => `${l.value}(${l.frequency})`).join(', ')}`);
            functionLog.push(`Plano Mín Válido: ${minLpdValueFound === Infinity ? 'Nenhum' : minLpdValueFound}`);
            functionLog.push(`Candidatos Próximos ao Mín (+/- ${OBLIGATORY_RANGE}): ${nearMinLpds.length} [${nearMinLpds.map(c=>c.value + '(' + c.frequency + ')').join(', ')}]`);

            // 4. Verificar se há Planos únicos suficientes
            if (uniqueValidLpdListWithFreq.length < requestedCombinationSize && requestedCombinationSize > 0) { // Permitir tamanho 0 se for solicitado/possível
                 functionLog.push(`<span class="error">Erro: Planos válidos únicos insuficientes (${uniqueValidLpdListWithFreq.length}) disponíveis para o tamanho solicitado ${requestedCombinationSize}.</span>`);
                 return { combination: null, log: functionLog.join('\n'), status: "Error" };
             }

            // 5. Determinar Planos para Cálculo (Aplicar Regra do Plano Mín - lógica da v0.3.7)
            functionLog.push(`--- Selecionando Planos para Cálculo Proporcional ---`);
            let selectionLog = [];
            let finalSelectedLpdsForProportion = []; // Contém objetos {value, frequency}

            if (requestedCombinationSize === 1) {
                selectionLog.push(`Tam. combo 1: Ajuste da regra do Plano Mín não aplicado à seleção.`);
                if (uniqueValidLpdListWithFreq.length > 0) { finalSelectedLpdsForProportion = [uniqueValidLpdListWithFreq[0]]; selectionLog.push(`(Usando valor médio; Plano Top para referência: ${finalSelectedLpdsForProportion[0].value})`); }
                else { selectionLog.push(`(Nenhum Plano único encontrado).`); }
            } else if (requestedCombinationSize > 1) { // Só aplica a regra se o tamanho for > 1
                const initialTopLpds = uniqueValidLpdListWithFreq.slice(0, requestedCombinationSize);
                selectionLog.push(`Top ${requestedCombinationSize} Planos Iniciais (por Freq/Valor): [${initialTopLpds.map(l => `${l.value}(${l.frequency})`).join(', ')}]`);
                const initialSelectionValues = initialTopLpds.map(lpd => lpd.value);
                const meetsMinLpdRule = nearMinLpds.length === 0 || initialSelectionValues.some(val => nearMinLpds.some(nearLpd => nearLpd.value === val));

                if (meetsMinLpdRule) {
                    selectionLog.push(`<span class="info">Regra do Plano Mín Atendida: Seleção inicial inclui Plano próximo ao mín (ou nenhum existe).</span>`);
                    finalSelectedLpdsForProportion = initialTopLpds;
                } else {
                    selectionLog.push(`<span class="warning">Regra do Plano Mín NÃO Atendida: Tentando substituição.</span>`);
                    if (nearMinLpds.length > 0) {
                        const bestNearMinLpd = nearMinLpds[0]; // O de maior freq perto do mín
                        selectionLog.push(`   - Melhor Candidato Próximo ao Mín: ${bestNearMinLpd.value}(${bestNearMinLpd.frequency})`);
                        let indexToReplace = -1; let minFreq = Infinity; let minValueAtMinFreq = Infinity;
                        // Encontra o de menor freq na seleção inicial (que não seja ele mesmo um perto do mín)
                        for(let i = 0; i < initialTopLpds.length; i++) { const lpd = initialTopLpds[i]; if (nearMinLpds.some(near => near.value === lpd.value)) continue; // Não substitui um que já está perto do mín
                         if (lpd.frequency < minFreq) { minFreq = lpd.frequency; minValueAtMinFreq = lpd.value; indexToReplace = i; } else if (lpd.frequency === minFreq && lpd.value < minValueAtMinFreq) { minValueAtMinFreq = lpd.value; indexToReplace = i; } } // Desempate pelo menor valor
                        if (indexToReplace !== -1) {
                            const lpdToReplace = initialTopLpds[indexToReplace];
                            selectionLog.push(`   - Plano a Substituir (Menor Freq): ${lpdToReplace.value}(${lpdToReplace.frequency})`);
                            let adjustedSelectedTopLpds = [...initialTopLpds]; adjustedSelectedTopLpds[indexToReplace] = bestNearMinLpd;
                            adjustedSelectedTopLpds.sort((a, b) => b.frequency - a.frequency || a.value - b.value); // Reordena para consistência de exibição
                            finalSelectedLpdsForProportion = adjustedSelectedTopLpds;
                            selectionLog.push(`<span class="info">   => Planos Finais para Cálculo: [${finalSelectedLpdsForProportion.map(l => `${l.value}(${l.frequency})`).join(', ')}]</span>`);
                        } else {
                             selectionLog.push(`<span class="warning">   - Não foi possível encontrar Plano adequado para substituir. Usando seleção inicial.</span>`);
                             finalSelectedLpdsForProportion = initialTopLpds; // Fallback
                        }
                    } else {
                        selectionLog.push(`<span class="warning">   - Nenhum candidato próximo ao mínimo disponível para substituição. Usando seleção inicial.</span>`);
                        finalSelectedLpdsForProportion = initialTopLpds; // Fallback
                    }
                }
            } else { // requestedCombinationSize == 0
                 selectionLog.push(`Tamanho de combinação solicitado é 0. O resultado será vazio.`);
                 finalSelectedLpdsForProportion = [];
            }
            functionLog.push(selectionLog.join('\n'));


            // 6. Realizar Cálculo Proporcional (Similar ao bloco de fallback)
            functionLog.push(`<div class="proportional-direct-section">--- Cálculo Proporcional ---`);
            let propCalcLog = [];
            const averageValuePerSlot = (maxSlotsForTargetCalc > 0 && sumAmounts > 0) ? (sumAmounts / maxSlotsForTargetCalc) : 0;
            propCalcLog.push(`Valor Médio por Imagem: ${averageValuePerSlot.toFixed(2)}`);

            if (requestedCombinationSize === 1) {
                propCalcLog.push(`Tam. combo 1: Usando média arredondada.`);
                const roundedAverage = roundToNearest(averageValuePerSlot, PROPORTIONAL_ROUNDING_STEP);
                 if (roundedAverage <= 0 && averageValuePerSlot > 0) { propCalcLog.push(`<span class="error">Erro: Média arredondada <= 0.</span>`); finderStatus = "Error"; }
                 else if (roundedAverage <= 0) { propCalcLog.push(`Info: Média arredondada <= 0. Usando combo vazia.`); foundCombination = []; }
                 else { foundCombination = [roundedAverage]; }
                 if (foundCombination !== null) propCalcLog.push(`Combo Calculada (Tam 1): [${foundCombination.join(', ')}]`);
            } else if (requestedCombinationSize > 1) { // Usa os Planos selecionados no passo 5
                const selectedLpdValues = finalSelectedLpdsForProportion.map(lpd => lpd.value);
                propCalcLog.push(`Usando Valores de Planos para Proporções: [${selectedLpdValues.join(', ')}] (Da etapa de seleção)`);
                const totalLpdValueMass = selectedLpdValues.reduce((sum, val) => sum + val, 0);
                propCalcLog.push(`Soma dos Planos (Base): ${totalLpdValueMass}`);
                if (totalLpdValueMass <= 0) { propCalcLog.push(`<span class="error">Erro: Soma dos Planos selecionados <= 0.</span>`); finderStatus = "Error"; }
                else if (averageValuePerSlot <= 0) { propCalcLog.push(`Info: Valor médio <= 0. Resultado vazio.`); foundCombination = []; }
                else {
                    propCalcLog.push(`Distribuindo Valor Médio (${averageValuePerSlot.toFixed(2)})...`);
                    const proportionalCombination = selectedLpdValues.map(lpdVal => roundToNearest(averageValuePerSlot * (lpdVal / totalLpdValueMass), PROPORTIONAL_ROUNDING_STEP));
                    const finalProportionalCombination = proportionalCombination.filter(v => v > 0);
                    if (finalProportionalCombination.length === 0) { propCalcLog.push(`<span class="warning">Aviso: Proporcional resultou em nenhum Plano positivo. Usando vazio.</span>`); foundCombination = []; }
                    else if (finalProportionalCombination.length < requestedCombinationSize) { propCalcLog.push(`<span class="warning">Aviso: Apenas ${finalProportionalCombination.length} Planos positivos resultaram (req ${requestedCombinationSize}). Usando valores positivos.</span>`); foundCombination = finalProportionalCombination.sort((a,b) => a - b); }
                    else { foundCombination = finalProportionalCombination.sort((a,b) => a - b).slice(0, requestedCombinationSize); } // Garante o tamanho correto
                    if (foundCombination !== null) { const sumOfProp = foundCombination.reduce((sum, val) => sum + val, 0); propCalcLog.push(`Combo Proporcional Calculada (Arred., >0): [${foundCombination.join(', ')}]`); propCalcLog.push(`Soma: ${sumOfProp} (vs Média Imagem: ${averageValuePerSlot.toFixed(2)})`); }
                }
            } else { // requestedCombinationSize == 0
                 propCalcLog.push(`Tam. combo 0 solicitado. Resultado vazio.`);
                 foundCombination = [];
            }
            functionLog.push(propCalcLog.join('\n') + `</div>`);

            return {
                combination: foundCombination,
                log: functionLog.join('\n'),
                status: finderStatus
            };
        }


        // --- LÓGICA CENTRAL DO ALOCADOR (runAllocationProcess - Permanece a mesma da v0.4, com traduções nos logs) ---
        function runAllocationProcess(itemsToProcess, userLpdCombinationWithDuplicates, maxSlotsPerInstance) {
            // ... (Lógica exatamente igual à da versão anterior v0.4, mas com logs traduzidos) ...
            // Retorna { itemAllocations: [], cumulativeUsage: {}, remainingSlots: {}, logs: {adjustment:"", variation:""} }
             const logs = { adjustment: '', variation: '' }; const maxSlotsIsFinite = maxSlotsPerInstance !== Infinity; const maxSlotsDisplayLocal = maxSlotsIsFinite ? maxSlotsPerInstance : "Ilimitado";
             const uniqueLpdValuesLocal = [...new Set(userLpdCombinationWithDuplicates)].sort((a, b) => a - b); const lpdInstanceCountsLocal = {}; userLpdCombinationWithDuplicates.forEach(lpd => { lpdInstanceCountsLocal[lpd] = (lpdInstanceCountsLocal[lpd] || 0) + 1; }); const initialTotalSlotsPerValueLocal = {}; uniqueLpdValuesLocal.forEach(lpd => { const instances = lpdInstanceCountsLocal[lpd] || 0; initialTotalSlotsPerValueLocal[lpd] = maxSlotsIsFinite ? (instances * maxSlotsPerInstance) : Infinity; });
             const currentRemainingSlots = { ...initialTotalSlotsPerValueLocal }; // Renomeado mentalmente para 'imagensRestantesAtuais'
             const currentItemAllocations = new Array(itemsToProcess.length).fill(null).map(() => ({ sum: 0, difference: 0, combination: [], finalUsageCounts: {}, error: null })); // Renomeado mentalmente para 'alocacoesAtuaisEspecificação'
             logs.adjustment += `--- Passo 1: Alocação DP Inicial (Imagens Máx/Instância: ${maxSlotsDisplayLocal}) ---\n`;
             itemsToProcess.forEach((item, i) => { logs.adjustment += `Especificação ${item.index + 1} ('${item.details}', Alvo: ${item.amount}): `; const allocation = findClosestSumWithRepetitionAndSlots([...uniqueLpdValuesLocal], item.amount, currentRemainingSlots); currentItemAllocations[i] = { sum: allocation.sum, difference: allocation.difference, combination: allocation.combination ? [...allocation.combination] : [], finalUsageCounts: {}, error: allocation.error || null }; if (allocation.error) { logs.adjustment += `<span class="error">Erro: ${allocation.error}</span>\n`; } else { logs.adjustment += `Soma Enc ${allocation.sum} (Dif: ${allocation.difference}), Combo: [${allocation.combination.join(', ')}]\n`; if (allocation.combination && allocation.combination.length > 0) { allocation.combination.forEach(lpd => { if (currentRemainingSlots.hasOwnProperty(lpd)) { if (currentRemainingSlots[lpd] > 0) { if (maxSlotsIsFinite) { currentRemainingSlots[lpd]--; } } else { console.warn(`Aviso Imagem Passo 1: Plano ${lpd} usado para Especificação ${item.details} quando imagens eram 0.`); currentItemAllocations[i].error = (currentItemAllocations[i].error || "") + ` Aviso: Usou Plano ${lpd} além das imagens.`; } } else { console.error(`Erro Lógica Passo 1: Plano ${lpd} usado mas não no mapa de imagens.`); currentItemAllocations[i].error = (currentItemAllocations[i].error || "") + ` Erro Crít: Usou Plano ${lpd} não no mapa.`; } }); } } });
             logs.adjustment += `Imagens Rem Após Passo 1: ${JSON.stringify(currentRemainingSlots)}\n`;
             let adjustmentLogHTML = `--- Passo 2: Preenchimento de Imagens (Imagens Máx/Instância: ${maxSlotsDisplayLocal}) ---`; if (maxSlotsIsFinite) { adjustmentLogHTML += `\nImagens Rem Iniciais Passo 2: ${JSON.stringify(currentRemainingSlots, null, 0)}`; let totalRemainingPass2 = Object.values(currentRemainingSlots).reduce((sum, count) => count === Infinity ? sum : sum + count, 0); adjustmentLogHTML += `\nTotal Imagens Finitas Rem: ${totalRemainingPass2}`; let adjustmentSafetyCounter = 0; const maxAdjustments = totalRemainingPass2 + itemsToProcess.length * uniqueLpdValuesLocal.length + 50; while (totalRemainingPass2 > 0 && adjustmentSafetyCounter < maxAdjustments) { adjustmentSafetyCounter++; let bestMove = { lpdToAdd: null, itemIndex: -1, minImpact: Infinity, currentAbsDiff: Infinity }; for (const lpd of uniqueLpdValuesLocal) { if (currentRemainingSlots[lpd] > 0) { for (let i = 0; i < currentItemAllocations.length; i++) { const currentAlloc = currentItemAllocations[i]; if (currentAlloc.error || currentAlloc.sum === undefined) continue; const originalAmount = itemsToProcess[i].amount; const currentSum = currentAlloc.sum; const currentAbsDifference = Math.abs(currentAlloc.difference); const newSum = currentSum + lpd; const newAbsDifference = Math.abs(newSum - originalAmount); const impact = newAbsDifference - currentAbsDifference; if (impact < bestMove.minImpact) { bestMove = { lpdToAdd: lpd, itemIndex: i, minImpact: impact, currentAbsDiff: currentAbsDifference }; } else if (impact === bestMove.minImpact && currentAbsDifference > bestMove.currentAbsDiff) { bestMove = { lpdToAdd: lpd, itemIndex: i, minImpact: impact, currentAbsDiff: currentAbsDifference }; } } } } if (bestMove.lpdToAdd !== null) { const lpd = bestMove.lpdToAdd; const itemIdx = bestMove.itemIndex; adjustmentLogHTML += `<div class="adjustment-step">Passo ${adjustmentSafetyCounter}: Adic Plano <span class="info">${lpd}</span> ao Especificação ${itemsToProcess[itemIdx].index + 1} ('${itemsToProcess[itemIdx].details}') (Impacto: ${bestMove.minImpact >= 0 ? '+' : ''}${bestMove.minImpact.toFixed(0)})`; currentItemAllocations[itemIdx].combination.push(lpd); currentItemAllocations[itemIdx].combination.sort((a, b) => a - b); currentItemAllocations[itemIdx].sum += lpd; currentItemAllocations[itemIdx].difference = currentItemAllocations[itemIdx].sum - itemsToProcess[itemIdx].amount; if (maxSlotsIsFinite) { currentRemainingSlots[lpd]--; totalRemainingPass2--; adjustmentLogHTML += `\n   -> Nova Soma: ${currentItemAllocations[itemIdx].sum}, Dif: ${currentItemAllocations[itemIdx].difference.toFixed(0)}, Imagens Rem ${lpd}: ${currentRemainingSlots[lpd]}</div>`; } else { adjustmentLogHTML += `\n   -> Nova Soma: ${currentItemAllocations[itemIdx].sum}, Dif: ${currentItemAllocations[itemIdx].difference.toFixed(0)} (Imagens Ilimitadas)</div>`; } } else { adjustmentLogHTML += `\n<span class="warning">Parado Passo 2: Nenhum movimento benéfico. ${totalRemainingPass2} imagens finitas restantes.</span>`; break; } } if (adjustmentSafetyCounter >= maxAdjustments) { adjustmentLogHTML += `\n<span class="error">Parado Passo 2: Limite de segurança (${maxAdjustments}) atingido.</span>`; } adjustmentLogHTML += `\nImagens Rem Após Passo 2: ${JSON.stringify(currentRemainingSlots)}`; } else { adjustmentLogHTML += `\n(Pulado: Imagens Máx Ilimitadas)`; } logs.adjustment = adjustmentLogHTML;
             let variationLogHTML = `--- Passo 3: Correção de Variação (Alvo: ±${(VARIATION_LIMIT_PASS_3 * 100).toFixed(0)}%) ---`; let madeVariationAdjustment = true; let variationLoopCounter = 0; const maxVariationLoops = itemsToProcess.length * uniqueLpdValuesLocal.length * 3 + 50; while (madeVariationAdjustment && variationLoopCounter < maxVariationLoops) { variationLoopCounter++; madeVariationAdjustment = false; let worstViolation = { index: -1, percentageDiff: 0, absDifference: 0 }; currentItemAllocations.forEach((alloc, i) => { if (alloc && !alloc.error && alloc.difference !== undefined) { const item = itemsToProcess[i]; const targetAmount = item.amount; let currentAbsPercentage = 0; const currentAbsDifference = Math.abs(alloc.difference); if (targetAmount > 0) { currentAbsPercentage = currentAbsDifference / targetAmount; } else if (alloc.sum !== 0) { currentAbsPercentage = Infinity; } if (currentAbsPercentage > VARIATION_LIMIT_PASS_3) { if (currentAbsPercentage > worstViolation.percentageDiff || (currentAbsPercentage === worstViolation.percentageDiff && currentAbsDifference > worstViolation.absDifference)) { worstViolation = { index: i, percentageDiff: currentAbsPercentage, absDifference: currentAbsDifference }; } } } }); if (worstViolation.index === -1) { variationLogHTML += `\nIter ${variationLoopCounter}: Nenhum item > ±${(VARIATION_LIMIT_PASS_3 * 100).toFixed(0)}%. Passo 3 completo.`; break; } const itemIdx = worstViolation.index; const currentAlloc = currentItemAllocations[itemIdx]; const originalAmount = itemsToProcess[itemIdx].amount; const isOverTarget = currentAlloc.difference > 0; variationLogHTML += `<div class="variation-step">Iter ${variationLoopCounter}: Corrigindo Especificação ${itemsToProcess[itemIdx].index + 1} ('${itemsToProcess[itemIdx].details}') - Dif: ${currentAlloc.difference.toFixed(0)} (${(worstViolation.percentageDiff * 100).toFixed(1)}%)`; let bestFix = { action: null, lpd: null, finalAbsDiff: Math.abs(currentAlloc.difference), finalPercDiff: worstViolation.percentageDiff }; const currentCombinationCopy = [...currentAlloc.combination]; for (const lpdToRemove of new Set(currentCombinationCopy)) { const newSum = currentAlloc.sum - lpdToRemove; const newSignedDiff = newSum - originalAmount; const newAbsDiff = Math.abs(newSignedDiff); let newPercentageDiff = Infinity; if (originalAmount > 0) { newPercentageDiff = newAbsDiff / originalAmount; } else if (newSum === 0) { newPercentageDiff = 0; } if (newPercentageDiff <= VARIATION_LIMIT_PASS_3) { if (newAbsDiff < bestFix.finalAbsDiff) { bestFix = { action: 'remove', lpd: lpdToRemove, finalAbsDiff: newAbsDiff, finalPercDiff: newPercentageDiff }; } } else if (bestFix.action === null && newAbsDiff < bestFix.finalAbsDiff) { bestFix = { action: 'remove', lpd: lpdToRemove, finalAbsDiff: newAbsDiff, finalPercDiff: newPercentageDiff }; } } for (const lpdToAdd of uniqueLpdValuesLocal) { if (maxSlotsIsFinite && currentRemainingSlots[lpdToAdd] <= 0) continue; const newSum = currentAlloc.sum + lpdToAdd; const newSignedDiff = newSum - originalAmount; const newAbsDiff = Math.abs(newSignedDiff); let newPercentageDiff = Infinity; if (originalAmount > 0) { newPercentageDiff = newAbsDiff / originalAmount; } else if (newSum === 0) { newPercentageDiff = 0; } if (newPercentageDiff <= VARIATION_LIMIT_PASS_3) { if (newAbsDiff < bestFix.finalAbsDiff) { bestFix = { action: 'add', lpd: lpdToAdd, finalAbsDiff: newAbsDiff, finalPercDiff: newPercentageDiff }; } } else if (bestFix.action === null && newAbsDiff < bestFix.finalAbsDiff) { bestFix = { action: 'add', lpd: lpdToAdd, finalAbsDiff: newAbsDiff, finalPercDiff: newPercentageDiff }; } } if (bestFix.action) { madeVariationAdjustment = true; const lpd = bestFix.lpd; variationLogHTML += ` -> Ação: <span class="info">${bestFix.action === 'remove' ? 'REMOVER' : 'ADICIONAR'} ${lpd}</span>`; if (bestFix.action === 'remove') { const indexToRemove = currentItemAllocations[itemIdx].combination.indexOf(lpd); if (indexToRemove > -1) { currentItemAllocations[itemIdx].combination.splice(indexToRemove, 1); currentItemAllocations[itemIdx].sum -= lpd; currentItemAllocations[itemIdx].difference -= lpd; if (maxSlotsIsFinite) { currentRemainingSlots[lpd]++; } } else { console.error(`Erro VFix: remover ${lpd} não encontrado em ${itemIdx}`); variationLogHTML += ` <span class="error">(Erro!)</span>`; madeVariationAdjustment = false; } } else { currentItemAllocations[itemIdx].combination.push(lpd); currentItemAllocations[itemIdx].combination.sort((a, b) => a - b); currentItemAllocations[itemIdx].sum += lpd; currentItemAllocations[itemIdx].difference += lpd; if (maxSlotsIsFinite) { currentRemainingSlots[lpd]--; } } const finalPercDiffCheck = originalAmount > 0 ? Math.abs(currentItemAllocations[itemIdx].difference / originalAmount) : (currentItemAllocations[itemIdx].sum === 0 ? 0 : Infinity); variationLogHTML += ` -> Nova Dif: ${currentItemAllocations[itemIdx].difference.toFixed(0)} (${(finalPercDiffCheck * 100).toFixed(1)}%)`; if (finalPercDiffCheck <= VARIATION_LIMIT_PASS_3) { variationLogHTML += ` <span class="success">(OK)</span>`; } else { variationLogHTML += ` <span class="warning">(Ainda Alto)</span>`; } if (maxSlotsIsFinite) { variationLogHTML += `, Imagens Rem ${lpd}: ${currentRemainingSlots[lpd]}`; } } else { variationLogHTML += ` -> <span class="warning">Nenhuma correção encontrada. Parando Passo 3.</span>`; madeVariationAdjustment = false; } variationLogHTML += `</div>`; } if (variationLoopCounter >= maxVariationLoops) { variationLogHTML += `\n<span class="error">Parado Passo 3: Limite de loop (${maxVariationLoops}) atingido.</span>`; } logs.variation = variationLogHTML;
             let finalCumulativeUsage = {}; uniqueLpdValuesLocal.forEach(lpd => { finalCumulativeUsage[lpd] = 0; }); currentItemAllocations.forEach(alloc => { alloc.finalUsageCounts = {}; if (!alloc.error && alloc.combination) { alloc.combination.forEach(lpd => { alloc.finalUsageCounts[lpd] = (alloc.finalUsageCounts[lpd] || 0) + 1; if (finalCumulativeUsage.hasOwnProperty(lpd)) { finalCumulativeUsage[lpd]++; } else { console.error(`Erro Lógica Contagem Final: Plano ${lpd} usado mas não na lista única.`); } }); } });
             return { itemAllocations: currentItemAllocations, cumulativeUsage: finalCumulativeUsage, remainingSlots: currentRemainingSlots, logs: logs };
        }

        // --- FUNÇÕES DE EXIBIÇÃO DO ALOCADOR (displayStrategyDetails, etc. - Permanece a mesma da v0.4, com traduções) ---
        function displayStrategyDetails(encodedStrategyName) { // exibirDetalhesEstrategia
             const strategyName = decodeURIComponent(encodedStrategyName); console.log(`Exibindo detalhes para: ${strategyName}`); const statusAreaDiv = document.getElementById('statusArea'); const detailsTitle = document.getElementById('detailsTitle'); const selectedResult = globalStrategyResults.find(res => res.strategyName === strategyName); const allocationResultsDiv = document.getElementById('allocationResults'); const adjustmentLogDiv = document.getElementById('adjustmentLog'); const variationLogDiv = document.getElementById('variationLog'); const cumulativeUsageDiv = document.getElementById('cumulativeUsage'); const lpdBreakdownDiv = document.getElementById('lpdBreakdown'); const finalSummaryTableDiv = document.getElementById('finalSummaryTableDiv'); allocationResultsDiv.innerHTML = 'Carregando...'; adjustmentLogDiv.innerHTML = ''; variationLogDiv.innerHTML = ''; cumulativeUsageDiv.innerHTML = ''; lpdBreakdownDiv.innerHTML = ''; finalSummaryTableDiv.innerHTML = '';
             if (!selectedResult) { statusAreaDiv.innerHTML = `<span class="error">Erro: Não foi possível encontrar resultados para "${strategyName}".</span>`; detailsTitle.innerHTML = 'Resultados Detalhados'; allocationResultsDiv.innerHTML = ''; return; }
             if (!selectedResult.resultData || !selectedResult.resultData.itemAllocations) { statusAreaDiv.innerHTML = `<span class="error">Erro: Dados incompletos para "${strategyName}".</span>`; detailsTitle.innerHTML = 'Resultados Detalhados'; allocationResultsDiv.innerHTML = '<span class="error">Dados incompletos.</span>'; return; }
             try { statusAreaDiv.innerHTML = `Exibindo detalhes para estratégia: <span class="info">${strategyName}</span>`; detailsTitle.innerHTML = `Resultados Detalhados da Alocação (Estratégia: ${strategyName})`; const finalItems = selectedResult.itemsUsed; const finalAllocations = selectedResult.resultData.itemAllocations; const finalCumulativeUsage = selectedResult.resultData.cumulativeUsage; const finalRemainingSlots = selectedResult.resultData.remainingSlots; const finalLogs = selectedResult.resultData.logs; const uniqueLpdValuesDisplay = globalUniqueLpdValues; const maxSlotsDisplayLocal = globalMaxSlotsDisplay; const originalItemsUnsorted = globalOriginalItems; const initialTotalSlotsPerValueLocal = globalInitialTotalSlotsPerValue; const lpdInstanceCountsLocal = globalLpdInstanceCounts; const userLpdCombinationWithDuplicatesLocal = globalUserLpdCombinationWithDuplicates; const maxSlotsNum = globalMaxSlotsPerInstance; const maxSlotsIsFinite = globalMaxSlotsPerInstance !== Infinity; adjustmentLogDiv.innerHTML = finalLogs.adjustment || "Nenhum registro de ajuste."; variationLogDiv.innerHTML = finalLogs.variation || "Nenhum registro de variação.";
                 let finalAllocationHTML = `--- Alocações Finais por Especificação (Estratégia: ${selectedResult.strategyName}) ---`; if (finalItems && finalAllocations && finalItems.length === finalAllocations.length) { finalItems.forEach((item, i) => { finalAllocationHTML += `<div class="item-allocation">`; finalAllocationHTML += `<b>${i + 1}. ${item.details}</b> (Linha Orig: ${item.originalIndex + 1}, Alvo: ${item.amount})\n`; const finalAlloc = finalAllocations[i]; if (!finalAlloc) { finalAllocationHTML += `<span class="error">Dados de aloc. ausentes.</span>\n`; } else if (finalAlloc.error) { finalAllocationHTML += `<span class="error">Erro Aloc: ${finalAlloc.error}</span>\n`; } else if (finalAlloc.sum !== undefined) { const finalPercDiff = item.amount > 0 ? (finalAlloc.difference / item.amount) : (finalAlloc.sum === 0 ? 0 : Infinity); const absFinalPercDiff = Math.abs(finalPercDiff); let diffClass = finalAlloc.difference === 0 ? 'zero-diff' : (finalAlloc.difference > 0 ? 'positive-diff' : 'negative-diff'); let diffSign = finalAlloc.difference > 0 ? '+' : ''; finalAllocationHTML += `<span class="highlight">Soma: ${finalAlloc.sum}</span> (Dif: <span class="${diffClass}">${diffSign}${finalAlloc.difference.toFixed(0)}</span>`; if (item.amount > 0) { finalAllocationHTML += ` / ${(finalPercDiff * 100).toFixed(1)}%`; if (absFinalPercDiff > REPROCESS_VARIATION_LIMIT) { finalAllocationHTML += ` <span class="violation">>±${(REPROCESS_VARIATION_LIMIT * 100).toFixed(0)}%</span>`; } else if (absFinalPercDiff > VARIATION_LIMIT_PASS_3) { finalAllocationHTML += ` <span class="warning">>±${(VARIATION_LIMIT_PASS_3 * 100).toFixed(0)}%</span>`; } } else if (finalAlloc.sum !== 0) { finalAllocationHTML += ` <span class="violation">Soma não zero para alvo zero</span>`; } finalAllocationHTML += `)\n`; if (finalAlloc.combination && finalAlloc.combination.length > 0) { finalAllocationHTML += `   Combo (${finalAlloc.combination.length}): [${finalAlloc.combination.join(', ')}]`; if (finalAlloc.finalUsageCounts && Object.keys(finalAlloc.finalUsageCounts).length > 0) { finalAllocationHTML += `\n   Uso: { ${Object.entries(finalAlloc.finalUsageCounts).map(([lpd, count]) => `"${lpd}": ${count}`).join(', ')} }`; } else { finalAllocationHTML += `\n   Uso: {}`; } } else { finalAllocationHTML += `   (Nenhum Plano alocado)`; } } else { finalAllocationHTML += "<span class='error'>Estrutura Aloc Inválida</span>"; } finalAllocationHTML += `</div>`; }); } else { finalAllocationHTML += '<span class="error">Incompatibilidade Especificação/Aloc.</span>'; } allocationResultsDiv.innerHTML = finalAllocationHTML;
                 let usageSummaryHTML = `<div class="usage-summary">--- Uso Acumulado de Planos (Estrat: ${selectedResult.strategyName}, Imagens Máx/Inst: ${maxSlotsDisplayLocal}) ---<ul>`; if (uniqueLpdValuesDisplay && uniqueLpdValuesDisplay.length > 0) { uniqueLpdValuesDisplay.forEach(lpd => { const initialTotal = initialTotalSlotsPerValueLocal[lpd] || 0; const usedTotal = finalCumulativeUsage[lpd] || 0; let remainingTotal; if(maxSlotsIsFinite) { remainingTotal = finalRemainingSlots.hasOwnProperty(lpd) ? finalRemainingSlots[lpd] : (initialTotal - usedTotal); } else { remainingTotal = Infinity; } const numInstances = lpdInstanceCountsLocal[lpd] || 0; usageSummaryHTML += `<li>Plano <b>${lpd}</b> (${numInstances} inst): Usado <b>${usedTotal}</b>`; if (maxSlotsIsFinite) { usageSummaryHTML += ` (Inicial: ${initialTotal}, Rem: ${remainingTotal})`; if (remainingTotal < 0) { usageSummaryHTML += ` <span class="error">(Erro de Imagem!)</span>`; } else if (usedTotal + remainingTotal !== initialTotal && initialTotal !== Infinity) { console.warn(`Incompatibilidade Imagem Plano ${lpd}: Usado ${usedTotal}, Rem ${remainingTotal}, Inicial ${initialTotal}. Estrat: ${strategyName}`); usageSummaryHTML += ` <span class="warning">(Incompatibilidade Contagem?)</span>`; } } usageSummaryHTML += `</li>`; }); } else { usageSummaryHTML += "<li>Nenhum Plano para rastrear.</li>"; } usageSummaryHTML += "</ul></div>"; cumulativeUsageDiv.innerHTML = usageSummaryHTML;
                 // Montagem dos Planos (lpdBreakdown)
                 let lpdBreakdownHTML = `<div class="lpd-section-title">--- Montagem dos Planos por Instância (Estrat: ${selectedResult.strategyName}) ---`; const allLpdUses = []; finalItems.forEach((item, i) => { const finalAlloc = finalAllocations[i]; if (finalAlloc && !finalAlloc.error && finalAlloc.combination) { finalAlloc.combination.forEach(lpdVal => { allLpdUses.push({ itemIndex: i, itemDetails: item.details, lpdValue: lpdVal, assignedInstanceKey: null }); }); } }); const lpdInstanceCounters = {}; const breakdownByInstance = {}; if (userLpdCombinationWithDuplicatesLocal && userLpdCombinationWithDuplicatesLocal.length > 0) { userLpdCombinationWithDuplicatesLocal.forEach(lpdInputVal => { const currentInstanceNum = (lpdInstanceCounters[lpdInputVal] || 0) + 1; lpdInstanceCounters[lpdInputVal] = currentInstanceNum; const instanceKey = `${lpdInputVal}_${currentInstanceNum}`; breakdownByInstance[instanceKey] = { lpdValue: lpdInputVal, instanceNum: currentInstanceNum, items: [], total: 0 }; let assignedToThisInstance = 0; for (let use of allLpdUses) { if (use.lpdValue === lpdInputVal && use.assignedInstanceKey === null) { if (!maxSlotsIsFinite || assignedToThisInstance < maxSlotsNum) { use.assignedInstanceKey = instanceKey; assignedToThisInstance++; } if (maxSlotsIsFinite && assignedToThisInstance >= maxSlotsNum) break; } } }); Object.keys(breakdownByInstance).forEach(instanceKey => { const instanceData = breakdownByInstance[instanceKey]; const usesForThisInstance = allLpdUses.filter(use => use.assignedInstanceKey === instanceKey); instanceData.total = usesForThisInstance.length; const itemsMap = {}; usesForThisInstance.forEach(use => { itemsMap[use.itemDetails] = (itemsMap[use.itemDetails] || 0) + 1; }); instanceData.items = Object.entries(itemsMap).map(([details, count]) => ({ details, count })).sort((a, b) => a.details.localeCompare(b.details)); }); Object.keys(breakdownByInstance).sort((a, b) => { const lA = breakdownByInstance[a].lpdValue, lB = breakdownByInstance[b].lpdValue; const iA = breakdownByInstance[a].instanceNum, iB = breakdownByInstance[b].instanceNum; return lA - lB || iA - iB; }).forEach(instanceKey => { const instanceData = breakdownByInstance[instanceKey]; lpdBreakdownHTML += `<div class="lpd-section"><span class="lpd-section-title">Plano: ${instanceData.lpdValue} (Instância ${instanceData.instanceNum})</span>`; if (instanceData.items.length > 0) { lpdBreakdownHTML += `<ul class="lpd-item-list">`; instanceData.items.forEach(itemUse => { lpdBreakdownHTML += `<li>${itemUse.details}: ${itemUse.count}x</li>`; }); lpdBreakdownHTML += `</ul><div class="lpd-total">Total Usado: ${instanceData.total}`; if (maxSlotsIsFinite) { lpdBreakdownHTML += ` / ${maxSlotsNum}`; if (instanceData.total > maxSlotsNum) { lpdBreakdownHTML += ` <span class="error">(Excedeu!)</span>`; } } lpdBreakdownHTML += `</div>`; } else { lpdBreakdownHTML += `\n   (Não usado)`; } lpdBreakdownHTML += `</div>`; }); const unassignedUses = allLpdUses.filter(use => use.assignedInstanceKey === null); if (unassignedUses.length > 0) { console.warn(`Estrat ${strategyName}: ${unassignedUses.length} usos de Plano não atribuídos.`, unassignedUses); lpdBreakdownHTML += `<div class="lpd-section"><span class="lpd-section-title warning">Aviso: ${unassignedUses.length} usos de Plano não atribuídos.</span></div>`; } } else { lpdBreakdownHTML += "<p>Nenhuma combinação de Planos para detalhar.</p>"; } lpdBreakdownDiv.innerHTML = lpdBreakdownHTML;
                 // Tabela Comparativa (finalSummaryTableDiv)
                 let summaryTableHTML = `<div class="lpd-section-title">--- Tabela Comparativa (Estrat: ${selectedResult.strategyName}) ---</div><table id="finalSummaryTable"><thead><tr><th>Especificação</th><th>Quantidade</th><th>Empenho</th><th>Dif</th><th>Var (%)</th></tr></thead><tbody>`; const allocationMap = new Map(); finalItems.forEach((item, i) => { allocationMap.set(item.originalIndex, { itemData: item, allocationData: finalAllocations[i] }); }); originalItemsUnsorted.forEach(originalItem => { const resultEntry = allocationMap.get(originalItem.originalIndex); let Especificação = originalItem.details; let quantidade = originalItem.amount; let empenho = 'N/A'; let difHtml = 'N/A'; let varHtml = 'N/A'; if (resultEntry && resultEntry.allocationData) { const finalAlloc = resultEntry.allocationData; if (!finalAlloc.error && finalAlloc.sum !== undefined) { empenho = finalAlloc.sum.toFixed(0); const dif = finalAlloc.difference; let difClass = dif === 0 ? 'zero-diff' : (dif > 0 ? 'positive-diff' : 'negative-diff'); let difSign = dif > 0 ? '+' : ''; difHtml = `<span class="${difClass}">${difSign}${dif.toFixed(0)}</span>`; if (quantidade > 0) { const percentage = (dif / quantidade); const percentageFmt = (percentage * 100).toFixed(1) + '%'; varHtml = percentageFmt; if (Math.abs(percentage) > REPROCESS_VARIATION_LIMIT) { varHtml = `<span class="violation">${percentageFmt}</span>`; } else if (Math.abs(percentage) > VARIATION_LIMIT_PASS_3) { varHtml = `<span class="warning">${percentageFmt}</span>`; } } else if (finalAlloc.sum !== 0) { varHtml = `<span class="violation">N/A</span>`; } else { varHtml = '0.0%'; } } else if (finalAlloc.error) { empenho = `<span class="error">Erro</span>`; let shortError = finalAlloc.error.length > 50 ? finalAlloc.error.substring(0, 47) + '...' : finalAlloc.error; difHtml = `<span class="error" title="${finalAlloc.error}">${shortError}</span>`; varHtml = `<span class="error">Erro</span>`; } } else { empenho = '<span class="warning">N/A</span>'; difHtml = '<span class="warning">N/A</span>'; varHtml = '<span class="warning">N/A</span>'; } summaryTableHTML += `<tr><td>${Especificação}</td><td>${quantidade}</td><td>${empenho}</td><td>${difHtml}</td><td>${varHtml}</td></tr>`; }); summaryTableHTML += `</tbody></table>`; finalSummaryTableDiv.innerHTML = summaryTableHTML; updateComparisonTableHighlight(strategyName);
             } catch (e) { console.error(`Erro ao exibir detalhes para ${strategyName}:`, e); statusAreaDiv.innerHTML = `<span class="error">Erro ao exibir detalhes para "${strategyName}". Verifique o console. Err: ${e.message}</span>`; allocationResultsDiv.innerHTML = '<span class="error">Erro de Exibição</span>'; adjustmentLogDiv.innerHTML = ''; variationLogDiv.innerHTML = ''; cumulativeUsageDiv.innerHTML = ''; lpdBreakdownDiv.innerHTML = ''; finalSummaryTableDiv.innerHTML = ''; detailsTitle.innerHTML = `Resultados Detalhados (Erro)`; }
        }
        function updateComparisonTableHighlight(selectedStrategyName) { // atualizarDestaqueTabelaComparacao
             const table = document.getElementById('comparisonTable'); if (!table) return; const tbody = table.getElementsByTagName('tbody')[0]; if (!tbody) return; const rows = tbody.getElementsByTagName('tr'); for (let row of rows) { row.classList.remove('best-effort'); const firstCell = row.cells[0]; if (firstCell) { firstCell.textContent = firstCell.textContent.replace(/\s*\(Selecionado\)$/, '').trim(); const currentStrategyName = firstCell.textContent; const resultEntry = globalStrategyResults.find(res => res.strategyName === currentStrategyName); row.classList.remove('strategy-error-row'); if (resultEntry && resultEntry.hasAllocationError) { row.classList.add('strategy-error-row'); } if (currentStrategyName === selectedStrategyName) { row.classList.add('best-effort'); firstCell.textContent = `${currentStrategyName} (Selecionado)`; } } }
        }
        function toggleErrorStrategies() { // alternarEstrategiasComErro
             const container = document.getElementById('comparisonTableContainer'); const button = document.getElementById('toggleErrorsBtn'); if (container && button) { const hiding = container.classList.toggle('hide-errors'); const errorRowCount = globalStrategyResults.filter(r => r.hasAllocationError).length; button.textContent = hiding ? `Mostrar ${errorRowCount} Estrat. c/ Erro...` : `Ocultar ${errorRowCount} Estrat. c/ Erro...`; }
        }


        // --- FUNÇÃO PRINCIPAL DE CONTROLE (Atualizada) ---
        function initiateProcess(mode) { // Modo é 'findBest' ou 'forceProportional'
            console.clear();
            console.log(`--- Iniciando Processo (Modo: ${mode}) ---`);

            // --- 1. Obter Entradas & Resetar UI (Comum) ---
            const tableDataInput = document.getElementById('tableData').value.trim();
            const maxSlotsInput = document.getElementById('maxSlots').value.trim(); // Imagens no Plano
            const combinationSizeInput = document.getElementById('combinationSize').value.trim(); // Quantidade de Planos
            const finderResultsLogDiv = document.getElementById('finderResultsLog');
            const foundCombinationDisplayDiv = document.getElementById('foundCombinationDisplay');
            const statusAreaDiv = document.getElementById('statusArea'); // Status Alocador
            const strategyComparisonDiv = document.getElementById('strategyComparison');
            const allocationResultsDiv = document.getElementById('allocationResults'); // Saídas Detalhadas Alocador...
            const adjustmentLogDiv = document.getElementById('adjustmentLog');
            const variationLogDiv = document.getElementById('variationLog');
            const cumulativeUsageDiv = document.getElementById('cumulativeUsage');
            const lpdBreakdownDiv = document.getElementById('lpdBreakdown'); // Montagem dos Planos
            const finalSummaryTableDiv = document.getElementById('finalSummaryTableDiv'); // Tabela Comparativa
            const detailsTitleH2 = document.getElementById('detailsTitle');

            finderResultsLogDiv.innerHTML = `Processando Combinação (Modo: ${mode})...`; // Atualiza msg inicial
            foundCombinationDisplayDiv.innerHTML = "";
            statusAreaDiv.innerHTML = "Aguardando Combinação...";
            strategyComparisonDiv.innerHTML = ""; allocationResultsDiv.innerHTML = ""; adjustmentLogDiv.innerHTML = ""; variationLogDiv.innerHTML = ""; cumulativeUsageDiv.innerHTML = ""; lpdBreakdownDiv.innerHTML = ""; finalSummaryTableDiv.innerHTML = ""; detailsTitleH2.innerHTML = 'Resultados Detalhados da Alocação';
            globalStrategyResults = []; globalOriginalItems = []; globalUniqueLpdValues = []; globalUserLpdCombinationWithDuplicates = []; globalLpdInstanceCounts = {}; globalInitialTotalSlotsPerValue = {}; globalMaxSlotsPerInstance = Infinity; globalMaxSlotsDisplay = "Ilimitado";

            // --- 2. Validar Entradas Principais (Comum) ---
            if (!tableDataInput) { finderResultsLogDiv.innerHTML = '<span class="error">Erro: Dados da tabela vazios.</span>'; return; }
            if (!maxSlotsInput) { finderResultsLogDiv.innerHTML = '<span class="error">Erro: "Imagens no Plano" é obrigatório.</span>'; return; }
            if (!combinationSizeInput) { finderResultsLogDiv.innerHTML = '<span class="error">Erro: "Quantidade de Planos" é obrigatório.</span>'; return; }
            let maxSlotsPerInstance; let combinationSize;
             try { maxSlotsPerInstance = parseInt(maxSlotsInput); if (isNaN(maxSlotsPerInstance) || maxSlotsPerInstance < 1) throw new Error('"Imagens no Plano" >= 1.'); globalMaxSlotsPerInstance = maxSlotsPerInstance; globalMaxSlotsDisplay = String(maxSlotsPerInstance); } catch (e) { finderResultsLogDiv.innerHTML = `<span class="error">Erro de Entrada: ${e.message}</span>`; return; }
             try { combinationSize = parseInt(combinationSizeInput); if (isNaN(combinationSize) || combinationSize < 1) throw new Error('"Quantidade de Planos" >= 1.'); } catch (e) { finderResultsLogDiv.innerHTML = `<span class="error">Erro de Entrada: ${e.message}</span>`; return; }

            // --- 3. Processar Dados da Tabela (Comum) ---
            let parsedItems = []; let parseErrors = []; const lines = tableDataInput.split('\n'); let minRawAmount = Infinity, maxRawAmount = -Infinity, sumRawAmount = 0, validItemCount = 0;
            lines.forEach((line, index) => { line = line.trim(); if (!line) return; let parts = line.split('\t'); let details = ''; if (parts.length < 2) parts = line.split(/\s+/); if (parts.length < 2) { parseErrors.push(`L${index + 1}: Não foi possível dividir: "${line}"`); return; } const amountStr = parts[parts.length - 1].replace(/,/g, ''); details = parts.slice(0, -1).join(parts.length > 2 && line.includes('\t') ? '\t' : ' '); const amount = parseInt(amountStr); if (isNaN(amount)) { parseErrors.push(`L${index + 1}: Quantidade NaN ('${parts[parts.length - 1]}') para "${details}"`); return; } if (amount < 0) { parseErrors.push(`L${index + 1}: Quantidade negativa (${amount}) para "${details}"`); return; } parsedItems.push({ details: details, amount: amount, originalIndex: index }); sumRawAmount += amount; validItemCount++; if (amount < minRawAmount) minRawAmount = amount; if (amount > maxRawAmount) maxRawAmount = amount; });
            if (parseErrors.length > 0) { finderResultsLogDiv.innerHTML = `<span class="error">Erros ao Processar:</span>\n${parseErrors.join('\n')}`; return; }
            if (parsedItems.length === 0) { finderResultsLogDiv.innerHTML = `<span class="error">Erro: Nenhum Especificação válido processado.</span>`; return; }
            globalOriginalItems = parsedItems; // Armazena os Especificações originais
            console.log(`Processados ${validItemCount} Especificações. Soma: ${sumRawAmount}, Mín: ${minRawAmount}, Máx: ${maxRawAmount}`);

            // --- 4. Determinar Combinação de Planos baseado no modo ---
            finderResultsLogDiv.innerHTML = `Gerando Combinação (Modo: ${mode})...`;
            setTimeout(() => {
                try {
                    let combinationResult = null;
                    let combinationMethodDescription = "";

                    if (mode === 'findBest') {
                        console.log("Chamando findBestLpdCombination...");
                        combinationResult = findBestLpdCombination(globalOriginalItems, maxSlotsPerInstance, combinationSize);
                        combinationMethodDescription = "Método Melhor Plano (Padrão/MDC/Prop. Fallback)";
                    } else if (mode === 'forceProportional') {
                        console.log("Chamando calculateDirectProportionalCombination...");
                        combinationResult = calculateDirectProportionalCombination(globalOriginalItems, maxSlotsPerInstance, combinationSize);
                        combinationMethodDescription = "Método Proporcional Direto";
                    } else {
                        throw new Error(`Modo desconhecido: ${mode}`);
                    }

                    // Exibir Log da Combinação
                    finderResultsLogDiv.innerHTML = combinationResult.log;

                    if (combinationResult.status === "Error" || !combinationResult.combination || combinationResult.combination.length === 0) {
                        // Permitir combinação vazia [] se status for OK (ex: alvo era 0)
                        if (combinationResult.status === "OK" && Array.isArray(combinationResult.combination) && combinationResult.combination.length === 0) {
                             foundCombinationDisplayDiv.innerHTML = `<span class="warning">Geração da Combinação resultou em lista vazia []. Prosseguindo para Alocador sem Planos.</span>`;
                             statusAreaDiv.innerHTML = "Combinação vazia. Executando Alocador...";
                             globalUserLpdCombinationWithDuplicates = []; // Garante que é um array vazio
                             globalUniqueLpdValues = [];
                             globalLpdInstanceCounts = {};
                             globalInitialTotalSlotsPerValue = {};
                        } else {
                            foundCombinationDisplayDiv.innerHTML = `<span class="error">Geração da Combinação falhou (Modo: ${mode}). Não é possível prosseguir.</span>`;
                            statusAreaDiv.innerHTML = "Alocador Abortado (Falha na Combinação).";
                            return; // Para o processamento
                        }
                    } else {
                        // Geração da Combinação bem-sucedida
                        globalUserLpdCombinationWithDuplicates = combinationResult.combination;
                        globalUniqueLpdValues = [...new Set(globalUserLpdCombinationWithDuplicates)].sort((a, b) => a - b);
                        globalLpdInstanceCounts = {}; globalUserLpdCombinationWithDuplicates.forEach(lpd => { globalLpdInstanceCounts[lpd] = (globalLpdInstanceCounts[lpd] || 0) + 1; });
                        globalInitialTotalSlotsPerValue = {}; globalUniqueLpdValues.forEach(lpd => { const instances = globalLpdInstanceCounts[lpd] || 0; globalInitialTotalSlotsPerValue[lpd] = globalMaxSlotsPerInstance !== Infinity ? (instances * globalMaxSlotsPerInstance) : Infinity; });

                        console.log("Resultado Combinação (Valores):", globalUserLpdCombinationWithDuplicates);
                        console.log("Resultado Combinação (Únicos):", globalUniqueLpdValues);
                        console.log("Resultado Combinação (Contagens):", globalLpdInstanceCounts);
                        console.log("Resultado Combinação (Imagens Iniciais):", globalInitialTotalSlotsPerValue);

                        foundCombinationDisplayDiv.innerHTML = `Combinação Gerada (<span class="info">${combinationMethodDescription}</span>): <b>[${globalUserLpdCombinationWithDuplicates.join(', ')}]</b> (Tamanho: ${globalUserLpdCombinationWithDuplicates.length})`;
                        statusAreaDiv.innerHTML = `Combinação completa (Modo: ${mode}). Executando Alocador...`;
                    }

                    // --- 5. Executar Alocador usando a combinação gerada ---
                    runAllocatorPhase(); // Chama o alocador independentemente de combo vazia

                } catch (combinationError) {
                    console.error(`Erro durante Geração da Combinação (Modo: ${mode}):`, combinationError);
                    finderResultsLogDiv.innerHTML += `\n<span class="error">Ocorreu um erro inesperado durante a geração da combinação: ${combinationError.message}</span>`;
                    foundCombinationDisplayDiv.innerHTML = `<span class="error">Geração da combinação falhou (Modo: ${mode}).</span>`;
                    statusAreaDiv.innerHTML = "Alocador Abortado (Falha na Combinação).";
                }
            }, 10); // Pequeno timeout para refresh da UI

        } // Fim initiateProcess


        // --- Função da Fase do Alocador (runAllocatorPhase - Permanece a mesma da v0.4, com traduções) ---
        function runAllocatorPhase() {
            console.log("--- Iniciando Fase do Alocador ---");
            const statusAreaDiv = document.getElementById('statusArea');
            const strategyComparisonDiv = document.getElementById('strategyComparison');
            const allocationResultsDiv = document.getElementById('allocationResults');

            // Verifica se o Finder/Gerador forneceu os dados necessários dos *Especificações* (combo pode ser vazia)
            if (!globalOriginalItems || globalOriginalItems.length === 0) {
                statusAreaDiv.innerHTML = `<span class="error">Erro Alocador: Especificações processados ausentes.</span>`;
                return;
            }
            // Log se a combo estiver vazia
            if (!globalUserLpdCombinationWithDuplicates || globalUserLpdCombinationWithDuplicates.length === 0) {
                console.warn("Fase Alocador: Executando com combinação de Planos vazia.");
                // Alocador deve lidar com isso graciosamente (DP provavelmente retornará erros ou somas 0)
            }

            // --- Definir Estratégias de Ordenação (Mesmas 24) ---
             const strategies = [
                 { name: "Ordem Original de Entrada", sortFn: (items) => [...items] },
                 { name: "Quantidade Ascendente", sortFn: (items) => [...items].sort((a, b) => a.amount - b.amount) },
                 { name: "Quantidade Descendente", sortFn: (items) => [...items].sort((a, b) => b.amount - a.amount) },
                 { name: "Especificação Ascendente (A-Z)", sortFn: (items) => [...items].sort((a, b) => a.details.localeCompare(b.details)) },
                 { name: "Especificação Descendente (Z-A)", sortFn: (items) => [...items].sort((a, b) => b.details.localeCompare(a.details)) },
                 { name: "Quantidade Meio-para-Fora (Baixo/Cima)", sortFn: (items) => { const s = [...items].sort((a, b) => a.amount - b.amount), r = [], n = s.length; if (n === 0) return []; const m = Math.floor(n / 2); r.push(s[m]); let l = m - 1, g = m + 1; while (l >= 0 || g < n) { if (l >= 0) r.push(s[l--]); if (g < n) r.push(s[g++]); } return r; }},
                 { name: "Quantidade Meio-para-Fora (Cima/Baixo)", sortFn: (items) => { const s = [...items].sort((a, b) => a.amount - b.amount), r = [], n = s.length; if (n === 0) return []; const m = Math.floor(n / 2); r.push(s[m]); let l = m - 1, g = m + 1; while (l >= 0 || g < n) { if (g < n) r.push(s[g++]); if (l >= 0) r.push(s[l--]); } return r; }},
                 { name: "Especificação Meio-para-Fora (Baixo/Cima)", sortFn: (items) => { const s = [...items].sort((a,b)=>a.details.localeCompare(b.details)), r = [], n = s.length; if (n === 0) return []; const m = Math.floor(n / 2); r.push(s[m]); let l = m - 1, g = m + 1; while (l >= 0 || g < n) { if (l >= 0) r.push(s[l--]); if (g < n) r.push(s[g++]); } return r; }},
                 { name: "Especificação Meio-para-Fora (Cima/Baixo)", sortFn: (items) => { const s = [...items].sort((a,b)=>a.details.localeCompare(b.details)), r = [], n = s.length; if (n === 0) return []; const m = Math.floor(n / 2); r.push(s[m]); let l = m - 1, g = m + 1; while (l >= 0 || g < n) { if (g < n) r.push(s[g++]); if (l >= 0) r.push(s[l--]); } return r; }},
                 { name: "Quantidade Fora-para-Dentro (Intercalado)", sortFn: (items) => { const s = [...items].sort((a,b)=>a.amount - b.amount), r = []; let l = 0, g = s.length - 1; while(l <= g) { r.push(s[l++]); if (l <= g) { r.push(s[g--]); } } return r; }},
                 { name: "Especificação Fora-para-Dentro (Intercalado)", sortFn: (items) => { const s = [...items].sort((a,b)=>a.details.localeCompare(b.details)), r = []; let l = 0, g = s.length - 1; while(l <= g) { r.push(s[l++]); if (l <= g) { r.push(s[g--]); } } return r; }},
                 { name: "Qtd Asc, Especificação Asc (Desempate)", sortFn: (items) => [...items].sort((a, b) => a.amount - b.amount || a.details.localeCompare(b.details)) },
                 { name: "Qtd Asc, Índice Asc (Desempate)", sortFn: (items) => [...items].sort((a, b) => a.amount - b.amount || a.originalIndex - b.originalIndex) },
                 { name: "Qtd Asc, Índice Desc (Desempate)", sortFn: (items) => [...items].sort((a, b) => a.amount - b.amount || b.originalIndex - a.originalIndex) },
                 { name: "Qtd Desc, Índice Asc (Desempate)", sortFn: (items) => [...items].sort((a, b) => b.amount - a.amount || a.originalIndex - b.originalIndex) },
                 { name: "Qtd Desc, Índice Desc (Desempate)", sortFn: (items) => [...items].sort((a, b) => b.amount - a.amount || b.originalIndex - a.originalIndex) },
                 { name: "Quantidade por Último Dígito", sortFn: (items) => [...items].sort((a, b) => (a.amount % 10) - (b.amount % 10) || a.amount - b.amount) },
                 { name: "Quantidade por Primeiro Dígito", sortFn: (items) => { const fd = (n) => {n=Math.abs(n); if(n===0) return 0; while(n>=10) n=Math.floor(n/10); return n;}; return [...items].sort((a, b) => fd(a.amount) - fd(b.amount) || a.amount - b.amount); }},
                 { name: "Qtd Asc (Processa Terços P->G->M)", sortFn: (items) => { const s = [...items].sort((a,b)=>a.amount-b.amount), n=s.length, t=Math.ceil(n/3); return [...s.slice(0,t), ...s.slice(n-t), ...s.slice(t,n-t)]; }}, // P = Pequeno, G = Grande, M = Médio
                 { name: "Qtd Desc (Processa Terços G->P->M)", sortFn: (items) => { const s = [...items].sort((a,b)=>b.amount-a.amount), n=s.length, t=Math.ceil(n/3); return [...s.slice(0,t), ...s.slice(n-t), ...s.slice(t,n-t)]; }}, // G = Grande, P = Pequeno, M = Médio
                 { name: "Qtd Asc (Intercala por 3: 0,3.. 1,4.. 2,5..)", sortFn: (items) => { const s=[...items].sort((a,b)=>a.amount-b.amount), r=[], n=s.length; for(let k=0;k<3;k++) for(let i=k;i<n;i+=3) r.push(s[i]); return r; }},
                 { name: "Qtd Desc (Intercala por 3: 0,3.. 1,4.. 2,5..)", sortFn: (items) => { const s=[...items].sort((a,b)=>b.amount-a.amount), r=[], n=s.length; for(let k=0;k<3;k++) for(let i=k;i<n;i+=3) r.push(s[i]); return r; }},
                 { name: "Desvio da Média Qtd (Mais Próximo Primeiro)", sortFn: (items) => { if(items.length===0) return []; const avg = items.reduce((sum,i)=>sum+i.amount,0)/items.length; return [...items].sort((a,b)=>Math.abs(a.amount-avg)-Math.abs(b.amount-avg)); }},
                 { name: "Desvio da Média Qtd (Mais Distante Primeiro)", sortFn: (items) => { if(items.length===0) return []; const avg = items.reduce((sum,i)=>sum+i.amount,0)/items.length; return [...items].sort((a,b)=>Math.abs(b.amount-avg)-Math.abs(a.amount-avg)); }},
             ];

            let localStrategyResults = [];
            let firstSuccessfulResult = null;
            const comboString = globalUserLpdCombinationWithDuplicates.length > 0 ? `[${globalUserLpdCombinationWithDuplicates.join(', ')}]` : '[Vazia]';
            statusAreaDiv.innerHTML = `Executando alocação para ${strategies.length} estratégias usando combinação ${comboString}... Por favor, aguarde.`;

            setTimeout(() => {
                try {
                    for (const strategy of strategies) {
                        console.log(`--- Executando Estratégia Alocador: ${strategy.name} ---`);
                        const currentItemsOrdered = strategy.sortFn(globalOriginalItems).map((item, idx) => ({ ...item, index: idx })); // Especificações ordenados
                        const result = runAllocationProcess(currentItemsOrdered, [...globalUserLpdCombinationWithDuplicates], globalMaxSlotsPerInstance);
                        let hasAllocationError = false; let firstErrorMessage = "";
                        // Verificação de erro mais robusta
                        if (result && result.itemAllocations) { for(let i = 0; i < result.itemAllocations.length; i++) { const alloc = result.itemAllocations[i]; const item = currentItemsOrdered[i]; if (!alloc) { hasAllocationError = true; firstErrorMessage = "Objeto aloc ausente"; break;} if (alloc.error) { hasAllocationError = true; if (!firstErrorMessage) firstErrorMessage = alloc.error; /* Não quebra para pegar todos os erros no log, mas marca como erro */ } // Condição de erro adicionada: Soma 0 para alvo > 0, indica que DP não conseguiu alocar nada útil
                         if (!alloc.error && item.amount > 0 && alloc.sum === 0 && alloc.combination.length === 0) { hasAllocationError = true; const zeroSumError = "Soma 0 para alvo > 0 (Falha DP?)"; alloc.error = alloc.error ? (alloc.error + "; " + zeroSumError) : zeroSumError; if (!firstErrorMessage) firstErrorMessage = zeroSumError; } } } else { hasAllocationError = true; firstErrorMessage = "Estrutura de resultado inválida"; } if (hasAllocationError) console.warn(`--- Aloc Estrat ${strategy.name}: Erro(s). Primeiro: "${firstErrorMessage}"`);
                        const maxVariation = calculateMaxVariation(currentItemsOrdered, result.itemAllocations); const avgVariation = calculateAverageVariation(currentItemsOrdered, result.itemAllocations); const meetsLimit = !hasAllocationError && maxVariation <= REPROCESS_VARIATION_LIMIT;
                        console.log(`--- Aloc Estrat ${strategy.name} Resultado: VarMáx=${(maxVariation * 100).toFixed(2)}%, VarMéd=${(avgVariation * 100).toFixed(2)}%, TemErro=${hasAllocationError}, AtendeLimite=${meetsLimit}`);
                        const resultEntry = { strategyName: strategy.name, itemsUsed: currentItemsOrdered, resultData: result, maxVariation: maxVariation, avgVariation: avgVariation, meetsLimit: meetsLimit, hasAllocationError: hasAllocationError }; localStrategyResults.push(resultEntry);
                        if (meetsLimit && !firstSuccessfulResult) { firstSuccessfulResult = resultEntry; console.log(`--- Encontrada primeira estratégia alocadora bem-sucedida: ${strategy.name} ---`); }
                    } // Fim loop estratégia

                    globalStrategyResults = localStrategyResults;
                    let finalResultToShow = null; let statusMessage = "";
                    if (firstSuccessfulResult) { finalResultToShow = firstSuccessfulResult; statusMessage = `<span class="success">Visão Padrão: Primeira estratégia dentro do limite: ${finalResultToShow.strategyName}</span>. Clique abaixo...`; }
                    else { if (globalStrategyResults.length > 0) { const errorFreeStrategies = globalStrategyResults.filter(r => !r.hasAllocationError); if (errorFreeStrategies.length > 0) { errorFreeStrategies.sort((a, b) => a.avgVariation - b.avgVariation); finalResultToShow = errorFreeStrategies[0]; const vStr = finalResultToShow.maxVariation === Infinity ? 'Inf' : `${(finalResultToShow.maxVariation * 100).toFixed(1)}%`; const avgStr = (finalResultToShow.avgVariation * 100).toFixed(1) + '%'; statusMessage = `<span class="warning">Visão Padrão: Nenhuma estratégia atendeu ao limite. Mostrando menor <span class="info">var média</span> (sem erro):</span> <span class="info">${finalResultToShow.strategyName}</span> (Máx: ${vStr}, Média: ${avgStr}). Clique abaixo...`; } else { globalStrategyResults.sort((a, b) => a.avgVariation - b.avgVariation); finalResultToShow = globalStrategyResults[0]; const vStr = finalResultToShow.maxVariation === Infinity ? 'Inf' : `${(finalResultToShow.maxVariation * 100).toFixed(1)}%`; const avgStr = (finalResultToShow.avgVariation * 100).toFixed(1) + '%'; statusMessage = `<span class="error">Visão Padrão: Todas as estratégias tiveram erros. Mostrando menor <span class="info">var média</span>:</span> <span class="info">${finalResultToShow.strategyName}</span> (Máx: ${vStr}, Média: ${avgStr}). Clique abaixo...`; } } else { statusMessage = `<span class="error">Erro: Nenhum resultado de estratégia gerado.</span>`; allocationResultsDiv.innerHTML = ''; return; } }
                    statusAreaDiv.innerHTML = statusMessage;

                    // --- Exibir Tabela de Comparação ---
                    let comparisonHTML = `<div class="comparison-title">--- Resumo da Comparação de Estratégias ---</div><div id="comparisonTableContainer" class="comparison-table-container hide-errors"><table id="comparisonTable"><thead><tr><th>Estratégia</th><th>Var Máx (%)</th><th>Var Média (%)</th><th>Resultado</th></tr></thead><tbody>`;
                    const successResults = []; const highVarResults = []; const errorResults = []; globalStrategyResults.forEach(res => { if (res.hasAllocationError) errorResults.push(res); else if (res.meetsLimit) successResults.push(res); else highVarResults.push(res); }); const sortByAvgVar = (a, b) => a.avgVariation - b.avgVariation; successResults.sort(sortByAvgVar); highVarResults.sort(sortByAvgVar); errorResults.sort(sortByAvgVar); const sortedResults = [...successResults, ...highVarResults, ...errorResults]; let errorCount = errorResults.length;
                    sortedResults.forEach(res => { let maxVarStr = ""; if (res.maxVariation === Infinity) { maxVarStr = '<span class="violation">Infinita</span>'; } else { maxVarStr = (res.maxVariation * 100).toFixed(1) + '%'; if (!res.meetsLimit && !res.hasAllocationError) maxVarStr = `<span class="warning">${maxVarStr}</span>`; } let avgVarStr = (res.avgVariation * 100).toFixed(1) + '%'; let outcomeStr = ''; let rowClass = ''; if (res.hasAllocationError) { outcomeStr = `<span class="error">Erro</span>`; rowClass = 'strategy-error-row'; } else if (res.meetsLimit) { outcomeStr = `<span class="success">Sucesso</span>`; } else { outcomeStr = `<span class="warning">Var Alta</span>`; } const isSelectedStrategy = (finalResultToShow && res.strategyName === finalResultToShow.strategyName); if (isSelectedStrategy) rowClass = `${rowClass} best-effort`.trim(); comparisonHTML += `<tr class="${rowClass}"><td class="strategy-name" onclick="displayStrategyDetails('${encodeURIComponent(res.strategyName)}')">${res.strategyName} ${isSelectedStrategy ? '(Selecionado)' : ''}</td><td>${maxVarStr}</td><td>${avgVarStr}</td><td>${outcomeStr}</td></tr>`; });
                    comparisonHTML += `</tbody></table></div>`; if (errorCount > 0) { comparisonHTML += `<button id="toggleErrorsBtn" onclick="toggleErrorStrategies()">Mostrar ${errorCount} Estrat. c/ Erro...</button>`; } strategyComparisonDiv.innerHTML = comparisonHTML;

                    // --- Exibir Detalhes Padrão ---
                    if (finalResultToShow) displayStrategyDetails(encodeURIComponent(finalResultToShow.strategyName));
                    else allocationResultsDiv.innerHTML = 'Nenhuma estratégia padrão disponível.';

                } catch (allocatorError) {
                    console.error("Erro durante processamento da estratégia do Alocador:", allocatorError);
                    statusAreaDiv.innerHTML = `<span class="error">Erro na fase do Alocador. Verifique o console. Err: ${allocatorError.message}</span>`;
                    allocationResultsDiv.innerHTML = `<span class="error">Alocador Falhou</span>`; strategyComparisonDiv.innerHTML = "";
                }
            }, 10); // Timeout para loop aloc

        } // Fim runAllocatorPhase

    </script>

</body>
</html>