<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>LPD Combination & Allocation Finder</title>
    <style>
        /* ... (styles remain the same) ... */
         body { font-family: sans-serif; padding: 20px; }
        label { display: block; margin-top: 10px; margin-bottom: 5px; font-weight: bold; }
        textarea { width: 90%; min-height: 150px; margin-bottom: 10px; font-family: monospace; }
        input[type="number"] { padding: 8px; margin-bottom: 10px; width: 120px; }
        button { padding: 10px 15px; cursor: pointer; background-color: #007bff; color: white; border: none; border-radius: 4px; margin-top: 10px; }
        button:hover { background-color: #0056b3; }
        #results, #allocationResults { margin-top: 20px; padding: 15px; border: 1px solid #ccc; background-color: #f9f9f9; white-space: pre-wrap; font-family: monospace; }
        .error { color: red; font-weight: bold; }
        .info { color: blue; }
        .input-group { margin-bottom: 15px; }
        .highlight { background-color: yellow; font-weight: bold; }
    </style>
</head>
<body>

    <h1>Find LPD Combination & Allocate Special Number (with Repetition)</h1>

    <!-- ... (HTML inputs remain the same) ... -->
    <div class="input-group">
        <label for="tableData">Table Data (Details + Amount, one per line):</label>
        <textarea id="tableData" placeholder="Example: Tempero Para Aves	3000..."></textarea>
    </div>
    <div class="input-group">
        <label for="targetSum">Target Sum for LPD Combination:</label>
        <input type="number" id="targetSum" placeholder="e.g., 37000">
    </div>
    <div class="input-group">
        <label for="combinationSize">Number of LPDs in Combination:</label>
        <input type="number" id="combinationSize" value="4" min="2">
    </div>
    <div class="input-group">
        <label for="specialNumber">Special Number to Allocate:</label>
        <input type="number" id="specialNumber" placeholder="e.g., 70000">
    </div>
    <button onclick="processAll()">Find Combination & Allocate</button>
    <div id="results">LPD Combination results will appear here...</div>
    <div id="allocationResults">Special Number Allocation results will appear here...</div>


    <script>
        let lastFoundLpdCombination = null; // Store the last successful LPD combination

        // --- Recursive Combination Finder (for LPDs to sum to target) ---
        // Finds *one* combination of k distinct LPDs summing to target
        function findSumCombinationRecursive(lpdValues, target, k, startIndex, currentCombination) {
             // ... (same implementation as before) ...
            if (currentCombination.length === k) {
                const currentSum = currentCombination.reduce((sum, item) => sum + item, 0);
                if (currentSum === target) return currentCombination;
                return null;
            }
            if (startIndex >= lpdValues.length || lpdValues.length - startIndex < k - currentCombination.length) {
                return null;
            }
            for (let i = startIndex; i < lpdValues.length; i++) {
                currentCombination.push(lpdValues[i].value);
                const result = findSumCombinationRecursive(lpdValues, target, k, i + 1, currentCombination);
                if (result) return result;
                currentCombination.pop();
            }
            return null;
        }


        // --- Find Closest Sum using LPDs with Repetition Allowed (Change-Making DP) ---
        // lpdArray: The array of LPDs from the *found combination* (used as denominations)
        // target: The special number
        function findClosestSumWithRepetitionMinCoins(lpdArray, target) {
            if (!lpdArray || lpdArray.length === 0) {
                 console.warn("LPD array empty for allocation.");
                 return { sum: 0, difference: Math.abs(target), combination: [], error: "No LPDs provided" };
            }
             if (target < 0) { // Handle negative target just in case
                  console.warn("Target special number is negative.");
                  return { sum: 0, difference: Math.abs(target), combination: [], error: "Negative target" };
             }

            lpdArray = [...new Set(lpdArray)].sort((a, b) => a - b); // Use unique LPDs and sort

            if (lpdArray.length === 0 || lpdArray[0] <= 0) {
                 console.warn("LPD array invalid for allocation (empty or non-positive).");
                 return { sum: 0, difference: Math.abs(target), combination: [], error: "Invalid LPDs" };
            }
            const smallestLpd = lpdArray[0];

            // Determine DP table size: up to target + smallest LPD - 1
            // This ensures we can find sums just above the target.
            const maxSum = target + smallestLpd -1;

            // dp[i] stores the minimum number of LPDs to make sum i
            const dp = new Array(maxSum + 1).fill(Infinity);
            // lastLpd[i] stores the last LPD used to achieve the minimum coin solution for sum i
            const lastLpd = new Array(maxSum + 1).fill(-1);

            dp[0] = 0; // 0 coins to make sum 0

            // Build the DP table
            for (const lpd of lpdArray) {
                for (let i = lpd; i <= maxSum; i++) {
                    if (dp[i - lpd] !== Infinity) { // If the previous sum is reachable
                        if (dp[i - lpd] + 1 < dp[i]) { // If using this LPD is better (fewer items)
                            dp[i] = dp[i - lpd] + 1;
                            lastLpd[i] = lpd;
                        }
                        // Note: No tie-breaking here needed for *building* the table,
                        // just take the first path found that improves the count.
                    }
                }
            }

            // Find the closest sum (minimum difference) among reachable sums
            let minDiff = Infinity;
            let closestSum = -1;

            // Start search from target downwards, then target upwards
             // Search downwards from target
             for (let i = target; i >= 0; i--) {
                 if (dp[i] !== Infinity) {
                      const diff = target - i; // Always non-negative here
                      if (diff < minDiff) {
                          minDiff = diff;
                          closestSum = i;
                      } else if (diff === minDiff) {
                          // Tie-breaking: fewer coins preferred, then largest sum (already handled by search order)
                          if (dp[i] < dp[closestSum]) {
                              closestSum = i;
                          }
                      }
                      // Since we search downwards, the first hit for a diff is the highest sum
                      // If we only want closest abs diff, we need to search up too
                      // break; // Optimization if only closest below is needed? No, need abs diff.
                 }
                 // Optimization: if current diff > minDiff found so far, maybe stop going lower?
                 if (target - i > minDiff && closestSum !== -1) break;
             }

             // Search upwards from target + 1
             for (let i = target + 1; i <= maxSum; i++) {
                  if (dp[i] !== Infinity) {
                      const diff = i - target; // Always positive here
                      if (diff < minDiff) {
                           minDiff = diff;
                           closestSum = i;
                      } else if (diff === minDiff) {
                           // Tie-breaking: fewer coins preferred, then smaller sum (already handled by search order)
                           if (dp[i] < dp[closestSum]) {
                               closestSum = i;
                           } else if (dp[i] === dp[closestSum] && i < closestSum) { // Should not happen if diff is same, but check
                                closestSum = i; // Prefer sum closer to target
                           }
                       }
                       // Optimization: if current diff > minDiff found so far, stop going higher
                       if (i - target >= minDiff && closestSum !== -1) break; // Use >= because minDiff could be 0
                  }
             }


            // Handle case where no sum is reachable (e.g., target=3, LPDs=[5])
            // or if target is 0.
            if (closestSum === -1) {
                if (target === 0 && dp[0] === 0) { // Special case: target is 0
                     closestSum = 0;
                     minDiff = 0;
                } else { // No reachable sum found (or target was unreachable non-zero)
                    closestSum = 0; // Closest reachable is 0
                    minDiff = Math.abs(target - 0);
                    console.warn(`Could not find any reachable sum for target ${target} using LPDs. Closest is 0.`);
                }
            }


            // Reconstruct the combination using lastLpd array
            const combination = [];
            let currentSum = closestSum;
            let safetyCounter = 0;
            const maxLoops = (closestSum / smallestLpd) + lpdArray.length + 100; // Generous limit

            while (currentSum > 0 && safetyCounter < maxLoops) {
                const usedLpd = lastLpd[currentSum];
                if (usedLpd === -1 || usedLpd <= 0) {
                     console.error(`Backtracking error: Invalid LPD (${usedLpd}) found for sum ${currentSum}. Aborting combination.`);
                     return { sum: closestSum, difference: minDiff, combination: [], error: `Backtracking failed at ${currentSum}` };
                }
                combination.push(usedLpd);
                currentSum -= usedLpd;
                safetyCounter++;
            }
             if (safetyCounter >= maxLoops) {
                 console.error("Backtracking limit reached - potential infinite loop.");
                 return { sum: closestSum, difference: minDiff, combination: [], error: "Backtracking limit" };
             }

             // Verify reconstruction (optional sanity check)
            const reconstructedSum = combination.reduce((a, b) => a + b, 0);
            if (reconstructedSum !== closestSum) {
                 console.error(`Backtracking verification error: Reconstructed sum ${reconstructedSum} does not match closest sum ${closestSum}`);
                 return { sum: closestSum, difference: minDiff, combination: combination.sort((a,b)=>a-b), error: `Reconstruction mismatch (${reconstructedSum} != ${closestSum})` };
            }

            return { sum: closestSum, difference: minDiff, combination: combination.sort((a,b)=>a-b) };
        }


        // --- Main Processing Function ---
        function processAll() {
            // ... (Input reading and validation remain the same) ...
            const tableDataInput = document.getElementById('tableData').value.trim();
            const targetSumInput = document.getElementById('targetSum').value;
            const combinationSizeInput = document.getElementById('combinationSize').value;
            const specialNumberInput = document.getElementById('specialNumber').value;
            const resultsDiv = document.getElementById('results');
            const allocationResultsDiv = document.getElementById('allocationResults');
            resultsDiv.innerHTML = 'Processing LPD Combination...';
            allocationResultsDiv.innerHTML = 'Waiting for LPD Combination...';
            lastFoundLpdCombination = null;

            if (!tableDataInput) { resultsDiv.innerHTML = '<span class="error">Error: Table data cannot be empty.</span>'; return; }
            if (!targetSumInput) { resultsDiv.innerHTML = '<span class="error">Error: Target sum cannot be empty.</span>'; return; }
            if (!combinationSizeInput) { resultsDiv.innerHTML = '<span class="error">Error: Number of LPDs cannot be empty.</span>'; return; }

            const initialTargetSum = parseInt(targetSumInput);
            const combinationSize = parseInt(combinationSizeInput);
            const specialNumber = specialNumberInput ? parseInt(specialNumberInput) : null;

            if (isNaN(initialTargetSum)) { resultsDiv.innerHTML = '<span class="error">Error: Invalid Target Sum.</span>'; return; }
            if (isNaN(combinationSize) || combinationSize < 2) { resultsDiv.innerHTML = `<span class="error">Error: Invalid Number of LPDs.</span>`; return; }
            if (specialNumberInput && (isNaN(specialNumber) || specialNumber < 0)) { // Also check for negative special number
                 allocationResultsDiv.innerHTML = '<span class="error">Error: Invalid or negative Special Number.</span>'; return;
            }

            // 1. Parse Table Data
             // ... (same parsing as before) ...
            const lines = tableDataInput.split('\n'); const lpdFrequencies = {}; let parseErrors = [];
            lines.forEach((line, index) => { line = line.trim(); if (!line) return; let parts = line.split('\t'); if (parts.length < 2) parts = line.split(/\s+/); if (parts.length < 2) { parseErrors.push(`L${index + 1}: Split error.`); return; } const amountStr = parts[parts.length - 1]; const amount = parseInt(amountStr); if (isNaN(amount)) { parseErrors.push(`L${index + 1}: Amt NaN "${amountStr}".`); return; } if (amount <= 0) { parseErrors.push(`L${index + 1}: Amt <=0 "${amount}".`); return; } if (amount % 2 !== 0) { parseErrors.push(`L${index + 1}: Amt odd "${amount}".`); return; } const lpd = amount / 2; lpdFrequencies[lpd] = (lpdFrequencies[lpd] || 0) + 1; });
            if (parseErrors.length > 0) { resultsDiv.innerHTML = `<span class="error">Parse errors:</span>\n${parseErrors.join('\n')}`; return; }
            const uniqueLpdList = Object.entries(lpdFrequencies).map(([lpd, freq]) => ({ value: parseInt(lpd), frequency: freq })).sort((a, b) => b.frequency - a.frequency);
            if (uniqueLpdList.length < combinationSize) { resultsDiv.innerHTML = `<span class="error">Need at least ${combinationSize} unique LPDs. Found ${uniqueLpdList.length}.</span>`; return; }

            // 2. Find LPD Combination (summing to initialTargetSum)
             // ... (same logic as before using findSumCombinationRecursive and adjustment loop) ...
            const MAX_INITIAL_TRIES = 10; const MAX_ADJUSTMENT_ITERATIONS = 20;
            let currentLpdSumTarget = initialTargetSum; let lpdAttempts = 0; let lpdAdjustment = 500; let lpdDirection = 1;
            let foundLpdCombination = null; let lpdSearchLog = [`Searching for ${combinationSize} LPDs summing to: ${initialTargetSum}`];
            while (lpdAttempts < MAX_INITIAL_TRIES + MAX_ADJUSTMENT_ITERATIONS * 2) { if (lpdAttempts > 0) lpdSearchLog.push(`Attempt ${lpdAttempts + 1}: Trying sum ${currentLpdSumTarget}...`); foundLpdCombination = findSumCombinationRecursive(uniqueLpdList, currentLpdSumTarget, combinationSize, 0, []); if (foundLpdCombination) { lpdSearchLog.push(`\n<span class="highlight">Success! Found LPD combination for sum ${currentLpdSumTarget}.</span>`); lastFoundLpdCombination = foundLpdCombination.sort((a,b)=>a-b); break; } lpdAttempts++; if (lpdAttempts >= MAX_INITIAL_TRIES) { currentLpdSumTarget = initialTargetSum + lpdDirection * lpdAdjustment; lpdDirection *= -1; if (lpdDirection === 1) lpdAdjustment += 500; } }

            // 3. Allocate Special Number (if LPD combination found and special number provided)
            if (lastFoundLpdCombination) {
                resultsDiv.innerHTML = lpdSearchLog.join('\n') + `\n\nFound LPD Combination (${combinationSize} LPDs): [${lastFoundLpdCombination.join(', ')}] \nTargeted Sum: ${currentLpdSumTarget}`;

                if (specialNumber !== null) {
                    allocationResultsDiv.innerHTML = `Allocating Special Number: ${specialNumber} using LPDs: [${lastFoundLpdCombination.join(', ')}] with repetition allowed...`;

                    // Use the new allocation function
                    const allocation = findClosestSumWithRepetitionMinCoins(lastFoundLpdCombination, specialNumber);

                    let allocMsg = `Special Number: ${specialNumber}\nUsing LPDs: [${lastFoundLpdCombination.join(', ')}] (Repetition allowed)\n\n`;
                    if (allocation.error) {
                         allocMsg += `<span class="error">Allocation Error: ${allocation.error}</span>\n`;
                         allocMsg += `Closest Sum Found: ${allocation.sum}\nDifference: ${allocation.difference}`;
                         if(allocation.combination && allocation.combination.length > 0) {
                             allocMsg += `\nPartial/Incomplete Combination: [${allocation.combination.join(', ')}]`;
                         }
                    } else if (allocation.sum !== undefined) {
                         allocMsg += `<span class="highlight">Closest Achievable Sum: ${allocation.sum}</span>\n(Difference from Special Number: ${allocation.difference})\nAchieved with combination: [${allocation.combination.join(', ')}]`;
                    } else {
                         allocMsg += "<span class='error'>Could not determine allocation result.</span>";
                    }
                    allocationResultsDiv.innerHTML = allocMsg;

                } else {
                    allocationResultsDiv.innerHTML = "No Special Number provided for allocation.";
                }
            } else {
                 resultsDiv.innerHTML = lpdSearchLog.join('\n') + `\n\n<span class="error">No LPD combination found summing near ${initialTargetSum}.</span>`;
                 allocationResultsDiv.innerHTML = "Cannot allocate Special Number as no LPD combination was found.";
            }
        }
    </script>

</body>
</html>