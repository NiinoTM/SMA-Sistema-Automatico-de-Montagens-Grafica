<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>LPD Combination Finder v0.3.2 (GCD Fallback)</title>
    <style>
        /* Basic styling (same as v0.3.1) */
        body { font-family: sans-serif; padding: 20px; }
        label { display: block; margin-top: 10px; margin-bottom: 5px; font-weight: bold; }
        textarea { width: 90%; min-height: 150px; margin-bottom: 10px; font-family: monospace; }
        input[type="number"] { padding: 8px; margin-bottom: 10px; width: 120px; }
        button { padding: 10px 15px; cursor: pointer; background-color: #007bff; color: white; border: none; border-radius: 4px; margin-top: 10px; }
        button:hover { background-color: #0056b3; }
        #results { margin-top: 20px; padding: 15px; border: 1px solid #ccc; background-color: #f9f9f9; white-space: pre-wrap; font-family: monospace; }
        .error { color: red; font-weight: bold; }
        .info { color: blue; }
        .success { color: green; font-weight: bold; }
        .fallback { color: darkorange; font-weight: bold; } /* Style for fallback messages */
        .input-group { margin-bottom: 15px; }
        .highlight { background-color: yellow; font-weight: bold; }
        .target-section { border-top: 2px solid #aaa; padding-top: 10px; margin-top: 15px; }
        .candidate-section { border-left: 3px solid #ddd; padding-left: 10px; margin-top: 5px; margin-bottom: 5px; }
        .fallback-section { border-top: 2px solid darkorange; padding-top: 10px; margin-top: 15px; } /* Style for fallback section */

    </style>
</head>
<body>

    <h1>LPD Combination Finder (Target Range Sum / GCD Fallback, Highest Frequency near Min Amount, >=2000)</h1>
    <p>Calculates a target sum range based on Max Slots/total amount. Finds the best combination (highest frequency, including one LPD near min amount) for multiples of 500 in that range. If no LPD near min amount is found, attempts a fallback using the GCD of input amounts.</p>

    <!-- Input fields (same as v0.3.1) -->
    <div class="input-group">
        <label for="tableData">Table Data (Details + Amount, one per line):</label>
        <textarea id="tableData" placeholder="Example:
Item A	3000 (min amount)
Item B  4000 (freq 5)
Item C	7500 (freq 8)
..."></textarea>
    </div>
    <div class="input-group">
        <label for="maxSlots">Max Slots per LPD Instance (Cumulative):</label>
        <input type="number" id="maxSlots" min="1" placeholder="e.g., 16" required>
    </div>
    <div class="input-group">
        <label for="combinationSize">Number of Distinct LPDs (>=2000) in Combination (Standard Method):</label>
        <input type="number" id="combinationSize" value="4" min="2">
    </div>
    <button onclick="findBestCombination()">Find Best Combination</button>

    <!-- Output area -->
    <div id="results">LPD Combination results will appear here...</div>

    <script>
        // --- CONFIGURATION RULES ---
        const MIN_LPD_VALUE = 2000;
        const OBLIGATORY_RANGE = 500; // Range +/- from minAmountFound for standard method
        const TARGET_RANGE_BELOW = 500;
        const TARGET_RANGE_ABOVE = 1000;
        const TARGET_STEP = 500;
        // --- ---

        // --- Helper Functions ---

        // Greatest Common Divisor (Euclidean Algorithm)
        function gcd(a, b) {
            a = Math.abs(a);
            b = Math.abs(b);
            if (b === 0) return a;
            return gcd(b, a % b);
        }

        // GCD of an array of numbers
        function arrayGcd(numbers) {
            if (!numbers || numbers.length === 0) return 0; // Or throw error?
            if (numbers.length === 1) return Math.abs(numbers[0]);

            let result = Math.abs(numbers[0]);
            for (let i = 1; i < numbers.length; i++) {
                result = gcd(result, numbers[i]);
                if (result === 1) return 1; // Optimization: if GCD becomes 1, it will stay 1
            }
            return result;
        }

        // Recursive Combination Finder (for standard method - requires distinct LPDs)
        // (Function remains the same as v0.3.1)
        function findSumCombinationRecursive(lpdValueObjectsToSearch, target, k, startIndex, currentCombinationValues) {
            if (currentCombinationValues.length === k) {
                const currentSum = currentCombinationValues.reduce((sum, item) => sum + item, 0);
                if (Math.abs(currentSum - target) < 0.01) {
                    return [...currentCombinationValues];
                }
                return null;
            }
            if (startIndex >= lpdValueObjectsToSearch.length ||
                currentCombinationValues.length > k ||
                lpdValueObjectsToSearch.length - startIndex < k - currentCombinationValues.length) {
                return null;
            }
            for (let i = startIndex; i < lpdValueObjectsToSearch.length; i++) {
                const currentLpdValue = lpdValueObjectsToSearch[i].value;
                // Ensure distinct LPD *values* in the combination for the standard method
                if (!currentCombinationValues.includes(currentLpdValue)) {
                    currentCombinationValues.push(currentLpdValue);
                    const result = findSumCombinationRecursive(lpdValueObjectsToSearch, target, k, i + 1, currentCombinationValues);
                    if (result) { return result; }
                    currentCombinationValues.pop(); // Backtrack
                }
            }
            return null;
        }

        // --- Main Processing Function ---
        function findBestCombination() {
            // 1. Read and Validate Inputs
            const tableDataInput = document.getElementById('tableData').value.trim();
            const maxSlotsInput = document.getElementById('maxSlots').value.trim();
            const combinationSizeInput = document.getElementById('combinationSize').value; // Used only for standard method
            const resultsDiv = document.getElementById('results');

            resultsDiv.innerHTML = `Processing LPD Combination (>= ${MIN_LPD_VALUE}, Target Range / GCD Fallback)...`;

            if (!tableDataInput) { resultsDiv.innerHTML = '<span class="error">Error: Table data cannot be empty.</span>'; return; }
            if (!maxSlotsInput) { resultsDiv.innerHTML = '<span class="error">Error: Max Slots value is required.</span>'; return; }

            // 2. Parse Table Data & Calculate SumAmounts
            const lines = tableDataInput.split('\n');
            const lpdFrequencies = {};      // { lpdValue: count }
            const validRawAmounts = [];    // Store the actual valid amounts for GCD fallback
            let parseErrors = [];
            let minAmountFound = Infinity;
            let sumAmounts = 0;

            lines.forEach((line, index) => {
                line = line.trim(); if (!line) return;
                let parts = line.split('\t'); if (parts.length < 2) parts = line.split(/\s+/);
                if (parts.length < 2) { parseErrors.push(`L${index + 1}: Cannot split line: "${line}"`); return; }
                const amountStr = parts[parts.length - 1];
                const amount = parseInt(amountStr);
                if (isNaN(amount)) { parseErrors.push(`L${index + 1}: Amount NaN: "${amountStr}"`); return; }
                if (amount <= 0) { parseErrors.push(`L${index + 1}: Amount <= 0: "${amount}"`); return; }
                if (amount % 2 !== 0) { parseErrors.push(`L${index + 1}: Amount Odd: "${amount}"`); return; }

                // Store valid data
                validRawAmounts.push(amount); // Store the amount itself
                sumAmounts += amount;
                if (amount < minAmountFound) minAmountFound = amount;

                // Store LPD frequency if applicable
                const lpd = amount / 2;
                if (lpd >= MIN_LPD_VALUE) {
                    lpdFrequencies[lpd] = (lpdFrequencies[lpd] || 0) + 1;
                }
            });

            if (parseErrors.length > 0) { resultsDiv.innerHTML = `<span class="error">Input Data Parse Errors:</span>\n${parseErrors.join('\n')}`; return; }
            if (minAmountFound === Infinity || validRawAmounts.length === 0) { resultsDiv.innerHTML = `<span class="error">Error: No valid amounts found in the table data.</span>`; return; }
            if (sumAmounts === 0) { resultsDiv.innerHTML = `<span class="error">Error: Total sum of amounts is zero. Cannot calculate target.</span>`; return; }

            // 3. Prepare Base Data and Validate MaxSlots/Combination Size
            const maxSlots = parseInt(maxSlotsInput);
            if (isNaN(maxSlots) || maxSlots <= 0) {
                resultsDiv.innerHTML = '<span class="error">Error: Invalid Max Slots value. Must be a positive number.</span>';
                return;
            }

            const combinationSize = parseInt(combinationSizeInput); // Standard method size
            if (isNaN(combinationSize) || combinationSize < 2) {
                resultsDiv.innerHTML = `<span class="error">Error: Invalid Number of Distinct LPDs for Standard Method (must be >= 2).</span>`;
                return;
            }

             // Prepare LPD list (needed for both methods)
            const uniqueValidLpdListWithFreq = Object.entries(lpdFrequencies)
                                      .map(([lpd, freq]) => ({ value: parseInt(lpd), frequency: freq }));

             // Log initial findings
            let initialLog = [];
            initialLog.push(`Minimum Amount Found in Table: ${minAmountFound}`);
            initialLog.push(`Total Sum of Amounts: ${sumAmounts}`);
            initialLog.push(`Valid Amounts Found: [${validRawAmounts.join(', ')}]`);
            initialLog.push(`Max Slots: ${maxSlots}`);
            initialLog.push(`Standard Method Combination Size: ${combinationSize}`);
            initialLog.push(`Valid LPDs (>=${MIN_LPD_VALUE}) Found: ${uniqueValidLpdListWithFreq.length} unique values.`);

            // 4. Check for Obligatory Candidates (for standard method)
            const obligatoryCandidates = uniqueValidLpdListWithFreq.filter(lpdObj => {
                 const diff = Math.abs(lpdObj.value - minAmountFound); // Compare LPD value (amount/2) to min amount
                 return diff <= OBLIGATORY_RANGE;
            }).sort((a, b) => a.value - b.value);

            initialLog.push(`Found ${obligatoryCandidates.length} candidate LPD(s) within +/- ${OBLIGATORY_RANGE} of Min Amount (${minAmountFound}): [${obligatoryCandidates.map(c=>c.value).join(', ')}]`);

            // 5. Decide Strategy: Standard or Fallback
            if (obligatoryCandidates.length === 0) {
                // ---=== GCD FALLBACK STRATEGY ===---
                initialLog.push(`<span class="fallback">ALERT: No valid LPDs found near minimum amount. Attempting GCD Fallback Strategy.</span>`);

                let fallbackLog = [`<div class="fallback-section">--- GCD Fallback Calculation ---`];

                const baseTargetAmount = sumAmounts / maxSlots; // Use the average *amount* for GCD target
                fallbackLog.push(`Base Target Amount (Sum/Slots): ${baseTargetAmount.toFixed(2)}`);

                if (validRawAmounts.length < 1) {
                     fallbackLog.push(`<span class="error">Error: Cannot calculate GCD fallback, no valid amounts were parsed.</span>`);
                     resultsDiv.innerHTML = initialLog.join('\n') + '\n' + fallbackLog.join('\n') + `</div>`;
                     return;
                }

                // Calculate GCD of all valid *amounts*
                const gcdAmounts = arrayGcd(validRawAmounts);
                fallbackLog.push(`GCD of all valid amounts (${validRawAmounts.length} values): ${gcdAmounts}`);

                if (gcdAmounts <= 0) {
                    fallbackLog.push(`<span class="error">Error: Calculated GCD of amounts is ${gcdAmounts}. Cannot proceed with fallback.</span>`);
                    resultsDiv.innerHTML = initialLog.join('\n') + '\n' + fallbackLog.join('\n') + `</div>`;
                    return;
                }

                // Find the multiple of the GCD closest to the base target amount
                const fallbackTarget = Math.round(baseTargetAmount / gcdAmounts) * gcdAmounts;
                fallbackLog.push(`Fallback Target (Nearest multiple of GCD to Base Target): ${fallbackTarget}`);

                if (fallbackTarget <= 0) {
                     fallbackLog.push(`<span class="error">Error: Calculated Fallback Target is ${fallbackTarget}. Cannot proceed.</span>`);
                     resultsDiv.innerHTML = initialLog.join('\n') + '\n' + fallbackLog.join('\n') + `</div>`;
                     return;
                }

                 // Check if the target is perfectly divisible by GCD (should be by definition of calculation)
                if (fallbackTarget % gcdAmounts !== 0) {
                     fallbackLog.push(`<span class="error">Error: Fallback Target ${fallbackTarget} is not perfectly divisible by GCD ${gcdAmounts}. Calculation error.</span>`);
                     resultsDiv.innerHTML = initialLog.join('\n') + '\n' + fallbackLog.join('\n') + `</div>`;
                     return;
                }

                const fallbackK = fallbackTarget / gcdAmounts; // Number of times GCD fits into target
                fallbackLog.push(`Required number of GCD units (Target / GCD): ${fallbackK}`);

                // Construct the result: Array of GCD repeated k times
                const fallbackCombination = Array(fallbackK).fill(gcdAmounts);

                 resultsDiv.innerHTML = initialLog.join('\n') + '\n' + fallbackLog.join('\n')
                                    + `\n\n<span class="highlight fallback">GCD Fallback Result: [${fallbackCombination.join(', ')}]</span>`
                                    + `\n(Based on GCD of input amounts, aiming for target amount ${fallbackTarget})`
                                    + `\nCombination Size: ${fallbackK}`
                                    + `</div>`; // Close fallback-section
            } else {
                // ---=== STANDARD STRATEGY (Target Range, Obligatory Candidate) ===---
                initialLog.push(`<span class="info">Standard strategy selected (found LPDs near minimum).</span>`);

                // Calculate Target Sum Range for standard method
                const baseTargetLPD = sumAmounts / maxSlots; // Can use LPD average here or amount average, consistency matters. Using amount avg like fallback.
                const lowerBound = baseTargetLPD - TARGET_RANGE_BELOW;
                const upperBound = baseTargetLPD + TARGET_RANGE_ABOVE;
                const targetsToTest = [];
                const firstMultiple = Math.ceil(lowerBound / TARGET_STEP) * TARGET_STEP;
                const lastMultiple = Math.floor(upperBound / TARGET_STEP) * TARGET_STEP;

                for (let target = firstMultiple; target <= lastMultiple; target += TARGET_STEP) {
                    if (target > 0) { targetsToTest.push(target); }
                }

                initialLog.push(`Base Calculated Target (Sum/Slots): ${baseTargetLPD.toFixed(2)}`);
                initialLog.push(`Target Range Tested (-${TARGET_RANGE_BELOW} / +${TARGET_RANGE_ABOVE}): [${lowerBound.toFixed(2)}, ${upperBound.toFixed(2)}]`);

                if (targetsToTest.length === 0) {
                    initialLog.push(`<span class="error">Error: No positive multiples of ${TARGET_STEP} found in the calculated target range [${lowerBound.toFixed(2)}, ${upperBound.toFixed(2)}] for standard method. Cannot proceed.</span>`);
                    resultsDiv.innerHTML = initialLog.join('\n');
                    return;
                }
                initialLog.push(`Target Sums (multiples of ${TARGET_STEP} in range) to be Tested: [${targetsToTest.join(', ')}]`);


                // Sort LPDs for standard search
                uniqueValidLpdListWithFreq.sort((a, b) => {
                    if (b.frequency !== a.frequency) return b.frequency - a.frequency;
                    return b.value - a.value;
                });
                let frequencyLog = `Valid LPDs Sorted by Frequency (Value(Frequency)): ${uniqueValidLpdListWithFreq.map(l => `${l.value}(${l.frequency})`).join(', ')}`;

                // --- Start Standard Search ---
                const neededOtherLpds = combinationSize - 1;
                let overallSearchLog = [`--- Initial Setup ---`];
                overallSearchLog.push(...initialLog); // Add logs generated so far
                overallSearchLog.push(frequencyLog);
                overallSearchLog.push(`--- Combination Search (Standard Method) ---`);

                let overallBestCombination = null;
                let overallBestFrequencyScore = -1;
                let overallBestTargetSum = null;

                function getFrequencyScore(combination) {
                     let score = 0;
                     for (const lpdValue of combination) { score += (lpdFrequencies[lpdValue] || 0); }
                     return score;
                }

                for (const currentTargetSum of targetsToTest) {
                    overallSearchLog.push(`<div class="target-section">--- Testing Target Sum: ${currentTargetSum} ---`);
                    let foundCombinationForThisTarget = false;

                    for (const currentObligatoryCandidate of obligatoryCandidates) {
                        const currentObligatoryLpdValue = currentObligatoryCandidate.value;
                        overallSearchLog.push(`<div class="candidate-section">=== Trying Obligatory Candidate LPD: ${currentObligatoryLpdValue} for target ${currentTargetSum} ===`);

                        const searchLpdList = uniqueValidLpdListWithFreq.filter(lpdObj => lpdObj.value !== currentObligatoryLpdValue);

                        if (neededOtherLpds > 0 && searchLpdList.length < neededOtherLpds) {
                            overallSearchLog.push(`   Skipping: Not enough other unique LPDs (${searchLpdList.length}) available to find ${neededOtherLpds} more.`);
                            overallSearchLog.push(`</div>`); continue;
                        }

                        const targetForRecursion = currentTargetSum - currentObligatoryLpdValue;
                        overallSearchLog.push(`   Target sum for remaining ${neededOtherLpds} LPDs: ${currentTargetSum} - ${currentObligatoryLpdValue} = ${targetForRecursion}`);

                        let foundKMinus1Combination = null;
                        if (targetForRecursion < 0 && neededOtherLpds > 0) {
                             overallSearchLog.push(`   Skipping: Target for remaining LPDs (${targetForRecursion}) is negative.`);
                        } else if (neededOtherLpds === 0) { // Combination size is 1
                             if (Math.abs(targetForRecursion) < 0.01) { foundKMinus1Combination = []; } // Need 0 more, target matches
                             else { overallSearchLog.push(`   Skipping: Need 0 more LPDs, but obligatory ${currentObligatoryLpdValue} != target ${currentTargetSum}.`); }
                        } else if (targetForRecursion === 0 && neededOtherLpds > 0) {
                             overallSearchLog.push(`   Skipping: Need ${neededOtherLpds} more LPDs, but remaining target is 0.`);
                        } else if (neededOtherLpds > 0 && targetForRecursion > 0) {
                            foundKMinus1Combination = findSumCombinationRecursive(searchLpdList, targetForRecursion, neededOtherLpds, 0, []);
                        }

                        if (foundKMinus1Combination !== null) {
                            const currentFullCombination = [...foundKMinus1Combination, currentObligatoryLpdValue].sort((a, b) => a - b);
                            const currentFrequencyScore = getFrequencyScore(currentFullCombination);
                            overallSearchLog.push(`   <span class="success">Found Exact Sum Combination: [${currentFullCombination.join(', ')}] (Sum: ${currentTargetSum}, Freq Score: ${currentFrequencyScore})</span>`);
                            foundCombinationForThisTarget = true;

                            if (overallBestCombination === null || currentFrequencyScore > overallBestFrequencyScore) {
                                overallSearchLog.push(`   <span class="info">   ** New OVERALL Best Combination Found (Higher Freq Score) **</span>`);
                                overallBestCombination = currentFullCombination;
                                overallBestFrequencyScore = currentFrequencyScore;
                                overallBestTargetSum = currentTargetSum;
                            }
                        } else {
                            overallSearchLog.push(`   -> No combination of ${neededOtherLpds} other distinct LPDs found summing to ${targetForRecursion}.`);
                        }
                        overallSearchLog.push(`</div>`); // Close candidate-section
                    } // End obligatory candidate loop

                    if (!foundCombinationForThisTarget) {
                         overallSearchLog.push(`   <span class="info">No combinations found for target ${currentTargetSum} after trying all obligatory candidates.</span>`);
                    }
                     overallSearchLog.push(`</div>`); // Close target-section
                } // End outer target sum loop

                // --- Display Standard Method Result ---
                resultsDiv.innerHTML = overallSearchLog.join('\n');

                if (overallBestCombination) {
                    resultsDiv.innerHTML += `\n\n<hr>\n`
                                     + `<span class="highlight">Overall Best LPD Combination Found (${combinationSize} LPDs): [${overallBestCombination.join(', ')}]</span>`
                                     + `\n(Standard Method: Highest frequency score among valid combinations for targets [${targetsToTest.join(', ')}])`
                                     + `\nAchieved Target Sum: ${overallBestTargetSum}`
                                     + `\nTotal Frequency Score: ${overallBestFrequencyScore}`;
                } else {
                     resultsDiv.innerHTML += `\n\n<hr>\n`
                                        + `<span class="error">Standard Method Failed: No combination of ${combinationSize} distinct LPDs (>=${MIN_LPD_VALUE}, including one near min amount ${minAmountFound}) found summing EXACTLY to any tested target sum [${targetsToTest.join(', ')}].</span>`;
                }
            } // End Standard vs Fallback if/else

        } // End findBestCombination
    </script>
</body>
</html>